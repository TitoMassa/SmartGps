<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Smart Move Pro</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <!-- Estilos CSS Embebidos -->
    <style>
        /* RESET Y ESTILOS GLOBALES */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden; /* Evita el scroll en el body */
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
        }

        /* LAYOUT PRINCIPAL */
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        #map {
            height: 55vh; /* 55% de la altura de la pantalla */
            width: 100%;
            background-color: #333; /* Color de fondo mientras carga el mapa */
        }

        #controls-container {
            height: 45vh; /* 45% de la altura de la pantalla */
            overflow-y: auto;
            padding: 10px;
            border-top: 2px solid #444;
        }

        /* ESTILOS DE COMPONENTES DE UI */
        h2, h3 {
            margin-top: 10px;
            margin-bottom: 8px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        button, input[type="text"], input[type="time"] {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            background-color: #222;
            border: 1px solid #555;
            color: #FFFFFF;
            border-radius: 5px;
            font-size: 1em;
        }

        button {
            cursor: pointer;
            font-weight: bold;
            background-color: #0056b3;
        }

        button:hover {
            background-color: #006cdd;
        }
        
        button.danger {
            background-color: #b30000;
        }
        button.danger:hover {
            background-color: #dd0000;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }

        .checkbox-container input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
        }
        
        /* PANELES DE CONTROL */
        .panel {
            display: none; /* Ocultos por defecto */
        }
        .panel.active {
            display: block; /* Visible cuando está activo */
        }

        /* LISTA DE PARADAS */
        #stops-list {
            list-style: none;
            padding: 0;
        }

        #stops-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 5px;
            border-bottom: 1px solid #333;
            background-color: #1a1a1a;
            margin-bottom: 3px;
            border-radius: 3px;
        }

        #stops-list li.next-stop-highlight {
            background-color: #004d99;
            border-left: 5px solid #007bff;
        }
        
        #stops-list .stop-info {
            font-size: 0.9em;
        }

        #stops-list .stop-type {
            font-weight: bold;
            font-size: 0.8em;
            padding: 3px 6px;
            border-radius: 10px;
            color: #000;
        }
        
        #stops-list .stop-type-inicio { background-color: #007bff; color: #fff; }
        #stops-list .stop-type-intermedia { background-color: #ff8c00; color: #fff;}
        #stops-list .stop-type-fin { background-color: #8b0000; color: #fff;}

        /* LISTA DE RUTAS GUARDADAS */
        #saved-routes-list .route-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #2a2a2a;
            margin-bottom: 5px;
            border-radius: 4px;
        }

        #saved-routes-list .route-item button {
            width: auto;
            padding: 5px 10px;
            margin-left: 5px;
            font-size: 0.8em;
        }
        
        /* SEGUIMIENTO EN TIEMPO REAL */
        #tracking-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        #tracking-info div {
            background-color: #1c1c1c;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        #tracking-info .label {
            font-size: 0.8em;
            color: #aaa;
        }

        #tracking-info .value {
            font-size: 1.4em;
            font-weight: bold;
        }

        #deviation-display.ahead { color: #00FF00; }
        #deviation-display.late { color: #FF0000; }
        
        #manual-advance-buttons {
            display: none; /* Oculto por defecto */
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        /* ICONOS PERSONALIZADOS DE LEAFLET */
        .leaflet-div-icon {
            background: #000;
            border: 2px solid #FFF;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #FFF;
            font-size: 16px;
        }

        .leaflet-div-icon-start { background-color: #007bff; }
        .leaflet-div-icon-end { background-color: #8b0000; }
        .leaflet-div-icon-intermediate { background-color: #ff8c00; }
        
        /* ICONO DE POSICIÓN DEL CONDUCTOR */
        .user-marker {
            width: 22px;
            height: 22px;
            background-color: #00aaff;
            border-radius: 50%;
            border: 3px solid #ffffff;
            box-shadow: 0 0 10px #00aaff;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(0.9); box-shadow: 0 0 0 0 rgba(0, 170, 255, 0.7); }
            70% { transform: scale(1); box-shadow: 0 0 10px 10px rgba(0, 170, 255, 0); }
            100% { transform: scale(0.9); box-shadow: 0 0 0 0 rgba(0, 170, 255, 0); }
        }

    </style>
</head>
<body>

    <div id="app-container">
        <div id="map"></div>
        <div id="controls-container">
            <!-- Panel Principal -->
            <div id="main-panel" class="panel active">
                <h2>Menú Principal</h2>
                <button id="btn-show-creator">Crear Nueva Ruta</button>
                <button id="btn-show-loader">Cargar Ruta Guardada</button>
                <p style="text-align: center; margin-top: 20px; color: #888;">Bienvenido a Smart Move Pro</p>
            </div>

            <!-- Panel de Creación de Ruta -->
            <div id="route-creator-panel" class="panel">
                <button id="btn-back-to-main-from-creator">‹ Volver al Menú</button>
                <h2>Editor de Ruta</h2>
                <p id="creator-instructions" style="color: #ccc; margin-bottom: 10px; text-align:center;">Toque el mapa para agregar paradas: 1º Inicio, 2º Fin, luego intermedias.</p>
                <input type="text" id="route-name" placeholder="Nombre de la Ruta (ej. Mañana Lunes)">
                <div class="checkbox-container">
                    <input type="checkbox" id="auto-calc-times">
                    <label for="auto-calc-times">Calcular horarios intermedios automáticamente</label>
                </div>
                <h3>Paradas</h3>
                <ol id="stops-list"></ol>
                <button id="btn-save-route">Guardar Ruta</button>
                <button id="btn-clear-route" class="danger">Limpiar Ruta Actual</button>
            </div>
            
            <!-- Panel de Carga de Ruta -->
            <div id="route-loader-panel" class="panel">
                <button id="btn-back-to-main-from-loader">‹ Volver al Menú</button>
                <h2>Rutas Guardadas</h2>
                <div id="saved-routes-list">
                    <p>No hay rutas guardadas.</p>
                </div>
            </div>

            <!-- Panel de Seguimiento -->
            <div id="tracking-panel" class="panel">
                <button id="btn-back-to-main-from-tracking">‹ Finalizar y Volver al Menú</button>
                <h2 id="tracking-route-name"></h2>
                
                <div id="tracking-info">
                    <div>
                        <div class="label">PRÓXIMA PARADA</div>
                        <div id="next-stop-display" class="value">--</div>
                    </div>
                    <div>
                        <div class="label">VELOCIDAD</div>
                        <div id="speed-display" class="value">0 km/h</div>
                    </div>
                    <div style="grid-column: 1 / -1;"> <!-- Ocupa todo el ancho -->
                        <div class="label">DESVÍO HORARIO (+ ADELANTADO / - ATRASADO)</div>
                        <div id="deviation-display" class="value">00:00</div>
                    </div>
                </div>

                <button id="btn-toggle-tracking">Iniciar Seguimiento</button>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="manual-advance-mode">
                    <label for="manual-advance-mode">Avance Manual de Parada</label>
                </div>
                <div id="manual-advance-buttons">
                    <button id="btn-prev-stop">‹ Parada Anterior</button>
                    <button id="btn-next-stop">Siguiente Parada ›</button>
                </div>
            </div>

        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- Lógica de la Aplicación JavaScript Embebida -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- ESTADO GLOBAL DE LA APLICACIÓN ---
        let map;
        let currentRoute = { name: '', stops: [] };
        let trackingState = {
            isTracking: false,
            watchId: null,
            userMarker: null,
            routePolyline: null,
            stopMarkers: [],
            currentSegmentIndex: 0, // El índice de la parada de la que partimos
            lastPosition: null
        };

        // --- CONSTANTES ---
        const PROXIMITY_THRESHOLD = 50; // metros para detectar llegada a parada

        // --- INICIALIZACIÓN ---
        function init() {
            initMap();
            initUI();
            loadSavedRoutes();
        }

        function initMap() {
            map = L.map('map').setView([40.416775, -3.703790], 13); // Vista inicial en Madrid, ES

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            
            map.on('click', onMapClick);
        }

        function initUI() {
            // Navegación entre paneles
            document.getElementById('btn-show-creator').addEventListener('click', () => showPanel('route-creator-panel'));
            document.getElementById('btn-show-loader').addEventListener('click', () => {
                loadSavedRoutes(); // Recargar lista al mostrar
                showPanel('route-loader-panel');
            });
            document.getElementById('btn-back-to-main-from-creator').addEventListener('click', () => showPanel('main-panel'));
            document.getElementById('btn-back-to-main-from-loader').addEventListener('click', () => showPanel('main-panel'));
            document.getElementById('btn-back-to-main-from-tracking').addEventListener('click', () => {
                // Si el seguimiento está activo, detenerlo antes de salir
                if (trackingState.isTracking) {
                    toggleTracking();
                }
                clearCurrentRoute();
                showPanel('main-panel');
            });

            // Controles del creador de rutas
            document.getElementById('btn-save-route').addEventListener('click', saveRoute);
            document.getElementById('btn-clear-route').addEventListener('click', clearCurrentRoute);

            // Controles de seguimiento
            document.getElementById('btn-toggle-tracking').addEventListener('click', toggleTracking);
            document.getElementById('manual-advance-mode').addEventListener('change', (e) => {
                document.getElementById('manual-advance-buttons').style.display = e.target.checked ? 'grid' : 'none';
            });
            document.getElementById('btn-next-stop').addEventListener('click', () => advanceStop(1));
            document.getElementById('btn-prev-stop').addEventListener('click', () => advanceStop(-1));
        }

        // --- GESTIÓN DE PANELES ---
        function showPanel(panelId) {
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            document.getElementById(panelId).classList.add('active');
            // Si entramos al creador de ruta o al panel de seguimiento, reajustamos el tamaño del mapa
            // para asegurar que es visible y tiene el tamaño correcto.
            setTimeout(() => map.invalidateSize(), 100); 
        }

        // --- LÓGICA DE CREACIÓN DE RUTA ---
        function onMapClick(e) {
            // Solo permitir agregar paradas desde el panel de creación
            if (!document.getElementById('route-creator-panel').classList.contains('active')) {
                return;
            }

            const latlng = e.latlng;
            let stopType, promptMessageName, promptMessageTime;

            if (currentRoute.stops.length === 0) {
                stopType = 'Inicio';
                promptMessageName = "Nombre de la parada de INICIO:";
                promptMessageTime = "Hora de SALIDA (HH:MM):";
            } else if (currentRoute.stops.length === 1) {
                stopType = 'Fin';
                promptMessageName = "Nombre de la parada de FIN:";
                promptMessageTime = "Hora de LLEGADA (HH:MM):";
            } else {
                stopType = 'Intermedia';
                promptMessageName = `Nombre de la parada Intermedia #${currentRoute.stops.length - 1}:`;
                promptMessageTime = `Hora programada (HH:MM, opcional):`;
            }

            const name = prompt(promptMessageName);
            if (!name) return; // Cancelado

            let time = prompt(promptMessageTime);
            // Validar hora para inicio y fin
            if ((stopType === 'Inicio' || stopType === 'Fin') && !/^\d{2}:\d{2}$/.test(time)) {
                alert("Formato de hora inválido. Use HH:MM.");
                return;
            }
             // Si es intermedia y no se introduce hora, se deja en blanco
            if (stopType === 'Intermedia' && !/^\d{2}:\d{2}$/.test(time)) {
                time = null;
            }

            const stop = {
                lat: latlng.lat,
                lng: latlng.lng,
                name: name,
                time: time,
                type: stopType,
                id: Date.now() // ID único para la parada
            };

            // Las paradas intermedias se insertan antes del final
            if (stop.type === 'Intermedia') {
                currentRoute.stops.splice(currentRoute.stops.length - 1, 0, stop);
            } else {
                currentRoute.stops.push(stop);
            }
            
            renderRouteOnMapAndList();
        }

        function renderRouteOnMapAndList() {
            // Limpiar mapa
            trackingState.stopMarkers.forEach(m => map.removeLayer(m));
            trackingState.stopMarkers = [];
            if (trackingState.routePolyline) {
                map.removeLayer(trackingState.routePolyline);
                trackingState.routePolyline = null;
            }
            
            // Limpiar lista HTML
            const stopsListEl = document.getElementById('stops-list');
            stopsListEl.innerHTML = '';
            
            // Recalcular el tipo de parada (por si se borra alguna)
            if (currentRoute.stops.length > 0) currentRoute.stops[0].type = 'Inicio';
            if (currentRoute.stops.length > 1) currentRoute.stops[currentRoute.stops.length - 1].type = 'Fin';
            for (let i = 1; i < currentRoute.stops.length - 1; i++) {
                currentRoute.stops[i].type = 'Intermedia';
            }

            const latlngs = [];
            currentRoute.stops.forEach((stop, index) => {
                latlngs.push([stop.lat, stop.lng]);

                // Crear icono personalizado
                let iconHtml = '';
                let iconClass = 'leaflet-div-icon ';
                if (stop.type === 'Inicio') {
                    iconHtml = 'I';
                    iconClass += 'leaflet-div-icon-start';
                } else if (stop.type === 'Fin') {
                    iconHtml = 'F';
                    iconClass += 'leaflet-div-icon-end';
                } else {
                    iconHtml = index; // Las intermedias van de 1 en adelante
                    iconClass += 'leaflet-div-icon-intermediate';
                }
                
                const customIcon = L.divIcon({
                    html: iconHtml,
                    className: iconClass,
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                });

                const marker = L.marker([stop.lat, stop.lng], { icon: customIcon }).addTo(map);
                marker.bindPopup(`<b>${stop.name}</b><br>${stop.type}`);
                trackingState.stopMarkers.push(marker);

                // Añadir a la lista HTML
                const li = document.createElement('li');
                li.innerHTML = `
                    <span class="stop-info">
                        <span class="stop-type stop-type-${stop.type.toLowerCase()}">${stop.type}</span>
                        ${stop.name}
                    </span>
                    <span>${stop.time || 'Auto'}</span>
                `;
                li.dataset.stopId = stop.id;
                stopsListEl.appendChild(li);
            });

            if (latlngs.length > 1) {
                trackingState.routePolyline = L.polyline(latlngs, { color: 'blue' }).addTo(map);
                map.fitBounds(trackingState.routePolyline.getBounds().pad(0.1));
            }
        }
        
        function clearCurrentRoute() {
            if (confirm('¿Seguro que quieres borrar la ruta actual y todas sus paradas?')) {
                currentRoute = { name: '', stops: [] };
                document.getElementById('route-name').value = '';
                renderRouteOnMapAndList();
            }
        }
        
        function calculateAndApplyIntermediateTimes() {
            if (currentRoute.stops.length < 2) return;

            const startTimeStr = currentRoute.stops[0].time;
            const endTimeStr = currentRoute.stops[currentRoute.stops.length - 1].time;

            if (!startTimeStr || !endTimeStr) {
                alert("Se requiere hora de inicio y fin para calcular tiempos intermedios.");
                return false;
            }
            
            const startMillis = timeToMillis(startTimeStr);
            const endMillis = timeToMillis(endTimeStr);
            const totalDuration = endMillis - startMillis;
            
            if (totalDuration <= 0) {
                alert("La hora de fin debe ser posterior a la de inicio.");
                return false;
            }

            let totalDistance = 0;
            const segmentDistances = [];
            for (let i = 0; i < currentRoute.stops.length - 1; i++) {
                const dist = haversineDistance(currentRoute.stops[i], currentRoute.stops[i+1]);
                segmentDistances.push(dist);
                totalDistance += dist;
            }

            if (totalDistance === 0) return true; // Evitar división por cero

            let accumulatedTime = startMillis;
            let accumulatedDistance = 0;
            
            for (let i = 1; i < currentRoute.stops.length - 1; i++) {
                if (!currentRoute.stops[i].time) { // Solo calcular si no tiene hora manual
                    accumulatedDistance += segmentDistances[i-1];
                    const timeOffset = totalDuration * (accumulatedDistance / totalDistance);
                    currentRoute.stops[i].time = millisToTime(startMillis + timeOffset);
                }
            }
            return true;
        }


        // --- GESTIÓN DE RUTAS (LocalStorage) ---
        function saveRoute() {
            const routeName = document.getElementById('route-name').value.trim();
            if (!routeName) {
                alert("Por favor, introduce un nombre para la ruta.");
                return;
            }
            if (currentRoute.stops.length < 2) {
                alert("Una ruta debe tener al menos una parada de inicio y una de fin.");
                return;
            }

            currentRoute.name = routeName;

            if (document.getElementById('auto-calc-times').checked) {
                if (!calculateAndApplyIntermediateTimes()) {
                    return; // Detener guardado si el cálculo falla
                }
            }

            // Verificar que todas las paradas tengan hora
            if (currentRoute.stops.some(stop => !stop.time)) {
                alert("Todas las paradas deben tener un horario definido. Active el cálculo automático o ingrese los horarios manualmente.");
                return;
            }

            let savedRoutes = JSON.parse(localStorage.getItem('smartMoveProRoutes') || '[]');
            // Reemplazar si ya existe una con el mismo nombre
            const existingIndex = savedRoutes.findIndex(r => r.name === routeName);
            if (existingIndex > -1) {
                savedRoutes[existingIndex] = currentRoute;
            } else {
                savedRoutes.push(currentRoute);
            }

            localStorage.setItem('smartMoveProRoutes', JSON.stringify(savedRoutes));
            alert(`Ruta "${routeName}" guardada correctamente.`);
            renderRouteOnMapAndList(); // Actualizar la lista con los tiempos calculados
        }

        function loadSavedRoutes() {
            let savedRoutes = JSON.parse(localStorage.getItem('smartMoveProRoutes') || '[]');
            const listEl = document.getElementById('saved-routes-list');
            listEl.innerHTML = '';

            if (savedRoutes.length === 0) {
                listEl.innerHTML = '<p>No hay rutas guardadas.</p>';
                return;
            }

            savedRoutes.forEach(route => {
                const itemEl = document.createElement('div');
                itemEl.className = 'route-item';
                itemEl.innerHTML = `
                    <span>${route.name}</span>
                    <div>
                        <button class="btn-load" data-route-name="${route.name}">Cargar</button>
                        <button class="btn-delete danger" data-route-name="${route.name}">Borrar</button>
                    </div>
                `;
                listEl.appendChild(itemEl);
            });
            
            // Añadir event listeners a los nuevos botones
            listEl.querySelectorAll('.btn-load').forEach(btn => btn.addEventListener('click', (e) => {
                const routeName = e.target.dataset.routeName;
                const routeToLoad = savedRoutes.find(r => r.name === routeName);
                if (routeToLoad) {
                    currentRoute = JSON.parse(JSON.stringify(routeToLoad)); // Deep copy
                    showPanel('tracking-panel');
                    prepareTrackingPanel();
                }
            }));
            
            listEl.querySelectorAll('.btn-delete').forEach(btn => btn.addEventListener('click', (e) => {
                const routeName = e.target.dataset.routeName;
                if (confirm(`¿Seguro que quieres borrar la ruta "${routeName}"?`)) {
                    deleteRoute(routeName);
                }
            }));
        }

        function deleteRoute(routeName) {
            let savedRoutes = JSON.parse(localStorage.getItem('smartMoveProRoutes') || '[]');
            const filteredRoutes = savedRoutes.filter(r => r.name !== routeName);
            localStorage.setItem('smartMoveProRoutes', JSON.stringify(filteredRoutes));
            loadSavedRoutes(); // Recargar la lista
        }
        
        // --- LÓGICA DE SEGUIMIENTO EN TIEMPO REAL ---

        function prepareTrackingPanel() {
            document.getElementById('tracking-route-name').textContent = `En ruta: ${currentRoute.name}`;
            renderRouteOnMapAndList();
            resetTrackingDisplays();
        }

        function toggleTracking() {
            if (trackingState.isTracking) {
                stopTracking();
            } else {
                startTracking();
            }
        }
        
        function startTracking() {
            if (!navigator.geolocation) {
                alert("Geolocalización no soportada por este navegador.");
                return;
            }
            if (currentRoute.stops.length < 2) {
                alert("Cargue una ruta válida para iniciar el seguimiento.");
                return;
            }

            trackingState.isTracking = true;
            trackingState.currentSegmentIndex = 0;
            document.getElementById('btn-toggle-tracking').textContent = 'Detener Seguimiento';
            document.getElementById('btn-toggle-tracking').classList.add('danger');
            
            trackingState.watchId = navigator.geolocation.watchPosition(
                onPositionUpdate,
                onPositionError,
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
            
            updateNextStopHighlight();
        }

        function stopTracking() {
            if (trackingState.watchId) {
                navigator.geolocation.clearWatch(trackingState.watchId);
            }
            trackingState.isTracking = false;
            trackingState.watchId = null;
            trackingState.lastPosition = null;

            if (trackingState.userMarker) {
                map.removeLayer(trackingState.userMarker);
                trackingState.userMarker = null;
            }
            
            document.getElementById('btn-toggle-tracking').textContent = 'Iniciar Seguimiento';
            document.getElementById('btn-toggle-tracking').classList.remove('danger');
            resetTrackingDisplays();
        }

        function resetTrackingDisplays() {
            document.getElementById('next-stop-display').textContent = currentRoute.stops.length > 0 ? currentRoute.stops[0].name : '--';
            document.getElementById('speed-display').textContent = '0 km/h';
            const deviationEl = document.getElementById('deviation-display');
            deviationEl.textContent = '00:00';
            deviationEl.className = 'value';
            updateNextStopHighlight();
        }

        function onPositionUpdate(position) {
            trackingState.lastPosition = position;
            const { latitude, longitude, speed } = position.coords;
            
            // Actualizar marcador de usuario
            const userLatLng = [latitude, longitude];
            if (!trackingState.userMarker) {
                const userIcon = L.divIcon({ className: 'user-marker', iconSize: [22, 22] });
                trackingState.userMarker = L.marker(userLatLng, { icon: userIcon }).addTo(map);
            } else {
                trackingState.userMarker.setLatLng(userLatLng);
            }
            map.panTo(userLatLng);

            // Actualizar velocidad
            const speedKmh = speed ? (speed * 3.6).toFixed(0) : 0;
            document.getElementById('speed-display').textContent = `${speedKmh} km/h`;

            // Calcular desvío
            calculateDeviation(position.coords);

            // Detección de parada automática
            if (!document.getElementById('manual-advance-mode').checked) {
                checkAutomaticStopAdvance(position.coords);
            }
        }
        
        function onPositionError(error) {
            alert(`Error de geolocalización: ${error.message}`);
            stopTracking();
        }

        function calculateDeviation(currentCoords) {
            if (trackingState.currentSegmentIndex >= currentRoute.stops.length - 1) {
                // Ruta completada
                return;
            }

            const stopA = currentRoute.stops[trackingState.currentSegmentIndex];
            const stopB = currentRoute.stops[trackingState.currentSegmentIndex + 1];

            const timeA = timeToMillis(stopA.time);
            const timeB = timeToMillis(stopB.time);
            const Tt_tramo = timeB - timeA;

            const D_total = haversineDistance(stopA, stopB);
            const D_recorrida = haversineDistance(stopA, { lat: currentCoords.latitude, lng: currentCoords.longitude });

            if (D_total === 0) return; // Evitar división por cero

            const T_esperado_actual = timeA + (Tt_tramo * (D_recorrida / D_total));

            const ahora_millis = new Date().setHours(0,0,0,0) + (new Date().getTime() - new Date().setHours(0,0,0,0)) % (24 * 60 * 60 * 1000);
            
            const desvioMillis = ahora_millis - T_esperado_actual;

            // El cálculo original es (Hora_Actual - T_esperado_actual).
            // Si el resultado es positivo, significa que la hora actual es MAYOR que la esperada, por lo tanto, está ATRASADO.
            // Si el resultado es negativo, significa que la hora actual es MENOR, por lo tanto, está ADELANTADO.
            // La consigna pide `+` para adelantado y `-` para atrasado, por lo que invertimos el signo.
            const desvioFinalSegundos = -desvioMillis / 1000;
            
            const deviationEl = document.getElementById('deviation-display');
            deviationEl.textContent = formatDeviation(desvioFinalSegundos);
            
            if (desvioFinalSegundos > 5) { // Adelantado (+, verde)
                deviationEl.className = 'value ahead';
            } else if (desvioFinalSegundos < -5) { // Atrasado (-, rojo)
                deviationEl.className = 'value late';
            } else { // A tiempo (blanco)
                deviationEl.className = 'value';
            }
        }

        function checkAutomaticStopAdvance(currentCoords) {
            if (trackingState.currentSegmentIndex >= currentRoute.stops.length - 1) return;

            const nextStop = currentRoute.stops[trackingState.currentSegmentIndex + 1];
            const distanceToNextStop = haversineDistance(nextStop, { lat: currentCoords.latitude, lng: currentCoords.longitude });

            if (distanceToNextStop < PROXIMITY_THRESHOLD) {
                advanceStop(1);
            }
        }

        function advanceStop(direction) {
            const newIndex = trackingState.currentSegmentIndex + direction;

            if (newIndex >= 0 && newIndex < currentRoute.stops.length -1) {
                trackingState.currentSegmentIndex = newIndex;
                updateNextStopHighlight();
                alert(`Avanzando a la siguiente parada: ${currentRoute.stops[trackingState.currentSegmentIndex + 1].name}`);
            } else if (newIndex >= currentRoute.stops.length - 1) {
                // Llegada al final
                trackingState.currentSegmentIndex = currentRoute.stops.length - 1;
                updateNextStopHighlight(); // Marca la última como "llegada"
                alert("¡Ruta completada!");
                stopTracking();
            }
        }

        function updateNextStopHighlight() {
            // Quitar resaltado de todas
            document.querySelectorAll('#stops-list li').forEach(li => li.classList.remove('next-stop-highlight'));

            const nextStopIndex = trackingState.currentSegmentIndex + 1;
            
            if (nextStopIndex < currentRoute.stops.length) {
                const nextStop = currentRoute.stops[nextStopIndex];
                document.getElementById('next-stop-display').textContent = nextStop.name;
                
                // Resaltar en la lista
                const liToHighlight = document.querySelector(`#stops-list li[data-stop-id='${nextStop.id}']`);
                if (liToHighlight) {
                    liToHighlight.classList.add('next-stop-highlight');
                }
            } else {
                 document.getElementById('next-stop-display').textContent = "FIN DE RUTA";
            }
        }

        // --- FUNCIONES UTILITARIAS ---

        // Distancia Haversine en metros
        function haversineDistance(coords1, coords2) {
            function toRad(x) { return x * Math.PI / 180; }
            const R = 6371e3; // metros
            const dLat = toRad(coords2.lat - coords1.lat);
            const dLon = toRad(coords2.lng - coords1.lng);
            const lat1 = toRad(coords1.lat);
            const lat2 = toRad(coords2.lat);

            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Convierte "HH:MM" a milisegundos desde la medianoche
        function timeToMillis(timeStr) {
            if (!timeStr) return 0;
            const [hours, minutes] = timeStr.split(':').map(Number);
            return (hours * 3600 + minutes * 60) * 1000;
        }
        
        // Convierte milisegundos desde la medianoche a "HH:MM"
        function millisToTime(millis) {
            const totalSeconds = Math.round(millis / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }
        
        // Formatea el desvío en segundos a +/-MM:SS
        function formatDeviation(totalSeconds) {
            const sign = totalSeconds >= 0 ? '+' : '-';
            totalSeconds = Math.abs(totalSeconds);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            return `${sign}${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // --- EJECUTAR INICIALIZACIÓN ---
        init();
    });
    </script>

</body>
</html>
