<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --danger-color: #dc3545;
            --success-color: #28a745;
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--light-color);
            color: var(--dark-color);
            overflow-x: hidden; /* Evitar scroll horizontal innecesario */
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100vh; /* Ocupar toda la altura de la ventana gráfica */
        }

        #map {
            height: 55vh; /* Mapa ocupa al menos el 50% de la pantalla */
            width: 100%;
            background-color: #e0e0e0;
        }

        #controlsPanel {
            flex-grow: 1; /* El panel de controles ocupa el espacio restante */
            padding: 10px;
            overflow-y: auto;
            background-color: #ffffff;
            border-top: 2px solid var(--secondary-color);
        }

        .control-section {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .control-section h3 {
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 1px solid var(--primary-color);
            padding-bottom: 5px;
        }

        button, select, input[type="text"], input[type="time"], input[type="checkbox"] {
            padding: 8px 12px;
            margin: 5px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
            box-sizing: border-box;
        }
        input[type="text"], input[type="time"] {
            width: calc(100% - 24px); /* Ajustar por padding y borde */
        }
        select {
             width: 100%;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        button:hover {
            background-color: #0056b3;
        }

        button.danger {
            background-color: var(--danger-color);
        }
        button.danger:hover {
            background-color: #c82333;
        }
        button.success {
            background-color: var(--success-color);
        }
        button.success:hover {
            background-color: #218838;
        }
        button:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
        }


        #stopsList, #trackingQueueDisplay {
            list-style-type: none;
            padding: 0;
        }

        #stopsList li, #trackingQueueDisplay li {
            padding: 8px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #stopsList li:last-child, #trackingQueueDisplay li:last-child {
            border-bottom: none;
        }
        #stopsList button {
            padding: 4px 8px;
            font-size: 0.8em;
        }

        label {
            display: block;
            margin-top: 10px;
            font-weight: bold;
        }

        .inline-label {
            display: inline-block;
            margin-left: 5px;
            font-weight: normal;
        }

        #trackingInfo div {
            margin: 5px 0;
            font-size: 1.1em;
        }
        #timeDifferenceDisplay.adelantado {
            color: var(--success-color);
        }
        #timeDifferenceDisplay.atrasado {
            color: var(--danger-color);
        }

        /* Leaflet Custom Icons CSS */
        .leaflet-custom-icon {
            text-align: center;
            font-weight: bold;
            color: white;
            border-radius: 50%;
            line-height: 20px; /* Ajustar según iconSize */
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
        .icon-start { background-color: green; }
        .icon-end { background-color: red; }
        .icon-intermediate { background-color: blue; }
        .icon-bus {
            background-color: purple;
            font-size: 10px;
            line-height: 24px !important; /* Ajustar según iconSize */
            border: 2px solid white;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            button, select, input {
                font-size: 16px; /* Mejorar legibilidad en móviles */
            }
             input[type="text"], input[type="time"], select {
                width: 100%;
            }
        }

    </style>
</head>
<body>
    <div id="app">
        <div id="map"></div>
        <div id="controlsPanel">
            <!-- Sección de Creación/Edición de Ruta -->
            <div class="control-section">
                <h3>Crear/Editar Ruta</h3>
                <label for="startPointName">Nombre Punto Inicio:</label>
                <input type="text" id="startPointName" placeholder="Ej: Terminal">
                <label for="startPointTime">Hora Salida Inicio (HH:MM):</label>
                <input type="time" id="startPointTime">

                <label for="endPointName">Nombre Punto Fin:</label>
                <input type="text" id="endPointName" placeholder="Ej: Plaza Central">
                <label for="endPointTime">Hora Llegada Fin (HH:MM):</label>
                <input type="time" id="endPointTime">
                
                <button id="defineStartEndButton">Definir Inicio y Fin</button>
                <button id="resetRouteEditorButton" style="background-color: #ffc107; color: black;">Limpiar Editor</button>


                <div id="intermediateStopsSection" style="display:none;">
                    <p><em>Toque el mapa para añadir paradas intermedias.</em></p>
                    <input type="checkbox" id="autoCalcTimesCheckbox" checked>
                    <label for="autoCalcTimesCheckbox" class="inline-label">Calcular horarios intermedios automáticamente</label>
                    
                    <h4>Paradas de la Ruta Actual:</h4>
                    <ul id="stopsList"></ul>
                </div>
                
                <label for="routeName">Nombre de la Ruta (para guardar):</label>
                <input type="text" id="routeName" placeholder="Ej: Linea 101 - Vuelta">
                <button id="saveRouteButton">Guardar Ruta</button>
            </div>

            <!-- Sección de Gestión de Rutas -->
            <div class="control-section">
                <h3>Rutas Guardadas</h3>
                <select id="savedRoutesDropdown"></select>
                <button id="loadRouteButton">Cargar Ruta Seleccionada</button>
                <button id="deleteRouteButton" class="danger">Eliminar Ruta Seleccionada</button>
            </div>

            <!-- Sección de Cola de Seguimiento -->
            <div class="control-section">
                <h3>Cola de Seguimiento</h3>
                <button id="addSelectedToQueueButton">Añadir Ruta Seleccionada a Cola</button>
                <h4>Rutas en Cola:</h4>
                <ul id="trackingQueueDisplay"></ul>
                <button id="clearQueueButton" class="danger">Limpiar Cola</button>
            </div>

            <!-- Sección de Seguimiento en Tiempo Real -->
            <div class="control-section">
                <h3>Seguimiento</h3>
                <button id="startTrackingButton" class="success">Iniciar Seguimiento</button>
                <button id="stopTrackingButton" class="danger" disabled>Detener Seguimiento</button>
                
                <div id="trackingInfo" style="display:none;">
                    <div id="currentRouteDisplay">Ruta Actual: N/A</div>
                    <div id="nextStopDisplay">Próxima Parada: N/A</div>
                    <div id="timeDifferenceDisplay">Diferencia Tiempo: N/A</div>
                </div>

                <input type="checkbox" id="manualControlCheckbox" disabled>
                <label for="manualControlCheckbox" class="inline-label">Control Manual Parada/Ruta</label>
                <div id="manualControls" style="display:none;">
                    <button id="prevStopButton">Parada Anterior</button>
                    <button id="nextStopButton">Siguiente Parada / Próxima Ruta</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Constantes y Variables Globales ---
            const PROXIMITY_THRESHOLD_METERS = 50;
            const GEOFENCE_RADIUS_METERS = 100;
            const LOCALSTORAGE_ROUTES_KEY = 'smartMoveProRoutes';
            const LOCALSTORAGE_TRACKING_STATUS_KEY = 'smartMoveProTrackingStatus';

            let map;
            let currentEditingRoute = { // Para la creación/edición de rutas
                startPoint: null, // { lat, lng, name, departureTime (HH:MM string) }
                endPoint: null,   // { lat, lng, name, arrivalTime (HH:MM string) }
                intermediateStops: [], // [{ lat, lng, name (opcional), arrivalTime, departureTime }]
                name: ""
            };
            let routeMarkers = []; // Markers en el mapa durante la edición
            let routePolyline = null;

            let isEditingMode = false; // True después de definir inicio/fin y antes de guardar
            let nextIntermediateStopNumber = 1;

            let savedRoutes = []; // Array de objetos de ruta completos
            let trackingQueue = []; // Array de nombres de rutas
            let currentTrackingData = {
                isTracking: false,
                route: null, // La ruta activa completa con todas sus paradas
                routeIndexInQueue: -1,
                currentStopIndexFromWhichDeparted: -1, // -1: en inicio; 0: en ruta de S a P1; 1: en ruta de P1 a P2...
                nextStopIndexTowardsWhichHeading: 0,
                busMarker: null,
                busGeofences: [], // [startGeofence, endGeofence]
                watchId: null,
                lastKnownPosition: null,
                currentBusDelayOrAheadMillis: 0,
                manualMode: false,
                error: { hasError: false, reason: "" }
            };
            
            // Elementos del DOM
            const startPointNameInput = document.getElementById('startPointName');
            const startPointTimeInput = document.getElementById('startPointTime');
            const endPointNameInput = document.getElementById('endPointName');
            const endPointTimeInput = document.getElementById('endPointTime');
            const defineStartEndButton = document.getElementById('defineStartEndButton');
            const resetRouteEditorButton = document.getElementById('resetRouteEditorButton');
            const intermediateStopsSection = document.getElementById('intermediateStopsSection');
            const autoCalcTimesCheckbox = document.getElementById('autoCalcTimesCheckbox');
            const stopsListUI = document.getElementById('stopsList');
            const routeNameInput = document.getElementById('routeName');
            const saveRouteButton = document.getElementById('saveRouteButton');
            const savedRoutesDropdown = document.getElementById('savedRoutesDropdown');
            const loadRouteButton = document.getElementById('loadRouteButton');
            const deleteRouteButton = document.getElementById('deleteRouteButton');
            const addSelectedToQueueButton = document.getElementById('addSelectedToQueueButton');
            const trackingQueueDisplay = document.getElementById('trackingQueueDisplay');
            const clearQueueButton = document.getElementById('clearQueueButton');
            const startTrackingButton = document.getElementById('startTrackingButton');
            const stopTrackingButton = document.getElementById('stopTrackingButton');
            const trackingInfoDiv = document.getElementById('trackingInfo');
            const currentRouteDisplay = document.getElementById('currentRouteDisplay');
            const nextStopDisplayUI = document.getElementById('nextStopDisplay');
            const timeDifferenceDisplayUI = document.getElementById('timeDifferenceDisplay');
            const manualControlCheckbox = document.getElementById('manualControlCheckbox');
            const manualControlsDiv = document.getElementById('manualControls');
            const prevStopButton = document.getElementById('prevStopButton');
            const nextStopButton = document.getElementById('nextStopButton');

            // --- Iconos Personalizados Leaflet ---
            const createIcon = (text, className, size = 20) => L.divIcon({
                html: `<div class="leaflet-custom-icon ${className}" style="width:${size}px; height:${size}px; line-height:${size}px;">${text}</div>`,
                className: '', // Evita clase por defecto de Leaflet que puede interferir
                iconSize: [size, size],
                iconAnchor: [size/2, size/2]
            });

            const startIcon = createIcon('I', 'icon-start');
            const endIcon = createIcon('F', 'icon-end');
            const intermediateIcon = (number) => createIcon(number, 'icon-intermediate');
            const busIcon = createIcon('BUS', 'icon-bus', 24);

            // --- Inicialización del Mapa ---
            function initMap() {
                map = L.map('map');
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                map.on('locationfound', (e) => map.setView(e.latlng, 13));
                map.on('locationerror', () => map.setView([ -34.6037, -58.3816 ], 12)); // Buenos Aires fallback
                map.locate({ setView: true, maxZoom: 16, enableHighAccuracy: true });

                map.on('click', handleMapClick);
            }

            // --- Funciones Auxiliares de Tiempo ---
            function timeToMinutes(timeStr) { // HH:MM
                if (!timeStr) return 0;
                const [h, m] = timeStr.split(':').map(Number);
                return h * 60 + m;
            }

            function minutesToTime(totalMinutes) {
                if (isNaN(totalMinutes) || totalMinutes === null) return "00:00";
                const h = Math.floor(totalMinutes / 60) % 24; // Asegurar que las horas no pasen de 23
                const m = Math.round(totalMinutes % 60); // Redondear minutos
                return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
            }
            
            function formatTimeDifference(millis) {
                if (isNaN(millis)) return "N/A";
                const sign = millis >= 0 ? '-' : '+'; // + adelantado, - atrasado
                const absMillis = Math.abs(millis);
                const minutes = Math.floor(absMillis / 60000);
                const seconds = Math.floor((absMillis % 60000) / 1000);
                return `${sign}${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
            
            function getTimestampFromTimeString(timeString) { // HH:MM
                if (!timeString) return null;
                const [hours, minutes] = timeString.split(':').map(Number);
                const date = new Date();
                date.setHours(hours, minutes, 0, 0);
                return date.getTime();
            }


            // --- Lógica de Creación/Edición de Ruta ---
            defineStartEndButton.addEventListener('click', () => {
                const startName = startPointNameInput.value.trim();
                const startTime = startPointTimeInput.value;
                const endName = endPointNameInput.value.trim();
                const endTime = endPointTimeInput.value;

                if (!startName || !startTime || !endName || !endTime) {
                    alert("Por favor, defina Nombre y Hora para Punto de Inicio y Fin.");
                    return;
                }
                 if (timeToMinutes(startTime) >= timeToMinutes(endTime)) {
                    alert("La hora de llegada final debe ser posterior a la hora de salida inicial.");
                    return;
                }

                currentEditingRoute.startPoint = { name: startName, departureTime: startTime, type: 'start' };
                currentEditingRoute.endPoint = { name: endName, arrivalTime: endTime, type: 'end' };
                
                // Permitir al usuario clickear en el mapa para definir coordenadas de inicio/fin
                alert("Toque el mapa para definir la ubicación del PUNTO DE INICIO.");
                isEditingMode = "setting_start_point";
                defineStartEndButton.disabled = true;
                startPointNameInput.disabled = true;
                startPointTimeInput.disabled = true;
                endPointNameInput.disabled = true;
                endPointTimeInput.disabled = true;
                routeNameInput.value = `${startName} - ${endName}`;
            });

            resetRouteEditorButton.addEventListener('click', resetRouteEditor);

            function resetRouteEditor() {
                currentEditingRoute = { startPoint: null, endPoint: null, intermediateStops: [], name: "" };
                clearMapMarkersAndPolyline();
                stopsListUI.innerHTML = "";
                nextIntermediateStopNumber = 1;
                isEditingMode = false;

                startPointNameInput.value = "";
                startPointTimeInput.value = "";
                endPointNameInput.value = "";
                endPointTimeInput.value = "";
                routeNameInput.value = "";

                defineStartEndButton.disabled = false;
                startPointNameInput.disabled = false;
                startPointTimeInput.disabled = false;
                endPointNameInput.disabled = false;
                endPointTimeInput.disabled = false;
                
                intermediateStopsSection.style.display = "none";
            }

            function handleMapClick(e) {
                if (isEditingMode === "setting_start_point") {
                    currentEditingRoute.startPoint.lat = e.latlng.lat;
                    currentEditingRoute.startPoint.lng = e.latlng.lng;
                    addMarkerToMap(e.latlng, startIcon, `Inicio: ${currentEditingRoute.startPoint.name}`);
                    alert("Toque el mapa para definir la ubicación del PUNTO FINAL.");
                    isEditingMode = "setting_end_point";
                } else if (isEditingMode === "setting_end_point") {
                    currentEditingRoute.endPoint.lat = e.latlng.lat;
                    currentEditingRoute.endPoint.lng = e.latlng.lng;
                    addMarkerToMap(e.latlng, endIcon, `Fin: ${currentEditingRoute.endPoint.name}`);
                    isEditingMode = "adding_intermediate_stops";
                    intermediateStopsSection.style.display = "block";
                    renderStopsList();
                    drawRoutePolyline();
                } else if (isEditingMode === "adding_intermediate_stops") {
                    const stopName = prompt(`Nombre para Parada Intermedia ${nextIntermediateStopNumber} (opcional):`, `Parada ${nextIntermediateStopNumber}`);
                    const newStop = {
                        lat: e.latlng.lat,
                        lng: e.latlng.lng,
                        name: stopName || `Parada ${nextIntermediateStopNumber}`,
                        type: 'intermediate',
                        // Horarios se calcularán o pedirán
                    };
                    currentEditingRoute.intermediateStops.push(newStop);
                    nextIntermediateStopNumber++;
                    
                    if (autoCalcTimesCheckbox.checked) {
                        calculateAndAssignIntermediateTimes();
                    } else {
                        const arrivalTime = prompt("Hora de llegada/paso (HH:MM) para esta parada:", "12:00");
                        if (arrivalTime && /^\d{2}:\d{2}$/.test(arrivalTime)) {
                           newStop.arrivalTime = arrivalTime;
                           newStop.departureTime = arrivalTime; // Salida igual a llegada para intermedias
                        } else {
                            alert("Formato de hora inválido. La parada no tendrá horario manual.");
                            newStop.arrivalTime = null;
                            newStop.departureTime = null;
                        }
                    }
                    renderStopsList();
                    drawRoutePolyline(); // Redibuja para incluir la nueva parada
                }
            }
            
            autoCalcTimesCheckbox.addEventListener('change', () => {
                if (currentEditingRoute.startPoint && currentEditingRoute.endPoint && currentEditingRoute.intermediateStops.length > 0) {
                    if (autoCalcTimesCheckbox.checked) {
                        calculateAndAssignIntermediateTimes();
                    } else {
                        alert("Deberá ingresar manualmente los horarios para las paradas intermedias si las modifica o agrega nuevas.");
                        // Opcional: borrar tiempos calculados para forzar entrada manual
                         currentEditingRoute.intermediateStops.forEach(s => { s.arrivalTime = null; s.departureTime = null; });
                    }
                    renderStopsList();
                }
            });


            function calculateAndAssignIntermediateTimes() {
                if (!currentEditingRoute.startPoint || !currentEditingRoute.endPoint || !currentEditingRoute.startPoint.departureTime || !currentEditingRoute.endPoint.arrivalTime) return;

                const routePoints = [
                    currentEditingRoute.startPoint,
                    ...currentEditingRoute.intermediateStops,
                    currentEditingRoute.endPoint
                ];

                if (routePoints.length < 2) return;

                const totalTripMinutes = timeToMinutes(currentEditingRoute.endPoint.arrivalTime) - timeToMinutes(currentEditingRoute.startPoint.departureTime);
                if (totalTripMinutes <= 0) return; // No se puede calcular

                let totalDistance = 0;
                const segmentDistances = [];

                for (let i = 0; i < routePoints.length - 1; i++) {
                    const p1 = L.latLng(routePoints[i].lat, routePoints[i].lng);
                    const p2 = L.latLng(routePoints[i+1].lat, routePoints[i+1].lng);
                    const dist = p1.distanceTo(p2);
                    segmentDistances.push(dist);
                    totalDistance += dist;
                }

                if (totalDistance === 0) { // Si todos los puntos están en el mismo lugar
                     currentEditingRoute.intermediateStops.forEach(stop => {
                        stop.arrivalTime = currentEditingRoute.startPoint.departureTime;
                        stop.departureTime = currentEditingRoute.startPoint.departureTime;
                    });
                    return;
                }

                let accumulatedMinutes = timeToMinutes(currentEditingRoute.startPoint.departureTime);
                let accumulatedDistance = 0;

                for (let i = 0; i < currentEditingRoute.intermediateStops.length; i++) {
                    // La distancia a esta parada intermedia es desde el inicio HASTA esta parada, pasando por las anteriores.
                    // El segmento de interés es el que va DESDE LA PARADA ANTERIOR a la actual.
                    // La primera parada intermedia (i=0) depende de la distancia desde startPoint.
                    
                    // Sumamos la distancia del segmento que LLEGA a esta parada intermedia
                    // Si es la primera parada intermedia, el segmento es startPoint -> intermediateStop[0]
                    // segmentDistances[0] es startPoint -> intermediateStop[0]
                    // segmentDistances[1] es intermediateStop[0] -> intermediateStop[1]
                    // Entonces, para intermediateStop[i], el segmento que llega a ella es segmentDistances[i]
                    accumulatedDistance += segmentDistances[i]; // Distancia del segmento que acaba de terminar en esta parada

                    const proportionOfDistance = accumulatedDistance / totalDistance;
                    const arrivalMinutesAtStop = timeToMinutes(currentEditingRoute.startPoint.departureTime) + (totalTripMinutes * proportionOfDistance);
                    
                    currentEditingRoute.intermediateStops[i].arrivalTime = minutesToTime(arrivalMinutesAtStop);
                    currentEditingRoute.intermediateStops[i].departureTime = minutesToTime(arrivalMinutesAtStop);
                }
            }


            function renderStopsList() {
                stopsListUI.innerHTML = "";
                clearMapMarkersAndPolyline(false); // No borrar marcadores de inicio/fin si ya están

                const addStopToListUI = (stop, type, index = -1) => {
                    const li = document.createElement('li');
                    let timeInfo = '';
                    if (type === 'start') timeInfo = `Sale: ${stop.departureTime || 'N/D'}`;
                    else if (type === 'end') timeInfo = `Llega: ${stop.arrivalTime || 'N/D'}`;
                    else timeInfo = `Llega/Sale: ${stop.arrivalTime || 'N/D'}`;
                    
                    li.textContent = `${stop.name} (${type}) - ${timeInfo}`;
                    
                    if (type === 'intermediate') {
                        const removeBtn = document.createElement('button');
                        removeBtn.textContent = 'X';
                        removeBtn.classList.add('danger');
                        removeBtn.onclick = () => {
                            currentEditingRoute.intermediateStops.splice(index, 1);
                            nextIntermediateStopNumber--; // O recalcular en base a length
                            if (autoCalcTimesCheckbox.checked) calculateAndAssignIntermediateTimes();
                            renderStopsList(); // Re-renderizar todo
                            drawRoutePolyline();
                        };
                        li.appendChild(removeBtn);
                    }
                    stopsListUI.appendChild(li);
                    // Añadir marcador al mapa si tiene lat/lng
                    if (stop.lat && stop.lng) {
                        let icon;
                        if (type === 'start') icon = startIcon;
                        else if (type === 'end') icon = endIcon;
                        else icon = intermediateIcon(index + 1);
                        addMarkerToMap(L.latLng(stop.lat, stop.lng), icon, `${stop.name} (${timeInfo})`);
                    }
                };

                if (currentEditingRoute.startPoint) addStopToListUI(currentEditingRoute.startPoint, 'Inicio');
                currentEditingRoute.intermediateStops.forEach((stop, i) => addStopToListUI(stop, 'Intermedia', i));
                if (currentEditingRoute.endPoint) addStopToListUI(currentEditingRoute.endPoint, 'Fin');
            }

            function addMarkerToMap(latlng, icon, popupText) {
                const marker = L.marker(latlng, { icon: icon }).addTo(map);
                if (popupText) marker.bindPopup(popupText);
                routeMarkers.push(marker);
                return marker;
            }
            
            function clearMapMarkersAndPolyline(fullClear = true) {
                routeMarkers.forEach(marker => map.removeLayer(marker));
                routeMarkers = [];
                if (routePolyline) {
                    map.removeLayer(routePolyline);
                    routePolyline = null;
                }
                 if(fullClear){
                    nextIntermediateStopNumber = 1; // Reset counter if clearing fully
                 }
            }

            function drawRoutePolyline() {
                if (routePolyline) map.removeLayer(routePolyline);
                
                const points = [];
                if (currentEditingRoute.startPoint && currentEditingRoute.startPoint.lat) {
                    points.push([currentEditingRoute.startPoint.lat, currentEditingRoute.startPoint.lng]);
                }
                currentEditingRoute.intermediateStops.forEach(stop => {
                    if (stop.lat) points.push([stop.lat, stop.lng]);
                });
                if (currentEditingRoute.endPoint && currentEditingRoute.endPoint.lat) {
                    points.push([currentEditingRoute.endPoint.lat, currentEditingRoute.endPoint.lng]);
                }

                if (points.length >= 2) {
                    routePolyline = L.polyline(points, { color: 'blue' }).addTo(map);
                     // map.fitBounds(routePolyline.getBounds()); // Opcional: ajustar zoom a la ruta
                }
            }

            // --- Gestión de Rutas (Guardar, Cargar, Eliminar) ---
            saveRouteButton.addEventListener('click', () => {
                const routeNameToSave = routeNameInput.value.trim();
                if (!routeNameToSave) {
                    alert("Por favor, ingrese un nombre para la ruta.");
                    return;
                }
                if (!currentEditingRoute.startPoint || !currentEditingRoute.startPoint.lat ||
                    !currentEditingRoute.endPoint || !currentEditingRoute.endPoint.lat) {
                    alert("La ruta debe tener al menos un punto de inicio y fin definidos en el mapa.");
                    return;
                }
                
                currentEditingRoute.name = routeNameToSave;

                // Construir el objeto de ruta final, asegurándose de que todas las paradas tengan la info necesaria
                const finalRoute = {
                    name: currentEditingRoute.name,
                    startPoint: { ...currentEditingRoute.startPoint },
                    intermediateStops: currentEditingRoute.intermediateStops.map(s => ({ ...s })),
                    endPoint: { ...currentEditingRoute.endPoint }
                };
                
                const existingRouteIndex = savedRoutes.findIndex(r => r.name === routeNameToSave);
                if (existingRouteIndex !== -1) {
                    if (confirm(`Ya existe una ruta con el nombre "${routeNameToSave}". ¿Desea sobrescribirla?`)) {
                        savedRoutes[existingRouteIndex] = finalRoute;
                    } else {
                        return;
                    }
                } else {
                    savedRoutes.push(finalRoute);
                }
                
                localStorage.setItem(LOCALSTORAGE_ROUTES_KEY, JSON.stringify(savedRoutes));
                alert(`Ruta "${routeNameToSave}" guardada.`);
                populateSavedRoutesDropdown();
                resetRouteEditor(); // Limpiar el editor después de guardar
            });

            loadRouteButton.addEventListener('click', () => {
                const routeNameToLoad = savedRoutesDropdown.value;
                if (!routeNameToLoad) {
                    alert("Seleccione una ruta para cargar.");
                    return;
                }
                const routeToLoad = savedRoutes.find(r => r.name === routeNameToLoad);
                if (routeToLoad) {
                    resetRouteEditor(); // Limpia el estado de edición actual
                    
                    // Copia profunda para no modificar la ruta guardada directamente
                    currentEditingRoute = JSON.parse(JSON.stringify(routeToLoad)); 

                    startPointNameInput.value = currentEditingRoute.startPoint.name;
                    startPointTimeInput.value = currentEditingRoute.startPoint.departureTime;
                    endPointNameInput.value = currentEditingRoute.endPoint.name;
                    endPointTimeInput.value = currentEditingRoute.endPoint.arrivalTime;
                    routeNameInput.value = currentEditingRoute.name;
                    
                    // Activar modo edición como si se hubieran definido S/E
                    defineStartEndButton.disabled = true;
                    startPointNameInput.disabled = true;
                    startPointTimeInput.disabled = true;
                    endPointNameInput.disabled = true;
                    endPointTimeInput.disabled = true;
                    intermediateStopsSection.style.display = "block";
                    isEditingMode = "adding_intermediate_stops"; // Permite añadir más o editar existentes implicitamente
                    nextIntermediateStopNumber = currentEditingRoute.intermediateStops.length + 1;

                    renderStopsList(); // Dibuja marcadores y lista
                    drawRoutePolyline(); // Dibuja polilínea
                     if (routePolyline) map.fitBounds(routePolyline.getBounds());


                    alert(`Ruta "${routeNameToLoad}" cargada en el editor.`);
                }
            });

            deleteRouteButton.addEventListener('click', () => {
                const routeNameToDelete = savedRoutesDropdown.value;
                if (!routeNameToDelete) {
                    alert("Seleccione una ruta para eliminar.");
                    return;
                }
                if (confirm(`¿Está seguro que desea eliminar la ruta "${routeNameToDelete}"? Esta acción no se puede deshacer.`)) {
                    savedRoutes = savedRoutes.filter(r => r.name !== routeNameToDelete);
                    localStorage.setItem(LOCALSTORAGE_ROUTES_KEY, JSON.stringify(savedRoutes));
                    alert(`Ruta "${routeNameToDelete}" eliminada.`);
                    populateSavedRoutesDropdown();
                    // Si la ruta eliminada estaba en el editor, limpiar editor
                    if (routeNameInput.value === routeNameToDelete) {
                        resetRouteEditor();
                    }
                }
            });
            
            function loadRoutesFromStorage() {
                const storedRoutes = localStorage.getItem(LOCALSTORAGE_ROUTES_KEY);
                if (storedRoutes) {
                    savedRoutes = JSON.parse(storedRoutes);
                }
                populateSavedRoutesDropdown();
            }

            function populateSavedRoutesDropdown() {
                savedRoutesDropdown.innerHTML = ""; // Limpiar opciones previas
                if (savedRoutes.length === 0) {
                    const option = document.createElement('option');
                    option.value = "";
                    option.textContent = "No hay rutas guardadas";
                    savedRoutesDropdown.appendChild(option);
                    return;
                }
                savedRoutes.forEach(route => {
                    const option = document.createElement('option');
                    option.value = route.name;
                    option.textContent = route.name;
                    savedRoutesDropdown.appendChild(option);
                });
            }

            // --- Lógica de Cola de Seguimiento ---
            addSelectedToQueueButton.addEventListener('click', () => {
                const routeName = savedRoutesDropdown.value;
                if (!routeName) {
                    alert("Seleccione una ruta de la lista de rutas guardadas.");
                    return;
                }
                if (trackingQueue.includes(routeName)) {
                    alert("Esa ruta ya está en la cola.");
                    return;
                }
                trackingQueue.push(routeName);
                renderTrackingQueue();
            });

            clearQueueButton.addEventListener('click', () => {
                trackingQueue = [];
                renderTrackingQueue();
            });

            function renderTrackingQueue() {
                trackingQueueDisplay.innerHTML = "";
                trackingQueue.forEach((routeName, index) => {
                    const li = document.createElement('li');
                    li.textContent = `${index + 1}. ${routeName}`;
                    trackingQueueDisplay.appendChild(li);
                });
                startTrackingButton.disabled = trackingQueue.length === 0 || currentTrackingData.isTracking;
            }

            // --- Lógica de Seguimiento en Tiempo Real ---
            startTrackingButton.addEventListener('click', async () => {
                if (trackingQueue.length === 0) {
                    alert("Añada rutas a la cola de seguimiento primero.");
                    return;
                }
                if (!navigator.geolocation) {
                    alert("Geolocalización no es soportada por este navegador.");
                    updateTrackingStatusInLocalStorage(true, "Geolocalización no soportada");
                    return;
                }
                
                try {
                    // Pedir permiso explícitamente si aún no se ha concedido
                    // Esto también sirve para "despertar" el GPS
                    await new Promise((resolve, reject) => {
                         navigator.geolocation.getCurrentPosition(resolve, reject, {enableHighAccuracy: true, timeout:10000, maximumAge:0});
                    });
                } catch (error) {
                    console.error("Error obteniendo posición inicial:", error);
                    alert(`Error al iniciar GPS: ${error.message}. Asegúrese que los permisos de ubicación están concedidos y el GPS activo.`);
                    updateTrackingStatusInLocalStorage(true, `Error GPS: ${error.message}`);
                    return;
                }


                currentTrackingData.isTracking = true;
                currentTrackingData.routeIndexInQueue = 0;
                loadNextRouteForTracking(); // Carga la primera ruta y configura el estado
                
                currentTrackingData.watchId = navigator.geolocation.watchPosition(
                    onPositionUpdate,
                    onPositionError,
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 } // Opciones de alta precisión
                );

                startTrackingButton.disabled = true;
                stopTrackingButton.disabled = false;
                manualControlCheckbox.disabled = false;
                trackingInfoDiv.style.display = "block";
                updateTrackingStatusInLocalStorage();
            });
            
            stopTrackingButton.addEventListener('click', () => {
                if (currentTrackingData.watchId) {
                    navigator.geolocation.clearWatch(currentTrackingData.watchId);
                }
                currentTrackingData.isTracking = false;
                currentTrackingData.watchId = null;
                // Limpiar elementos del mapa relacionados al tracking
                if (currentTrackingData.busMarker) map.removeLayer(currentTrackingData.busMarker);
                currentTrackingData.busMarker = null;
                currentTrackingData.busGeofences.forEach(g => map.removeLayer(g));
                currentTrackingData.busGeofences = [];
                if (currentTrackingData.activeRoutePolyline) map.removeLayer(currentTrackingData.activeRoutePolyline);
                currentTrackingData.activeRoutePolyline = null;


                startTrackingButton.disabled = trackingQueue.length === 0;
                stopTrackingButton.disabled = true;
                manualControlCheckbox.disabled = true;
                manualControlCheckbox.checked = false; // Reset manual mode
                manualControlsDiv.style.display = "none";
                trackingInfoDiv.style.display = "none";

                // reset tracking data sub-fields, but keep queue
                currentTrackingData.route = null;
                currentTrackingData.routeIndexInQueue = -1;
                currentTrackingData.currentStopIndexFromWhichDeparted = -1;
                currentTrackingData.nextStopIndexTowardsWhichHeading = 0;
                currentTrackingData.error.hasError = false;
                currentTrackingData.error.reason = "";

                updateTrackingStatusInLocalStorage(); // Indica que ya no se está trackeando
                alert("Seguimiento detenido.");
            });

            function loadNextRouteForTracking() {
                clearMapMarkersAndPolyline(); // Limpia marcadores de edición, no los de tracking que se limpian aparte
                
                const routeName = trackingQueue[currentTrackingData.routeIndexInQueue];
                const routeDefinition = savedRoutes.find(r => r.name === routeName);
                
                if (!routeDefinition) {
                    console.error(`Ruta ${routeName} no encontrada para seguimiento.`);
                    updateTrackingStatusInLocalStorage(true, `Ruta ${routeName} no encontrada`);
                    stopTrackingButton.click(); // Detener si la ruta no se puede cargar
                    return;
                }
                
                // Crear una copia "plana" de la ruta para el seguimiento
                currentTrackingData.route = {
                    name: routeDefinition.name,
                    stops: [
                        { ...routeDefinition.startPoint, type: 'start' },
                        ...routeDefinition.intermediateStops.map(s => ({ ...s, type: 'intermediate' })),
                        { ...routeDefinition.endPoint, type: 'end' }
                    ]
                };
                currentTrackingData.currentStopIndexFromWhichDeparted = -1; // En punto de inicio
                currentTrackingData.nextStopIndexTowardsWhichHeading = 0; // Objetivo: primer punto (startPoint)

                drawActiveRouteOnMap();
                updateTrackingDisplays();
                updateTrackingStatusInLocalStorage();
            }
            
            function drawActiveRouteOnMap() {
                if (!currentTrackingData.route) return;

                // Limpiar antiguos geofences y polilínea de ruta activa si existen
                if (currentTrackingData.activeRoutePolyline) map.removeLayer(currentTrackingData.activeRoutePolyline);
                currentTrackingData.busGeofences.forEach(g => map.removeLayer(g));
                currentTrackingData.busGeofences = [];
                 // Limpiar marcadores de ruta previos (de edición o de ruta activa anterior)
                routeMarkers.forEach(m => map.removeLayer(m));
                routeMarkers = [];

                const routePointsLatLng = [];
                currentTrackingData.route.stops.forEach((stop, index) => {
                    const latlng = L.latLng(stop.lat, stop.lng);
                    routePointsLatLng.push(latlng);
                    let icon;
                    if (stop.type === 'start') icon = startIcon;
                    else if (stop.type === 'end') icon = endIcon;
                    else icon = intermediateIcon(index); // Usar índice global en ruta aplanada (Inicio=0, P1=1...)
                    
                    const marker = L.marker(latlng, { icon }).addTo(map);
                    marker.bindPopup(`${stop.name} (${stop.type === 'start' ? stop.departureTime : stop.arrivalTime})`);
                    routeMarkers.push(marker); // Guardar para poder borrarlos luego
                });

                if (routePointsLatLng.length > 0) {
                   currentTrackingData.activeRoutePolyline = L.polyline(routePointsLatLng, { color: 'green', weight: 5 }).addTo(map);
                   map.fitBounds(currentTrackingData.activeRoutePolyline.getBounds());
                }
                
                // Geofences para punto de inicio y fin de la ruta activa
                const startLatLng = L.latLng(currentTrackingData.route.stops[0].lat, currentTrackingData.route.stops[0].lng);
                const endLatLng = L.latLng(currentTrackingData.route.stops[currentTrackingData.route.stops.length - 1].lat, currentTrackingData.route.stops[currentTrackingData.route.stops.length - 1].lng);

                const startGeofence = L.circle(startLatLng, { radius: GEOFENCE_RADIUS_METERS, color: 'green', fillOpacity: 0.1 }).addTo(map);
                const endGeofence = L.circle(endLatLng, { radius: GEOFENCE_RADIUS_METERS, color: 'red', fillOpacity: 0.1 }).addTo(map);
                currentTrackingData.busGeofences.push(startGeofence, endGeofence);
            }

            function onPositionUpdate(position) {
                const { latitude, longitude } = position.coords;
                currentTrackingData.lastKnownPosition = { lat: latitude, lng: longitude };

                if (!currentTrackingData.busMarker) {
                    currentTrackingData.busMarker = L.marker([latitude, longitude], { icon: busIcon, zIndexOffset: 1000 }).addTo(map);
                } else {
                    currentTrackingData.busMarker.setLatLng([latitude, longitude]);
                }
                map.panTo([latitude, longitude], { animate: true }); // Opcional: centrar suavemente

                calculateTimeDifference(); // Esto actualiza currentTrackingData.currentBusDelayOrAheadMillis
                
                if (!currentTrackingData.manualMode) {
                    checkProximityAndAdvance();
                }
                updateTrackingDisplays();
                updateTrackingStatusInLocalStorage();
            }

            function onPositionError(error) {
                console.error("Error de geolocalización:", error);
                let reason = `Error GPS: ${error.message} (code: ${error.code})`;
                currentTrackingData.error = { hasError: true, reason: reason };
                if (error.code === error.PERMISSION_DENIED) {
                    alert("Permiso de ubicación denegado. El seguimiento no puede continuar.");
                    stopTrackingButton.click();
                } else if (error.code === error.POSITION_UNAVAILABLE) {
                     alert("Información de ubicación no disponible temporalmente.");
                } else if (error.code === error.TIMEOUT) {
                    // No alertar por cada timeout, podría ser molesto
                    console.warn("Timeout obteniendo ubicación.");
                }
                updateTrackingDisplays(); // Para mostrar el error si lo hay
                updateTrackingStatusInLocalStorage(true, reason);
            }

            function calculateTimeDifference() {
                if (!currentTrackingData.route || currentTrackingData.route.stops.length === 0) {
                    currentTrackingData.currentBusDelayOrAheadMillis = 0;
                    return;
                }

                const now = Date.now();
                const currentRouteStops = currentTrackingData.route.stops;
                
                if (currentTrackingData.currentStopIndexFromWhichDeparted === -1) { // En punto de inicio
                    const scheduledDepartureTime = getTimestampFromTimeString(currentRouteStops[0].departureTime);
                    if (!scheduledDepartureTime) {
                         currentTrackingData.currentBusDelayOrAheadMillis = 0; return;
                    }
                    // Diferencia = Hora programada de salida - Hora actual
                    // Positivo: Falta para salir (adelantado respecto a la tarea de salir, se considera que espera)
                    // Negativo: Ya debería haber salido (atrasado)
                    currentTrackingData.currentBusDelayOrAheadMillis = scheduledDepartureTime - now; 
                } else { // En ruta
                    const fromStop = currentRouteStops[currentTrackingData.currentStopIndexFromWhichDeparted];
                    const toStop = currentRouteStops[currentTrackingData.nextStopIndexTowardsWhichHeading];

                    if (!fromStop || !toStop || !currentTrackingData.lastKnownPosition) {
                        currentTrackingData.currentBusDelayOrAheadMillis = 0; return;
                    }

                    const scheduledDepartureFrom = getTimestampFromTimeString(fromStop.departureTime);
                    const scheduledArrivalAtTo = getTimestampFromTimeString(toStop.arrivalTime);
                    
                    if (!scheduledDepartureFrom || !scheduledArrivalAtTo) {
                         currentTrackingData.currentBusDelayOrAheadMillis = 0; return;
                    }
                    
                    const segmentScheduledDurationMillis = scheduledArrivalAtTo - scheduledDepartureFrom;
                    if (segmentScheduledDurationMillis <= 0) { // Puede pasar si departure de from es igual a arrival en to
                        // O si los tiempos son inconsistentes. Tratar como puntual.
                         currentTrackingData.currentBusDelayOrAheadMillis = 0; return;
                    }

                    const fromLatLng = L.latLng(fromStop.lat, fromStop.lng);
                    const toLatLng = L.latLng(toStop.lat, toStop.lng);
                    const currentLatLng = L.latLng(currentTrackingData.lastKnownPosition.lat, currentTrackingData.lastKnownPosition.lng);

                    const totalSegmentDistance = fromLatLng.distanceTo(toLatLng);
                    if (totalSegmentDistance === 0) { // Paradas en el mismo lugar
                         // Comparar hora actual con la de llegada programada a toStop
                         currentTrackingData.currentBusDelayOrAheadMillis = scheduledArrivalAtTo - now;
                         return;
                    }
                    
                    // Proyección del punto actual en el segmento de ruta. Es complejo.
                    // Simplificación: usar progreso lineal por distancia.
                    const distanceFromStartOfSegment = fromLatLng.distanceTo(currentLatLng);
                    //const distanceToEndOfSegment = currentLatLng.distanceTo(toLatLng);
                    
                    // Estimamos el progreso como la proporción de la distancia total del segmento que "debería" estar más cerca del inicio
                    // Esto no es perfecto si el bus se desvía, pero es una aproximación.
                    // Una forma es (distancia_total - distancia_restante) / distancia_total
                    // O, si el bus está más allá del punto "to", el progreso es > 1. Si está antes de "from", < 0.
                    // Forzamos progreso entre 0 y 1 para cálculo simple de tiempo esperado.
                    let progress = Math.max(0, Math.min(1, distanceFromStartOfSegment / totalSegmentDistance));


                    // Esta lógica necesita revisión para precisión
                    // Tiempo que debería haber transcurrido en el segmento actual = progreso * duración_programada_segmento
                    const expectedTimeElapsedInSegment = progress * segmentScheduledDurationMillis;
                    
                    // Hora a la que se debería estar en el punto actual si se partió a tiempo de "fromStop"
                    const expectedTimeAtCurrentPosition = scheduledDepartureFrom + expectedTimeElapsedInSegment;
                    
                    // Diferencia = Hora esperada en esta posición - Hora actual
                    // Positivo: Se llegó antes de lo esperado (adelantado)
                    // Negativo: Se llegó después de lo esperado (atrasado)
                    currentTrackingData.currentBusDelayOrAheadMillis = expectedTimeAtCurrentPosition - now;
                }
            }
            
            function updateTrackingDisplays() {
                if (!currentTrackingData.isTracking || !currentTrackingData.route) {
                    currentRouteDisplay.textContent = "Ruta Actual: N/A";
                    nextStopDisplayUI.textContent = "Próxima Parada: N/A";
                    timeDifferenceDisplayUI.textContent = "Diferencia Tiempo: N/A";
                    timeDifferenceDisplayUI.className = '';
                    return;
                }
                
                currentRouteDisplay.textContent = `Ruta Actual: ${currentTrackingData.route.name}`;
                
                const stops = currentTrackingData.route.stops;
                let nextStopInfo = "N/A";
                if (currentTrackingData.currentStopIndexFromWhichDeparted === -1) { // En inicio
                    nextStopInfo = `Salida de ${stops[0].name} a las ${stops[0].departureTime}`;
                } else if (currentTrackingData.nextStopIndexTowardsWhichHeading < stops.length) {
                    const nextSt = stops[currentTrackingData.nextStopIndexTowardsWhichHeading];
                    nextStopInfo = `${nextSt.name} (prog. ${nextSt.arrivalTime || 'N/D'})`;
                } else {
                    nextStopInfo = "Fin de ruta alcanzado";
                }
                nextStopDisplayUI.textContent = `Próxima Parada: ${nextStopInfo}`;

                timeDifferenceDisplayUI.textContent = `Diferencia: ${formatTimeDifference(currentTrackingData.currentBusDelayOrAheadMillis)}`;
                if (currentTrackingData.currentBusDelayOrAheadMillis > 0) { // Positivo: Favorable (adelantado o tiempo restante para salir)
                     timeDifferenceDisplayUI.className = 'adelantado'; // En UI esto sería verde (más tiempo del esperado / adelantado)
                } else if (currentTrackingData.currentBusDelayOrAheadMillis < 0) { // Negativo: Desfavorable (atrasado)
                     timeDifferenceDisplayUI.className = 'atrasado'; // En UI esto sería rojo (menos tiempo / atrasado)
                } else {
                     timeDifferenceDisplayUI.className = '';
                }

                if (currentTrackingData.error.hasError) {
                    timeDifferenceDisplayUI.textContent += ` - ERROR: ${currentTrackingData.error.reason}`;
                    timeDifferenceDisplayUI.className = 'atrasado';
                }
            }

            manualControlCheckbox.addEventListener('change', (e) => {
                currentTrackingData.manualMode = e.target.checked;
                manualControlsDiv.style.display = currentTrackingData.manualMode ? 'block' : 'none';
                if (!currentTrackingData.manualMode && currentTrackingData.isTracking) {
                    findAndSetCurrentLeg(); // Re-sincronizar al volver a automático
                }
                 updateTrackingStatusInLocalStorage();
            });

            prevStopButton.addEventListener('click', () => {
                if (!currentTrackingData.isTracking || !currentTrackingData.manualMode) return;
                
                // Lógica para ir a parada anterior. Cuidado con los límites.
                if (currentTrackingData.nextStopIndexTowardsWhichHeading > 0) {
                    currentTrackingData.nextStopIndexTowardsWhichHeading--;
                    currentTrackingData.currentStopIndexFromWhichDeparted = currentTrackingData.nextStopIndexTowardsWhichHeading -1;
                    if (currentTrackingData.currentStopIndexFromWhichDeparted < -1) currentTrackingData.currentStopIndexFromWhichDeparted = -1; // Límite
                }
                updateTrackingDisplays();
                updateTrackingStatusInLocalStorage();
            });
            
            nextStopButton.addEventListener('click', () => {
                if (!currentTrackingData.isTracking || !currentTrackingData.manualMode) return;

                const totalStops = currentTrackingData.route.stops.length;
                // Si estamos en la última parada (endPoint), avanzar a la siguiente ruta.
                if (currentTrackingData.nextStopIndexTowardsWhichHeading >= totalStops -1) {
                     currentTrackingData.routeIndexInQueue++;
                     if (currentTrackingData.routeIndexInQueue < trackingQueue.length) {
                         alert("Pasando manualmente a la siguiente ruta de la cola.");
                         loadNextRouteForTracking();
                     } else {
                         alert("Fin de todas las rutas en la cola. Deteniendo seguimiento.");
                         stopTrackingButton.click();
                     }
                } else { // Avanzar a la siguiente parada en la ruta actual
                    currentTrackingData.currentStopIndexFromWhichDeparted = currentTrackingData.nextStopIndexTowardsWhichHeading;
                    currentTrackingData.nextStopIndexTowardsWhichHeading++;
                }
                updateTrackingDisplays();
                updateTrackingStatusInLocalStorage();
            });


            function checkProximityAndAdvance() {
                if (!currentTrackingData.isTracking || currentTrackingData.manualMode || !currentTrackingData.route || !currentTrackingData.lastKnownPosition) return;

                const busLatLng = L.latLng(currentTrackingData.lastKnownPosition.lat, currentTrackingData.lastKnownPosition.lng);
                const currentRouteStops = currentTrackingData.route.stops;

                // 1. Manejo de salida del punto de inicio
                if (currentTrackingData.currentStopIndexFromWhichDeparted === -1) {
                    const startPoint = currentRouteStops[0];
                    const startLatLng = L.latLng(startPoint.lat, startPoint.lng);
                    if (busLatLng.distanceTo(startLatLng) > GEOFENCE_RADIUS_METERS) {
                        console.log("Salió del geofence de inicio. En ruta hacia parada 1.");
                        currentTrackingData.currentStopIndexFromWhichDeparted = 0; // Salió del inicio (índice 0)
                        currentTrackingData.nextStopIndexTowardsWhichHeading = 1;  // Se dirige a la parada 1 (índice 1)
                        // Registrar la hora real de salida, puede ser útil.
                        updateTrackingDisplays();
                        updateTrackingStatusInLocalStorage();
                        return; // Evitar más comprobaciones en este ciclo
                    }
                } else {
                    // 2. Manejo de llegada a paradas intermedias o fin
                    const nextStopTarget = currentRouteStops[currentTrackingData.nextStopIndexTowardsWhichHeading];
                    if (!nextStopTarget) return; // No hay más paradas (debería ser manejado por el if anterior)

                    const nextStopLatLng = L.latLng(nextStopTarget.lat, nextStopTarget.lng);
                    const distanceToNextStop = busLatLng.distanceTo(nextStopLatLng);

                    let threshold = PROXIMITY_THRESHOLD_METERS;
                    if (nextStopTarget.type === 'end') {
                        threshold = GEOFENCE_RADIUS_METERS; // Usar geofence para el punto final
                    }

                    if (distanceToNextStop <= threshold) {
                        console.log(`Llegó a/cerca de ${nextStopTarget.name}`);
                        // ¿Es el punto final de la ruta actual?
                        if (nextStopTarget.type === 'end') {
                            console.log("Llegó al geofence del punto final de la ruta.");
                            currentTrackingData.routeIndexInQueue++;
                            if (currentTrackingData.routeIndexInQueue < trackingQueue.length) {
                                alert(`Completada ruta: ${currentTrackingData.route.name}. Cargando siguiente ruta: ${trackingQueue[currentTrackingData.routeIndexInQueue]}`);
                                loadNextRouteForTracking(); // Carga y configura la nueva ruta, reinicia índices de parada.
                            } else {
                                alert("Fin de todas las rutas en la cola. Deteniendo seguimiento.");
                                stopTrackingButton.click();
                            }
                        } else { // Es una parada intermedia
                            currentTrackingData.currentStopIndexFromWhichDeparted = currentTrackingData.nextStopIndexTowardsWhichHeading;
                            currentTrackingData.nextStopIndexTowardsWhichHeading++;
                        }
                        updateTrackingDisplays();
                        updateTrackingStatusInLocalStorage();
                    }
                }
            }

            function findAndSetCurrentLeg() {
                if (!currentTrackingData.isTracking || !currentTrackingData.route || !currentTrackingData.lastKnownPosition) return;
                
                console.log("Intentando re-sincronizar posición con la ruta...");
                const busLatLng = L.latLng(currentTrackingData.lastKnownPosition.lat, currentTrackingData.lastKnownPosition.lng);
                const stops = currentTrackingData.route.stops;
                let bestMatch = { legIndex: -1, distance: Infinity };

                // Priorizar encontrar la parada más cercana ADELANTE en el orden de la ruta
                // Un enfoque simple: encontrar la parada más cercana a la que aún no se ha llegado
                // (o la última de la que se partió, si estamos muy cerca de ella).
                for (let i = 0; i < stops.length; i++) {
                    const stopLatLng = L.latLng(stops[i].lat, stops[i].lng);
                    const dist = busLatLng.distanceTo(stopLatLng);
                    
                    // Si esta parada está más adelante o es la actual, y es la más cercana hasta ahora
                    if (i >= currentTrackingData.currentStopIndexFromWhichDeparted && dist < bestMatch.distance) {
                        bestMatch.distance = dist;
                        bestMatch.legIndex = i; // Este sería el índice de la parada objetivo
                    }
                }
                
                if (bestMatch.legIndex !== -1) {
                     // Si la parada más cercana adelante es la misma a la que ya nos dirigíamos, no hacer nada.
                    // O, si estamos muy cerca de una parada, asumimos que esa es nuestra próxima meta o de la que partimos.
                    
                    // Este es un algoritmo simplificado:
                    // Se asume que si la parada "bestMatch.legIndex" es el punto de destino más probable.
                    // Entonces, partimos de "bestMatch.legIndex - 1".
                    if (bestMatch.legIndex === 0) { // Si la más cercana es el punto de inicio
                         currentTrackingData.currentStopIndexFromWhichDeparted = -1;
                         currentTrackingData.nextStopIndexTowardsWhichHeading = 0;
                    } else {
                         currentTrackingData.currentStopIndexFromWhichDeparted = bestMatch.legIndex - 1;
                         currentTrackingData.nextStopIndexTowardsWhichHeading = bestMatch.legIndex;
                    }
                    console.log(`Re-sincronizado: Salió de índice ${currentTrackingData.currentStopIndexFromWhichDeparted}, va hacia índice ${currentTrackingData.nextStopIndexTowardsWhichHeading}`);
                } else {
                     console.log("No se pudo re-sincronizar claramente.");
                     // Podría quedarse con los índices actuales.
                }
                updateTrackingDisplays();
                updateTrackingStatusInLocalStorage();
            }

            // --- Comunicación con localStorage ---
            function updateTrackingStatusInLocalStorage(isError = false, errorReason = "") {
                const status = {
                    isTracking: currentTrackingData.isTracking,
                    hasError: isError || currentTrackingData.error.hasError,
                    errorReason: errorReason || currentTrackingData.error.reason,
                    routeName: currentTrackingData.route ? currentTrackingData.route.name : null,
                    currentRouteIndexInQueue: currentTrackingData.routeIndexInQueue,
                    trackingQueueNames: [...trackingQueue], // Copia
                    // Asegúrate que estos índices son consistentes con la UI y lógica.
                    currentStopIndexFromWhichDeparted: currentTrackingData.isTracking ? currentTrackingData.currentStopIndexFromWhichDeparted : -1,
                    nextStopIndexTowardsWhichHeading: currentTrackingData.isTracking ? currentTrackingData.nextStopIndexTowardsWhichHeading : 0,
                    currentBusDelayOrAheadMillis: currentTrackingData.isTracking ? currentTrackingData.currentBusDelayOrAheadMillis : 0,
                    lastKnownPosition: currentTrackingData.lastKnownPosition,
                    lastUpdateTime: Date.now(),
                    // Incluye una representación plana de la ruta activa
                    routeStops: currentTrackingData.route ? currentTrackingData.route.stops.map(s => ({
                        name: s.name,
                        type: s.type,
                        // Guardar horas relevantes: si es 'start', su 'departureTime'. Sino, 'arrivalTime' (y 'departureTime' si existe).
                        arrivalTime: s.arrivalTime || null, 
                        departureTime: s.departureTime || null,
                        lat: s.lat, // Coordenadas para CuandoLlega (opcional si solo usa horarios)
                        lng: s.lng  // Idem
                    })) : []
                };
                localStorage.setItem(LOCALSTORAGE_TRACKING_STATUS_KEY, JSON.stringify(status));
            }
            
            // Intervalo para actualizar localStorage si no hay otro trigger
            // Se actualiza también en onPositionUpdate, cambios de estado, etc.
            // Podría no ser necesario si las otras actualizaciones son suficientes.
            // setInterval(() => {
            //     if (currentTrackingData.isTracking) {
            //         updateTrackingStatusInLocalStorage();
            //     }
            // }, 5000);


            // --- Service Worker ---
            const swCode = `
                const CACHE_NAME = 'smart-move-pro-cache-v1';
                // Cachear el propio HTML y los assets de Leaflet.
                // El path '/' asume que este HTML es el root de la app.
                // Ajustar si se sirve desde una subcarpeta.
                const urlsToCache = [
                    '/', // Cachear la página principal
                    'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
                    'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js',
                    'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
                    'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',
                    'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png'
                    // Si tuvieras iconos en /icons/ (para manifest), agrégalos aquí.
                ];

                self.addEventListener('install', event => {
                    event.waitUntil(
                        caches.open(CACHE_NAME)
                            .then(cache => {
                                console.log('SmartMovePro SW: Cache opened');
                                // Para assets de CDN, las requests podrían necesitar ser 'no-cors'
                                // pero esto devuelve respuestas opacas.
                                // Alternativamente, confiar en que el CDN tiene CORS configurado.
                                // Si no, cache.addAll podría fallar para algunos de estos.
                                // Es mejor si los assets clave de la app están en el mismo origen.
                                const requests = urlsToCache.map(url => {
                                   if (url.startsWith('http')) { // URL externa (CDN)
                                     return new Request(url, { mode: 'cors' }); // o 'no-cors' si es necesario y se acepta respuesta opaca
                                   }
                                   return url; // URL local
                                });
                                return cache.addAll(requests).catch(err => {
                                    console.error('SmartMovePro SW: Failed to cache some URLs during install:', err, requests);
                                    // Intentar cachear individualmente para depurar cuál falla
                                    requests.forEach(req => {
                                        cache.add(req).catch(e => console.warn('Failed to cache:', req, e));
                                    });
                                });
                            })
                    );
                });

                self.addEventListener('fetch', event => {
                    event.respondWith(
                        caches.match(event.request)
                            .then(response => {
                                if (response) {
                                    return response; // Servir desde el caché
                                }
                                // Si no está en caché, intentar obtener de la red
                                return fetch(event.request).then(
                                    networkResponse => {
                                        // Opcional: Cachear dinámicamente nuevas requests GET exitosas
                                        if (networkResponse && networkResponse.status === 200 && event.request.method === 'GET') {
                                           if (urlsToCache.includes(event.request.url) || event.request.url.includes('openstreetmap.org')) { // Solo cachear lo conocido o tiles
                                                const responseToCache = networkResponse.clone();
                                                caches.open(CACHE_NAME)
                                                    .then(cache => {
                                                        cache.put(event.request, responseToCache);
                                                    });
                                           }
                                        }
                                        return networkResponse;
                                    }
                                ).catch(() => {
                                    // Fallback muy básico si está offline y no está en caché.
                                    // Podrías devolver una página offline HTML aquí.
                                    console.warn('SmartMovePro SW: Fetch failed, resource not in cache and network unavailable for:', event.request.url);
                                });
                            })
                    );
                });

                self.addEventListener('activate', event => {
                    const cacheWhitelist = [CACHE_NAME];
                    event.waitUntil(
                        caches.keys().then(cacheNames => {
                            return Promise.all(
                                cacheNames.map(cacheName => {
                                    if (cacheWhitelist.indexOf(cacheName) === -1) {
                                        console.log('SmartMovePro SW: Deleting old cache', cacheName);
                                        return caches.delete(cacheName);
                                    }
                                })
                            );
                        })
                    );
                    return self.clients.claim(); // Asegurar que el SW se active para clientes abiertos inmediatamente
                });
            `;

            if ('serviceWorker' in navigator) {
                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swURL = URL.createObjectURL(blob);
                navigator.serviceWorker.register(swURL) // Registrar desde el blob URL
                    .then(registration => {
                        console.log('Smart Move Pro Service Worker registered with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Smart Move Pro Service Worker registration failed:', error);
                    });
            }


            // --- Inicialización General de la App ---
            initMap();
            loadRoutesFromStorage();
            renderTrackingQueue(); // asegurar que los botones de tracking estén bien inicialmente
            
            // Establecer un estado inicial para Cuando Llega
            if (!localStorage.getItem(LOCALSTORAGE_TRACKING_STATUS_KEY)) {
                 updateTrackingStatusInLocalStorage(); // Guarda un estado "not tracking" inicial.
            }

        }); // Fin DOMContentLoaded
    </script>
</body>
</html>
