<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* Evita el scroll general de la página */
        }

        #map {
            height: 55vh; /* Aproximadamente 50-60% */
            width: 100%;
            background-color: #333; /* Color de fondo mientras carga el mapa */
        }

        #controlsArea {
            flex-grow: 1;
            padding: 10px;
            overflow-y: auto; /* Scroll solo para el área de controles si es necesario */
            display: flex;
            flex-direction: column;
        }

        .control-section {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
        }

        .control-section h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #87CEFA; /* LightSkyBlue for headers */
        }

        input[type="text"], input[type="time"], input[type="datetime-local"], select, button {
            background-color: #333;
            color: #FFFFFF;
            border: 1px solid #555;
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            width: calc(100% - 18px); /* Ajustar por padding y borde */
            box-sizing: border-box;
        }
        
        input[type="checkbox"] {
            margin-right: 5px;
            vertical-align: middle;
        }

        button {
            cursor: pointer;
            background-color: #007bff; /* Azul para botones primarios */
        }
        button:hover {
            background-color: #0056b3;
        }
        button.danger {
            background-color: #dc3545; /* Rojo para botones de peligro */
        }
        button.danger:hover {
            background-color: #c82333;
        }
        button.secondary {
            background-color: #6c757d; /* Gris para secundarios */
        }
        button.secondary:hover {
            background-color: #545b62;
        }


        #stopsList {
            list-style-type: none;
            padding: 0;
        }
        #stopsList li {
            background-color: #222;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        #stopsList li.next-stop-highlight {
            background-color: #0056b3; /* Azul oscuro para destacar próxima parada */
            font-weight: bold;
        }

        #trackingInfo {
            font-size: 1em;
        }
        #deviationDisplay.adelantado {
            color: #00FF00; /* Verde */
        }
        #deviationDisplay.atrasado {
            color: #FF0000; /* Rojo */
        }
        #deviationDisplay.atiempo {
            color: #FFFFFF; /* Blanco */
        }

        /* Estilos para los iconos de Leaflet */
        .leaflet-div-icon {
            background: transparent;
            border: none;
        }
        .custom-marker-content {
            color: white;
            font-weight: bold;
            text-align: center;
            line-height: 20px; /* Ajustar según tamaño */
            width: 20px; /* Ajustar según tamaño */
            height: 20px; /* Ajustar según tamaño */
            border-radius: 50%; /* Círculo */
            font-size: 12px;
        }
        .start-marker .custom-marker-content { background-color: blue; }
        .end-marker .custom-marker-content { background-color: darkred; }
        .intermediate-marker .custom-marker-content { background-color: orange; }
        .driver-marker {
            background-color: rgba(0, 123, 255, 0.7); /* Azul pulsante */
            border: 2px solid white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            box-shadow: 0 0 0 rgba(0, 123, 255, 0.7);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 123, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 123, 255, 0); }
        }

    </style>
</head>
<body>
    <div id="map"></div>
    <div id="controlsArea">
        <div class="control-section">
            <h3>Crear/Modificar Ruta Actual</h3>
            <p>Toca el mapa para añadir paradas. La primera es INICIO, la segunda FIN, las siguientes INTERMEDIAS.</p>
            <input type="text" id="stopName" placeholder="Nombre de la parada (opcional para intermedias)">
            <input type="time" id="stopTime" placeholder="HH:MM (obligatorio para Inicio/Fin)">
            <p id="currentStopTypeInfo">Siguiente parada a añadir: INICIO</p>
            
            <label for="autoCalcTimes">
                <input type="checkbox" id="autoCalcTimes" checked> Calcular horarios intermedios automáticamente
            </label>
            <button id="resetCurrentRouteBtn">Limpiar Paradas Actuales</button>
        </div>

        <div class="control-section">
            <h3>Ruta Actual</h3>
            <ul id="stopsList">
                </ul>
        </div>

        <div class="control-section">
            <h3>Gestión de Rutas</h3>
            <input type="text" id="routeName" placeholder="Nombre para guardar la ruta">
            <button id="saveRouteBtn">Guardar Ruta Actual</button>
            <hr>
            <select id="savedRoutesSelect">
                <option value="">-- Cargar Ruta Guardada --</option>
            </select>
            <button id="loadRouteBtn">Cargar Ruta Seleccionada</button>
            <button id="deleteRouteBtn" class="danger">Borrar Ruta Seleccionada</button>
        </div>
        
        <div class="control-section">
            <h3>Seguimiento en Tiempo Real</h3>
            <button id="startTrackingBtn">Iniciar Seguimiento</button>
            <button id="stopTrackingBtn" style="display:none;">Detener Seguimiento</button>
            <div id="trackingInfo" style="margin-top:10px;">
                <p>Próxima Parada: <span id="nextStopDisplay">-</span></p>
                <p>Velocidad: <span id="speedDisplay">- km/h</span></p>
                <p>Desvío Horario: <span id="deviationDisplay" class="atiempo">00:00</span></p>
            </div>
            <label for="manualAdvance">
                <input type="checkbox" id="manualAdvance"> Avance Manual de Parada
            </label>
            <div id="manualAdvanceControls" style="display:none; margin-top:5px;">
                <button id="prevStopBtn" class="secondary">Parada Anterior</button>
                <button id="nextStopBtn" class="secondary">Siguiente Parada</button>
            </div>
        </div>

    </div>

    <script>
        // Variables globales
        let map;
        let currentRouteStops = []; // {lat, lng, name, time, type, originalIndex}
        let routePolyline = null;
        let stopMarkers = [];
        let driverMarker = null;
        let geolocWatchId = null;
        let isTracking = false;
        let currentTrackingStopIndex = 0; // Índice en currentRouteStops
        const PROXIMITY_THRESHOLD = 50; // metros para detección de parada

        // --- INICIALIZACIÓN ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadSavedRoutesList();
            attachEventListeners();
            updateCurrentStopTypeInfo();
            checkLocalStorageSupport();
        });

        function checkLocalStorageSupport() {
            if (typeof(Storage) === "undefined") {
                alert("Tu navegador no soporta localStorage. No se podrán guardar ni cargar rutas.");
                document.getElementById('saveRouteBtn').disabled = true;
                document.getElementById('loadRouteBtn').disabled = true;
                document.getElementById('deleteRouteBtn').disabled = true;
                document.getElementById('routeName').disabled = true;
                document.getElementById('savedRoutesSelect').disabled = true;
            }
        }

        function initMap() {
            map = L.map('map').setView([20, 0], 2); // Vista inicial genérica
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            map.on('click', onMapClick);

            // Intentar centrar el mapa en la ubicación actual del usuario al inicio
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => map.setView([position.coords.latitude, position.coords.longitude], 13),
                    () => console.warn("No se pudo obtener la ubicación inicial.")
                );
            }
        }

        function attachEventListeners() {
            document.getElementById('saveRouteBtn').addEventListener('click', saveRoute);
            document.getElementById('loadRouteBtn').addEventListener('click', loadRoute);
            document.getElementById('deleteRouteBtn').addEventListener('click', deleteRoute);
            document.getElementById('resetCurrentRouteBtn').addEventListener('click', resetCurrentRoute);
            
            document.getElementById('startTrackingBtn').addEventListener('click', startTracking);
            document.getElementById('stopTrackingBtn').addEventListener('click', stopTracking);

            document.getElementById('manualAdvance').addEventListener('change', toggleManualAdvanceControls);
            document.getElementById('prevStopBtn').addEventListener('click', () => manualAdvanceStop(-1));
            document.getElementById('nextStopBtn').addEventListener('click', () => manualAdvanceStop(1));
        }

        // --- LÓGICA DE CREACIÓN DE RUTA ---
        function onMapClick(e) {
            if (isTracking) {
                alert("Detén el seguimiento actual para modificar la ruta.");
                return;
            }

            const lat = e.latlng.lat;
            const lng = e.latlng.lng;
            const stopNameInput = document.getElementById('stopName');
            const stopTimeInput = document.getElementById('stopTime');
            let stopType;
            let stopTime = stopTimeInput.value;

            if (currentRouteStops.length === 0) { // Inicio
                stopType = 'Inicio';
                if (!stopTime) { alert("Debe ingresar el horario de Salida para la parada de INICIO."); return; }
            } else if (currentRouteStops.length === 1) { // Fin
                stopType = 'Fin';
                if (!stopTime) { alert("Debe ingresar el horario de Llegada para la parada de FIN."); return; }
            } else { // Intermedia
                stopType = 'Intermedia';
                // Nombre y horario son opcionales para intermedias
            }
            
            const stop = {
                lat: lat,
                lng: lng,
                name: stopNameInput.value || `${stopType} ${currentRouteStops.filter(s=>s.type === stopType).length + 1}`,
                time: stopTime, // Se mantendrá como string HH:MM
                type: stopType,
                originalIndex: currentRouteStops.length // Para mantener el orden original antes de recalcular tiempos
            };

            // Si es una parada intermedia y se está insertando después de "Fin",
            // hay que reajustar. La parada de "Fin" siempre debe ser la última definida manualmente.
            if (currentRouteStops.length > 1 && currentRouteStops[1].type === 'Fin' && stopType === 'Intermedia') {
                const finalStop = currentRouteStops.pop(); // Quitar el Fin temporalmente
                currentRouteStops.push(stop); // Añadir la nueva intermedia
                currentRouteStops.push(finalStop); // Volver a poner el Fin al final
            } else {
                 currentRouteStops.push(stop);
            }


            stopNameInput.value = ''; // Limpiar para la siguiente
            // stopTimeInput.value = ''; // No limpiar el tiempo, puede ser útil para paradas secuenciales.

            if (document.getElementById('autoCalcTimes').checked && currentRouteStops.length > 2 && currentRouteStops[0].time && currentRouteStops[1].time) {
                calculateAndApplyIntermediateTimes();
            }
            
            visualizeCurrentRoute();
            updateCurrentStopTypeInfo();
        }
        
        function updateCurrentStopTypeInfo() {
            const infoEl = document.getElementById('currentStopTypeInfo');
            if (currentRouteStops.length === 0) infoEl.textContent = "Siguiente parada a añadir: INICIO (nombre y horario obligatorios)";
            else if (currentRouteStops.length === 1) infoEl.textContent = "Siguiente parada a añadir: FIN (nombre y horario obligatorios)";
            else infoEl.textContent = "Siguiente parada a añadir: INTERMEDIA (nombre y horario opcionales)";
        }

        function resetCurrentRoute() {
            if (isTracking) {
                alert("Detén el seguimiento para limpiar la ruta.");
                return;
            }
            currentRouteStops = [];
            visualizeCurrentRoute();
            updateCurrentStopTypeInfo();
            document.getElementById('stopsList').innerHTML = ''; // Limpiar lista
        }

        function calculateAndApplyIntermediateTimes() {
            if (currentRouteStops.length < 2) return; // Necesita al menos inicio y fin

            const startStop = currentRouteStops.find(s => s.type === 'Inicio');
            const endStop = currentRouteStops.find(s => s.type === 'Fin');

            if (!startStop || !endStop || !startStop.time || !endStop.time) {
                console.warn("Inicio o Fin no definidos o sin horario para cálculo automático.");
                return;
            }

            const startTimeSeconds = timeToSeconds(startStop.time);
            const endTimeSeconds = timeToSeconds(endStop.time);
            const totalTripDurationSeconds = endTimeSeconds - startTimeSeconds;

            if (totalTripDurationSeconds <= 0) {
                console.warn("La hora de fin debe ser posterior a la de inicio.");
                // Podríamos optar por limpiar los tiempos intermedios o mostrar un error
                currentRouteStops.forEach(stop => {
                    if (stop.type === 'Intermedia' && !stop.manuallySetTime) { // Asumimos que si el usuario puso tiempo, no lo tocamos
                        stop.time = '';
                    }
                });
                visualizeCurrentRoute(); // Actualizar la lista para reflejar tiempos vacíos
                return;
            }

            // Recopilar solo las paradas que forman el trayecto principal (Inicio, Intermedias, Fin) en orden
            let pathStops = [startStop];
            currentRouteStops.filter(s => s.type === 'Intermedia').sort((a,b) => a.originalIndex - b.originalIndex).forEach(s => pathStops.push(s));
            pathStops.push(endStop);

            // Calcular distancias acumuladas
            let totalHaversineDistance = 0;
            const segmentDistances = [];
            for (let i = 0; i < pathStops.length - 1; i++) {
                const dist = haversineDistance(pathStops[i], pathStops[i+1]);
                segmentDistances.push(dist);
                totalHaversineDistance += dist;
            }

            if (totalHaversineDistance === 0 && pathStops.length > 2) {
                 // Si todas las paradas están en el mismo punto, distribuir tiempo equitativamente
                 // entre las intermedias que no tengan tiempo manual.
                const intermediateStopsWithoutTime = pathStops.filter(s => s.type === 'Intermedia' && !s.time);
                const numSegmentsForEqualDistribution = intermediateStopsWithoutTime.length + 1;
                const timePerSegment = totalTripDurationSeconds / numSegmentsForEqualDistribution;
                
                let accumulatedTime = startTimeSeconds;
                for (let i = 1; i < pathStops.length -1; i++) { // Iterar sobre intermedias
                    if (pathStops[i].type === 'Intermedia' && !pathStops[i].time) {
                        accumulatedTime += timePerSegment;
                        pathStops[i].time = secondsToTime(accumulatedTime);
                    } else if (pathStops[i].type === 'Intermedia' && pathStops[i].time) {
                        accumulatedTime = timeToSeconds(pathStops[i].time); // Usar tiempo manual como base para siguiente cálculo
                    }
                }

            } else if (totalHaversineDistance > 0) {
                let accumulatedTimeSeconds = startTimeSeconds;
                let accumulatedDistance = 0;
                for (let i = 0; i < pathStops.length - 1; i++) {
                    const stopA = pathStops[i];
                    const stopB = pathStops[i+1];
                    
                    // Si la siguiente parada (stopB) es intermedia y tiene tiempo manual,
                    // el tiempo para stopB es ese. El tiempo acumulado se actualiza.
                    if (stopB.type === 'Intermedia' && stopB.time) {
                         // Ya tiene tiempo, no calcular. Actualizar accumulatedTimeSeconds para el siguiente tramo.
                        accumulatedTimeSeconds = timeToSeconds(stopB.time);
                        accumulatedDistance += segmentDistances[i];
                    } 
                    // Si stopB es intermedia y NO tiene tiempo manual, o es la parada de Fin.
                    else if ( (stopB.type === 'Intermedia' && !stopB.time) || stopB.type === 'Fin') {
                        if (segmentDistances[i] > 0 || totalHaversineDistance > 0) { // Evitar división por cero si todas las paradas están superpuestas
                            const proportionOfDistance = (totalHaversineDistance > 0) ? (segmentDistances[i] / totalHaversineDistance) : 0;
                            // El tiempo para este segmento se calcula sobre el tiempo restante TOTAL del viaje, no proporcionalmente
                            // a la duración total original si hubo paradas intermedias con tiempo manual.
                            // Se necesita recalcular el tiempo restante y distancia restante desde la última parada con tiempo fijo.
                            
                            // Encontrar la última parada con tiempo fijo antes de B
                            let lastFixedTimeStop = stopA;
                            let timeAtLastFixed = timeToSeconds(lastFixedTimeStop.time);
                            let distanceAfterLastFixed = 0;
                            let segmentsToConsiderForProportion = [];

                            for (let j = i; j < pathStops.length -1; j++) {
                                distanceAfterLastFixed += segmentDistances[j];
                                segmentsToConsiderForProportion.push(segmentDistances[j]);
                                if (pathStops[j+1].time && pathStops[j+1].type !== 'Fin') { // Siguiente es intermedia con tiempo
                                    break; 
                                }
                                if (pathStops[j+1].type === 'Fin') break;
                            }
                            
                            // Tiempo hasta la siguiente parada fija (o el final)
                            let timeToEndOfCurrentBlock;
                            let nextFixedStop = pathStops.slice(i + 1).find(s => s.time && s.type !== 'Inicio') || endStop;
                            timeToEndOfCurrentBlock = timeToSeconds(nextFixedStop.time) - timeAtLastFixed;

                            if (distanceAfterLastFixed > 0) {
                                accumulatedTimeSeconds += (timeToEndOfCurrentBlock * (segmentDistances[i] / distanceAfterLastFixed));
                            } else if (segmentsToConsiderForProportion.length > 0) { // Múltiples paradas en el mismo sitio
                                 // Distribuir el tiempo equitativamente entre estas paradas sin distancia
                                const stopsInSameSpotWithoutTime = pathStops.slice(pathStops.indexOf(stopA)+1, pathStops.indexOf(nextFixedStop)+1).filter(s=>!s.time);
                                if (stopsInSameSpotWithoutTime.length > 0) {
                                    accumulatedTimeSeconds += timeToEndOfCurrentBlock / (stopsInSameSpotWithoutTime.length);
                                }
                            }
                             
                            if (stopB.type !== 'Fin') { // No sobrescribir el tiempo del Fin
                                stopB.time = secondsToTime(Math.round(accumulatedTimeSeconds));
                            }
                        } else if (stopB.type !== 'Fin') { // Paradas superpuestas, sin tiempo manual
                            // Esta lógica es más compleja si hay múltiples paradas en el mismo sitio.
                            // Simplificación: si no hay distancia, y no hay tiempo, no se asigna por ahora
                            // Una mejor aproximación sería distribuir el tiempo restante equitativamente
                            // entre las paradas sin tiempo que queden hasta la próxima con tiempo o el final.
                            // Esta parte fue parcialmente cubierta arriba con "totalHaversineDistance === 0"
                        }
                    }
                     // Si stopB ya tenía tiempo (manual), accumulatedTimeSeconds ya se actualizó con su tiempo
                    if (stopB.time) {
                        accumulatedTimeSeconds = timeToSeconds(stopB.time);
                    }
                }
            }
            
            // Actualizar currentRouteStops con los tiempos calculados (si no tenían uno manual)
            pathStops.forEach(ps => {
                const originalStop = currentRouteStops.find(s => s.originalIndex === ps.originalIndex);
                if (originalStop && ps.time && (!originalStop.manuallySetTime || originalStop.type === 'Inicio' || originalStop.type === 'Fin')) {
                    originalStop.time = ps.time;
                }
            });

            visualizeCurrentRoute(); // Para actualizar la lista
        }


        // --- VISUALIZACIÓN DE RUTA ---
        function visualizeCurrentRoute() {
            // Limpiar marcadores y polilínea anteriores
            stopMarkers.forEach(marker => map.removeLayer(marker));
            stopMarkers = [];
            if (routePolyline) {
                map.removeLayer(routePolyline);
                routePolyline = null;
            }

            const stopsListElement = document.getElementById('stopsList');
            stopsListElement.innerHTML = ''; // Limpiar lista
            const latLngs = [];

            // Reordenar paradas para visualización: Inicio, Intermedias (por originalIndex), Fin
            let displayStops = [];
            const start = currentRouteStops.find(s => s.type === 'Inicio');
            const end = currentRouteStops.find(s => s.type === 'Fin');
            const intermediates = currentRouteStops.filter(s => s.type === 'Intermedia').sort((a,b) => a.originalIndex - b.originalIndex);
            
            if(start) displayStops.push(start);
            displayStops.push(...intermediates);
            if(end && end !== start) displayStops.push(end); // Evitar duplicar si solo hay una parada (inicio)

            displayStops.forEach((stop, index) => {
                const listItem = document.createElement('li');
                let stopTimeDisplay = stop.time || "N/A";
                listItem.textContent = `${index + 1}. ${stop.name} (${stop.type}) - ${stopTimeDisplay}`;
                
                if (isTracking && index === currentTrackingStopIndex) {
                    listItem.classList.add('next-stop-highlight');
                }
                stopsListElement.appendChild(listItem);

                // Añadir marcador al mapa
                if (stop.lat && stop.lng) {
                    latLngs.push([stop.lat, stop.lng]);
                    let icon;
                    let markerHtml;
                    let className = 'custom-marker';

                    if (stop.type === 'Inicio') {
                        markerHtml = '<div class="custom-marker-content">I</div>';
                        className += ' start-marker';
                    } else if (stop.type === 'Fin') {
                        markerHtml = '<div class="custom-marker-content">F</div>';
                        className += ' end-marker';
                    } else {
                        // Para intermedias, usamos el índice de las paradas intermedias
                        const intermediateDisplayIndex = displayStops.filter(s => s.type === 'Intermedia' && s.originalIndex <= stop.originalIndex).length;
                        markerHtml = `<div class="custom-marker-content">${intermediateDisplayIndex}</div>`;
                        className += ' intermediate-marker';
                    }
                    
                    icon = L.divIcon({
                        className: className,
                        html: markerHtml,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });

                    const marker = L.marker([stop.lat, stop.lng], { icon: icon }).addTo(map);
                    marker.bindPopup(`<b>${stop.name}</b><br>${stop.type}<br>${stopTimeDisplay}`);
                    stopMarkers.push(marker);
                }
            });

            // Dibujar polilínea si hay al menos 2 paradas
            if (latLngs.length >= 2) {
                routePolyline = L.polyline(latLngs, { color: 'blue' }).addTo(map);
                // map.fitBounds(routePolyline.getBounds()); // Ajustar zoom a la ruta
            } else if (latLngs.length === 1) {
                 // map.setView(latLngs[0], 15); // Centrar en la única parada
            }
        }

        // --- GESTIÓN DE RUTAS (localStorage) ---
        function saveRoute() {
            const routeName = document.getElementById('routeName').value;
            if (!routeName) {
                alert("Por favor, ingresa un nombre para la ruta.");
                return;
            }
            if (currentRouteStops.length < 2) {
                alert("La ruta debe tener al menos una parada de Inicio y una de Fin para ser guardada.");
                return;
            }
             if (!currentRouteStops.find(s => s.type === 'Inicio') || !currentRouteStops.find(s => s.type === 'Fin')){
                alert("La ruta debe tener una parada de Inicio y una de Fin definidas.");
                return;
            }

            try {
                localStorage.setItem(`smartmovepro_route_${routeName}`, JSON.stringify(currentRouteStops));
                alert(`Ruta "${routeName}" guardada.`);
                loadSavedRoutesList(); // Actualizar el desplegable
            } catch (e) {
                console.error("Error guardando en localStorage:", e);
                alert("Error al guardar la ruta. El almacenamiento podría estar lleno o no disponible.");
            }
        }

        function loadSavedRoutesList() {
            const select = document.getElementById('savedRoutesSelect');
            select.innerHTML = '<option value="">-- Cargar Ruta Guardada --</option>'; // Resetear
            try {
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('smartmovepro_route_')) {
                        const routeName = key.replace('smartmovepro_route_', '');
                        const option = document.createElement('option');
                        option.value = routeName;
                        option.textContent = routeName;
                        select.appendChild(option);
                    }
                }
            } catch (e) {
                console.error("Error leyendo de localStorage:", e);
            }
        }

        function loadRoute() {
            if (isTracking) {
                alert("Detén el seguimiento actual para cargar otra ruta.");
                return;
            }
            const routeName = document.getElementById('savedRoutesSelect').value;
            if (!routeName) {
                alert("Por favor, selecciona una ruta para cargar.");
                return;
            }
            try {
                const routeData = localStorage.getItem(`smartmovepro_route_${routeName}`);
                if (routeData) {
                    currentRouteStops = JSON.parse(routeData);
                    visualizeCurrentRoute();
                    updateCurrentStopTypeInfo(); // Aunque no se esté creando, para consistencia
                    document.getElementById('routeName').value = routeName; // Poner el nombre cargado en el input de guardar
                    alert(`Ruta "${routeName}" cargada.`);
                } else {
                    alert("No se encontró la ruta seleccionada.");
                }
            } catch (e) {
                console.error("Error cargando desde localStorage:", e);
                alert("Error al cargar la ruta.");
            }
        }

        function deleteRoute() {
             if (isTracking) {
                alert("Detén el seguimiento actual para borrar una ruta.");
                return;
            }
            const routeName = document.getElementById('savedRoutesSelect').value;
            if (!routeName) {
                alert("Por favor, selecciona una ruta para borrar.");
                return;
            }
            if (confirm(`¿Estás seguro de que quieres borrar la ruta "${routeName}"?`)) {
                try {
                    localStorage.removeItem(`smartmovepro_route_${routeName}`);
                    alert(`Ruta "${routeName}" borrada.`);
                    loadSavedRoutesList(); // Actualizar el desplegable
                    // Si la ruta borrada era la actual, limpiarla (opcional)
                    if (document.getElementById('routeName').value === routeName) {
                        resetCurrentRoute();
                        document.getElementById('routeName').value = "";
                    }
                } catch (e) {
                    console.error("Error borrando de localStorage:", e);
                    alert("Error al borrar la ruta.");
                }
            }
        }


        // --- SEGUIMIENTO EN TIEMPO REAL ---
        function startTracking() {
            if (currentRouteStops.length < 2) {
                alert("Carga o crea una ruta con al menos Inicio y Fin para iniciar el seguimiento.");
                return;
            }
             if (!currentRouteStops.find(s => s.type === 'Inicio') || !currentRouteStops.find(s => s.type === 'Fin')){
                alert("La ruta actual no tiene una parada de Inicio y/o Fin bien definida.");
                return;
            }
             // Asegurarse que todos los horarios necesarios estén presentes
            for (const stop of currentRouteStops) {
                if ((stop.type === 'Inicio' || stop.type === 'Fin' || (stop.type === 'Intermedia' && stop.time)) && !isValidTime(stop.time)) {
                     alert(`La parada "${stop.name}" tiene un formato de hora inválido. Use HH:MM.`);
                     return;
                }
            }


            isTracking = true;
            currentTrackingStopIndex = 0; // Empezar desde la primera parada
            updateNextStopDisplay();
            visualizeCurrentRoute(); // Para resaltar la primera parada

            document.getElementById('startTrackingBtn').style.display = 'none';
            document.getElementById('stopTrackingBtn').style.display = 'inline-block';
            document.getElementById('resetCurrentRouteBtn').disabled = true;
            document.getElementById('saveRouteBtn').disabled = true;
            document.getElementById('loadRouteBtn').disabled = true;
             // Deshabilitar controles de edición de ruta mientras se rastrea

            if (navigator.geolocation) {
                geolocWatchId = navigator.geolocation.watchPosition(
                    geolocationSuccess,
                    geolocationError,
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                );
            } else {
                alert("Geolocalización no soportada por este navegador.");
                stopTracking(); // Revertir estado
            }
        }

        function stopTracking() {
            isTracking = false;
            if (geolocWatchId) {
                navigator.geolocation.clearWatch(geolocWatchId);
                geolocWatchId = null;
            }
            if (driverMarker) {
                map.removeLayer(driverMarker);
                driverMarker = null;
            }
            
            document.getElementById('startTrackingBtn').style.display = 'inline-block';
            document.getElementById('stopTrackingBtn').style.display = 'none';
            document.getElementById('resetCurrentRouteBtn').disabled = false;
            document.getElementById('saveRouteBtn').disabled = false;
            document.getElementById('loadRouteBtn').disabled = false;

            document.getElementById('speedDisplay').textContent = '- km/h';
            document.getElementById('deviationDisplay').textContent = '00:00';
            document.getElementById('deviationDisplay').className = 'atiempo';
            document.getElementById('nextStopDisplay').textContent = '-';
            currentTrackingStopIndex = 0; // Reset
            visualizeCurrentRoute(); // Quitar resaltado
            alert("Seguimiento detenido.");
        }

        function geolocationSuccess(position) {
            const { latitude, longitude, speed } = position.coords;

            // Actualizar marcador del conductor
            if (!driverMarker) {
                const driverIcon = L.divIcon({
                    className: 'driver-marker',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });
                driverMarker = L.marker([latitude, longitude], { icon: driverIcon, zIndexOffset: 1000 }).addTo(map);
            } else {
                driverMarker.setLatLng([latitude, longitude]);
            }
            map.panTo([latitude, longitude]); // Opcional: centrar mapa en conductor

            // Mostrar velocidad
            const speedKmh = speed ? (speed * 3.6).toFixed(1) : '-'; // m/s a km/h
            document.getElementById('speedDisplay').textContent = `${speedKmh} km/h`;

            // Lógica de desvío y avance de parada
            if (currentRouteStops.length > 0 && currentTrackingStopIndex < currentRouteStops.length) {
                calculateAndDisplayDeviation({ lat: latitude, lng: longitude });
                
                if (!document.getElementById('manualAdvance').checked) {
                    checkAutoAdvanceStop({ lat: latitude, lng: longitude });
                }
            } else if (currentTrackingStopIndex >= currentRouteStops.length) {
                 // Ruta completada
                 document.getElementById('nextStopDisplay').textContent = "RUTA COMPLETADA";
                 // Opcionalmente, detener el seguimiento aquí.
                 // stopTracking(); 
                 // alert("¡Ruta completada!");
            }
        }

        function geolocationError(error) {
            console.error("Error de geolocalización:", error);
            let message = "Error de geolocalización: ";
            switch(error.code) {
                case error.PERMISSION_DENIED: message += "Permiso denegado."; break;
                case error.POSITION_UNAVAILABLE: message += "Posición no disponible."; break;
                case error.TIMEOUT: message += "Timeout obteniendo posición."; break;
                default: message += "Error desconocido."; break;
            }
            alert(message);
            stopTracking(); // Detener si hay error crítico
        }

        function calculateAndDisplayDeviation(currentLocation) {
            // Ordenar las paradas por su índice original para el cálculo
            const orderedStops = [...currentRouteStops].sort((a, b) => a.originalIndex - b.originalIndex);

            let stopA, stopB;

            if (currentTrackingStopIndex === 0) { // Antes de la primera parada (Inicio)
                stopA = orderedStops.find(s => s.type === 'Inicio');
                // Si solo hay una parada de inicio y luego fin, B es el fin.
                // Si hay intermedias, B es la primera parada (que sería el inicio mismo o la primera intermedia).
                 stopB = orderedStops.find(s => s.originalIndex >= stopA.originalIndex && s.time) || orderedStops.find(s => s.type === 'Fin' && s.time);
                 // Considerar el tramo desde una "salida teórica" antes del inicio, o directamente el inicio.
                 // Para simplificar, si estamos antes del inicio, el desvío se calcula respecto al inicio.
                if (!stopA || !stopA.time) { updateDeviationDisplay(0, 'atiempo'); return; }

                const timeToStopA_seconds = timeToSeconds(stopA.time);
                const now_seconds = timeToSeconds(getCurrentHHMMSS());
                const deviationSeconds = now_seconds - timeToStopA_seconds; // Negativo si es temprano, positivo si es tarde
                // Aquí la convención es: si llego ANTES de T_A, estoy adelantado. Adelantado es POSITIVO.
                // Hora_Actual - T_esperado. Si Hora_Actual < T_esperado, es negativo (adelantado)
                // Para que coincida con la lógica del prompt (+ para adelantado), invertimos.
                updateDeviationDisplay(-deviationSeconds);
                return;

            } else { // Entre paradas o después de la última
                // Parada A es la última parada "pasada" o la actual si estamos justo en ella.
                // Usamos currentTrackingStopIndex para determinar la "siguiente parada".
                // Parada A es currentTrackingStopIndex - 1
                // Parada B es currentTrackingStopIndex
                
                // Necesitamos las paradas con tiempo para el cálculo.
                // Encuentra la última parada con tiempo ANTES o IGUAL a currentTrackingStopIndex-1
                let lastPassedStopWithTimeIndex = -1;
                for(let i = currentTrackingStopIndex -1; i >=0; i--) {
                    if (orderedStops[i] && orderedStops[i].time) {
                        lastPassedStopWithTimeIndex = i;
                        break;
                    }
                }
                if(lastPassedStopWithTimeIndex === -1 && orderedStops[0] && orderedStops[0].time) { // Caso especial: si solo el inicio tiene tiempo
                    stopA = orderedStops[0];
                } else if (lastPassedStopWithTimeIndex !== -1) {
                     stopA = orderedStops[lastPassedStopWithTimeIndex];
                }


                // Encuentra la próxima parada con tiempo DESPUÉS o IGUAL a currentTrackingStopIndex
                let nextScheduledStopIndex = -1;
                 for(let i = currentTrackingStopIndex; i < orderedStops.length; i++) {
                    if (orderedStops[i] && orderedStops[i].time) {
                        nextScheduledStopIndex = i;
                        break;
                    }
                }
                if (nextScheduledStopIndex !== -1) {
                    stopB = orderedStops[nextScheduledStopIndex];
                }

                // Si no se encuentra A o B con tiempo, o son la misma, no se puede calcular desvío.
                if (!stopA || !stopB || !stopA.time || !stopB.time || stopA.originalIndex === stopB.originalIndex) {
                    // console.warn("No se pueden determinar paradas A y B con tiempo para calcular desvío.", stopA, stopB);
                    updateDeviationDisplay(0, 'atiempo'); // O un estado indefinido
                    return;
                }
            }


            const T_A_seconds = timeToSeconds(stopA.time);
            const T_B_seconds = timeToSeconds(stopB.time);
            const TT_tramo_seconds = T_B_seconds - T_A_seconds;

            if (TT_tramo_seconds <= 0 && stopA.originalIndex !== stopB.originalIndex) {
                // console.warn("Tiempo de tramo no positivo entre", stopA.name, "y", stopB.name);
                // Podría ser que B es antes que A si la ruta no está ordenada o los tiempos son inconsistentes.
                // En este caso, calculamos desvío respecto a la próxima parada B.
                const now_seconds = timeToSeconds(getCurrentHHMMSS());
                const deviationSeconds = now_seconds - T_B_seconds;
                updateDeviationDisplay(-deviationSeconds); // Invertido para + adelantado
                return;
            } else if (TT_tramo_seconds <= 0 && stopA.originalIndex === stopB.originalIndex) {
                // Estamos "en" la parada stopA (que es la misma que stopB en este escenario)
                const now_seconds = timeToSeconds(getCurrentHHMMSS());
                const deviationSeconds = now_seconds - T_A_seconds;
                updateDeviationDisplay(-deviationSeconds); // Invertido para + adelantado
                return;
            }


            const D_total = haversineDistance(stopA, stopB);
            const D_recorrida = haversineDistance(stopA, currentLocation);

            let T_esperado_actual_seconds;
            if (D_total > 0) {
                // Asegurar que D_recorrida no exceda D_total para el cálculo de proporción (puede pasar por imprecisión de GPS)
                const proportion = Math.min(1, Math.max(0, D_recorrida / D_total));
                T_esperado_actual_seconds = T_A_seconds + (TT_tramo_seconds * proportion);
            } else { // Paradas A y B en el mismo lugar
                // Si D_total es 0, el tiempo esperado es el de A (o B, son iguales en tiempo programado si TT_tramo es 0)
                // Si TT_tramo > 0 pero D_total es 0, significa que hay un tiempo de espera en el mismo punto.
                // En este caso, el tiempo esperado es T_A hasta que llegue T_B.
                // Para simplificar, si estamos en D_total = 0, T_esperado = T_A.
                // Si la hora actual es > T_A, estamos "atrasados" para ese punto.
                 T_esperado_actual_seconds = T_A_seconds; // O un promedio, o T_A si estamos más cerca de A.
                                                      // O T_B si ya pasamos la mitad del tiempo del tramo.
                                                      // Por ahora, simplificamos a T_A.
                                                      // Si estamos en un tramo donde D_total es 0 pero TT_tramo > 0 (espera en parada)
                                                      // T_esperado_actual podría ser simplemente la hora actual, y el desvío 0
                                                      // hasta que pase T_B. Esto es complejo.
                                                      // La lógica original asume movimiento.
                                                      // Si D_total es 0, el tiempo esperado es T_A si Hora_Actual < T_B, sino T_B.
                 const now = timeToSeconds(getCurrentHHMMSS());
                 if (now < T_A_seconds) T_esperado_actual_seconds = T_A_seconds;
                 else if (now > T_B_seconds) T_esperado_actual_seconds = T_B_seconds;
                 else T_esperado_actual_seconds = now; // Dentro del tiempo de espera, estamos "a tiempo"
            }

            const hora_actual_seconds = timeToSeconds(getCurrentHHMMSS());
            const desvio_seconds = hora_actual_seconds - T_esperado_actual_seconds;
            
            // Invertir para que positivo sea adelantado
            updateDeviationDisplay(-desvio_seconds);
        }

        function updateDeviationDisplay(deviationSeconds) {
            const sign = deviationSeconds > 0 ? '+' : (deviationSeconds < 0 ? '-' : '');
            const absSeconds = Math.abs(Math.round(deviationSeconds));
            const minutes = Math.floor(absSeconds / 60);
            const seconds = absSeconds % 60;
            const displayString = `${sign}${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

            const deviationEl = document.getElementById('deviationDisplay');
            deviationEl.textContent = displayString;
            if (deviationSeconds > 0) deviationEl.className = 'adelantado';
            else if (deviationSeconds < 0) deviationEl.className = 'atrasado';
            else deviationEl.className = 'atiempo';
        }
        
        function checkAutoAdvanceStop(currentLocation) {
            const orderedStops = [...currentRouteStops].sort((a, b) => a.originalIndex - b.originalIndex);
            if (currentTrackingStopIndex >= orderedStops.length) return; // Ya se completó la ruta

            const nextStopTarget = orderedStops[currentTrackingStopIndex];
            if (!nextStopTarget) return;

            const distanceToNextStop = haversineDistance(currentLocation, nextStopTarget);

            if (distanceToNextStop < PROXIMITY_THRESHOLD) {
                advanceToNextLogicalStop();
            } else {
                // Lógica para "saltar" parada si se desvía significativamente y se acerca más a una posterior.
                // Esto es más complejo. Por ahora, solo avanza secuencialmente por proximidad.
                // Podríamos buscar la parada más cercana EN ADELANTE en la ruta.
                let closestForwardStopIndex = -1;
                let minDistance = Infinity;

                for (let i = currentTrackingStopIndex + 1; i < orderedStops.length; i++) {
                    const forwardStop = orderedStops[i];
                    const dist = haversineDistance(currentLocation, forwardStop);
                    if (dist < PROXIMITY_THRESHOLD * 2 && dist < minDistance) { // Umbral mayor para saltos
                        minDistance = dist;
                        closestForwardStopIndex = i;
                    }
                }
                if (closestForwardStopIndex !== -1) {
                    // Comprobar si estamos mucho más cerca de esta que de la actual "nextStopTarget"
                    if (minDistance < distanceToNextStop / 2 ) { // Arbitrario: si está al menos el doble de cerca
                        console.log(`Salto detectado a la parada: ${orderedStops[closestForwardStopIndex].name}`);
                        currentTrackingStopIndex = closestForwardStopIndex;
                        updateNextStopDisplay();
                        visualizeCurrentRoute(); // Re-resaltar
                    }
                }
            }
        }
        
        function advanceToNextLogicalStop() {
             // La "próxima parada lógica" es simplemente la siguiente en el array ordenado.
            currentTrackingStopIndex++;
            if (currentTrackingStopIndex >= currentRouteStops.length) {
                document.getElementById('nextStopDisplay').textContent = "RUTA COMPLETADA";
                // Opcional: detener seguimiento aquí.
                // setTimeout(() => { // Dar tiempo a ver el mensaje
                //    if(isTracking) stopTracking(); 
                //    alert("¡Ruta completada!");
                // }, 2000);
            } else {
                updateNextStopDisplay();
            }
            visualizeCurrentRoute(); // Para actualizar resaltado en lista y potencialmente en mapa
        }


        function toggleManualAdvanceControls() {
            const manualAdvanceCheckbox = document.getElementById('manualAdvance');
            const manualControlsDiv = document.getElementById('manualAdvanceControls');
            manualControlsDiv.style.display = manualAdvanceCheckbox.checked ? 'block' : 'none';
        }

        function manualAdvanceStop(direction) { // 1 para siguiente, -1 para anterior
            if (!isTracking) {
                alert("Debe iniciar el seguimiento para usar el avance manual.");
                return;
            }
            
            const newIndex = currentTrackingStopIndex + direction;

            if (newIndex >= 0 && newIndex < currentRouteStops.length) {
                currentTrackingStopIndex = newIndex;
            } else if (newIndex >= currentRouteStops.length) {
                currentTrackingStopIndex = currentRouteStops.length; // Marca como completada
                document.getElementById('nextStopDisplay').textContent = "RUTA COMPLETADA";
                alert("Has llegado al final de la ruta (manualmente).");
            } else {
                // Ya está en la primera parada, no puede retroceder más
                currentTrackingStopIndex = 0;
            }
            updateNextStopDisplay();
            visualizeCurrentRoute(); // Para actualizar resaltado
        }
        
        function updateNextStopDisplay() {
            const orderedStops = [...currentRouteStops].sort((a,b) => a.originalIndex - b.originalIndex);
            const nextStopDisplayEl = document.getElementById('nextStopDisplay');
            if (currentTrackingStopIndex < orderedStops.length) {
                const nextStop = orderedStops[currentTrackingStopIndex];
                nextStopDisplayEl.textContent = `${nextStop.name} (${nextStop.time || 'N/A'})`;
            } else {
                nextStopDisplayEl.textContent = "RUTA COMPLETADA";
            }
        }


        // --- FUNCIONES UTILITARIAS ---
        function haversineDistance(coords1, coords2) { // {lat, lng}, {lat, lng}
            if (!coords1 || !coords2 || typeof coords1.lat !== 'number' || typeof coords1.lng !== 'number' || typeof coords2.lat !== 'number' || typeof coords2.lng !== 'number') {
                return Infinity; // O algún valor que indique error/imposibilidad
            }
            const R = 6371e3; // Radio de la Tierra en metros
            const lat1 = coords1.lat * Math.PI/180;
            const lat2 = coords2.lat * Math.PI/180;
            const deltaLat = (coords2.lat-coords1.lat) * Math.PI/180;
            const deltaLng = (coords2.lng-coords1.lng) * Math.PI/180;

            const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                      Math.cos(lat1) * Math.cos(lat2) *
                      Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // en metros
        }

        function timeToSeconds(timeStr) { // "HH:MM" o "HH:MM:SS"
            if (!timeStr || typeof timeStr !== 'string') return 0;
            const parts = timeStr.split(':');
            if (parts.length < 2) return 0;
            const hours = parseInt(parts[0], 10) || 0;
            const minutes = parseInt(parts[1], 10) || 0;
            const seconds = parts[2] ? (parseInt(parts[2], 10) || 0) : 0;
            return hours * 3600 + minutes * 60 + seconds;
        }

        function secondsToTime(totalSeconds) { // Devuelve "HH:MM"
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            // const seconds = Math.floor(totalSeconds % 60); // No necesitamos segundos para el display de horario de parada
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }
        
        function getCurrentHHMMSS() {
            const now = new Date();
            return `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`;
        }

        function isValidTime(timeStr) {
            if (!timeStr) return false; // Si es opcional y no está, es "válido" en ese contexto, pero para cálculos no.
                                     // Esta función es para verificar formato para cálculo.
            return /^([01]\d|2[0-3]):([0-5]\d)$/.test(timeStr) || /^([01]\d|2[0-3]):([0-5]\d):([0-5]\d)$/.test(timeStr);
        }

    </script>
</body>
</html>
