<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --adelantado-color: #00FF00;
            --atrasado-color: #FF0000;
            --map-height: 60vh;
            --controls-height: calc(100vh - var(--map-height) - 10px); /* 10px for margin */
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            font-family: Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden; /* Evitar scroll general */
        }

        #map {
            width: 100%;
            height: var(--map-height);
            background-color: #333; /* Placeholder color */
        }

        #controls {
            width: 100%;
            height: var(--controls-height);
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .control-section {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #555;
            border-radius: 5px;
        }

        .control-section h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #bbb;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        input[type="text"], input[type="time"], select, button {
            background-color: #333;
            color: var(--text-color);
            border: 1px solid #555;
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            width: calc(100% - 18px); /* Account for padding */
            box-sizing: border-box;
        }
        
        button {
            cursor: pointer;
            background-color: #007bff;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.danger {
            background-color: #dc3545;
        }
        button.danger:hover {
            background-color: #c82333;
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        #stopList {
            list-style-type: none;
            padding: 0;
            max-height: 150px; /* Limit height */
            overflow-y: auto;
        }

        #stopList li {
            background-color: #222;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        #stopList li.next-stop-highlight {
            background-color: #0056b3; /* Blueish highlight for next stop */
            font-weight: bold;
        }


        .adelantado { color: var(--adelantado-color); }
        .atrasado { color: var(--atrasado-color); }
        .a-tiempo { color: var(--text-color); }

        /* Custom Marker Icons using L.divIcon */
        .custom-marker-icon {
            text-align: center;
            color: white;
            font-weight: bold;
            border-radius: 50%;
            width: 30px!important; /* leaflet override */
            height: 30px!important; /* leaflet override */
            line-height: 30px; /* vertical centering */
            font-size: 14px;
            box-shadow: 0 0 5px rgba(0,0,0,0.7);
        }
        .start-marker { background-color: blue; }
        .end-marker { background-color: darkred; }
        .intermediate-marker { background-color: orange; }
        .user-location-marker {
            background-color: dodgerblue;
            border: 2px solid white;
            border-radius: 50%;
            width: 15px !important;
            height: 15px !important;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(30, 144, 255, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(30, 144, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(30, 144, 255, 0); }
        }

        #trackingInfo div {
            margin: 5px 0;
            font-size: 1.1em;
        }
        #trackingInfo #deviationDisplay {
            font-size: 1.3em;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <div id="controls">
        <div class="control-section">
            <h3>Creación de Ruta <small id="stopCreationMode">(Modo: Definiendo Inicio)</small></h3>
            <p>Toca el mapa para añadir paradas. Define Inicio, luego Fin, luego Intermedias.</p>
            <input type="text" id="stopName" placeholder="Nombre de la Parada">
            <input type="time" id="stopTime" placeholder="HH:MM (Opcional para intermedias)">
            <div>
                <input type="checkbox" id="autoCalcIntermediateTimes" checked>
                <label for="autoCalcIntermediateTimes">Calcular horarios intermedios automáticamente</label>
            </div>
            <button id="clearCurrentRouteBtn">Limpiar Ruta Actual</button>
        </div>

        <div class="control-section">
            <h3>Lista de Paradas (<span id="totalStops">0</span>)</h3>
            <ul id="stopList">
                <!-- Paradas se listarán aquí -->
            </ul>
        </div>

        <div class="control-section">
            <h3>Gestión de Rutas</h3>
            <input type="text" id="routeName" placeholder="Nombre para guardar la ruta">
            <button id="saveRouteBtn">Guardar Ruta Actual</button>
            <select id="savedRoutesList">
                <option value="">-- Cargar Ruta Guardada --</option>
            </select>
            <button id="loadRouteBtn">Cargar Ruta Seleccionada</button>
            <button id="deleteRouteBtn" class="danger">Borrar Ruta Seleccionada</button>
        </div>
        
        <div class="control-section">
            <h3>Seguimiento en Tiempo Real</h3>
            <button id="startTrackingBtn">Iniciar Seguimiento</button>
            <button id="stopTrackingBtn" disabled>Detener Seguimiento</button>
            <div>
                <input type="checkbox" id="manualAdvanceStop">
                <label for="manualAdvanceStop">Avance Manual de Parada</label>
            </div>
            <button id="prevStopBtn" disabled>Parada Anterior</button>
            <button id="nextStopBtn" disabled>Siguiente Parada</button>

            <div id="trackingInfo" style="margin-top:10px;">
                <div>Próxima Parada: <span id="nextStopDisplay">-</span></div>
                <div>Velocidad: <span id="speedDisplay">0 km/h</span></div>
                <div>Desvío Horario: <span id="deviationDisplay" class="a-tiempo">00:00</span></div>
            </div>
        </div>
    </div>

    <script>
        let map;
        let currentRoute = { name: "", stops: [] }; // { lat, lng, name, time (HH:MM string), type: 'start'/'intermediate'/'end' }
        let mapMarkers = [];
        let routePolyline = null;
        let userLocationMarker = null;
        let geolocationWatchId = null;
        let isTracking = false;
        let currentStopIndexForTracking = 0; // Index of the *next* stop to reach
        let lastPassedStopIndex = -1; // Index of the last stop successfully passed

        // Stop creation state machine
        let stopCreationStage = 'start'; // 'start', 'end', 'intermediate'
        const stopCreationModeEl = document.getElementById('stopCreationMode');
        
        // UI Elements
        const stopNameInput = document.getElementById('stopName');
        const stopTimeInput = document.getElementById('stopTime');
        const autoCalcIntermediateTimesCheckbox = document.getElementById('autoCalcIntermediateTimes');
        const stopListUl = document.getElementById('stopList');
        const totalStopsEl = document.getElementById('totalStops');
        const routeNameInput = document.getElementById('routeName');
        const savedRoutesListSelect = document.getElementById('savedRoutesList');
        const startTrackingBtn = document.getElementById('startTrackingBtn');
        const stopTrackingBtn = document.getElementById('stopTrackingBtn');
        const manualAdvanceCheckbox = document.getElementById('manualAdvanceStop');
        const prevStopBtn = document.getElementById('prevStopBtn');
        const nextStopBtn = document.getElementById('nextStopBtn');
        const nextStopDisplayEl = document.getElementById('nextStopDisplay');
        const speedDisplayEl = document.getElementById('speedDisplay');
        const deviationDisplayEl = document.getElementById('deviationDisplay');

        function initMap() {
            map = L.map('map').setView([40.416775, -3.703790], 13); // Default to Madrid, Spain

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            map.on('click', handleMapClick);
            loadRoutesFromLocalStorage();
            updateStopCreationModeUI();
        }

        function updateStopCreationModeUI() {
            let modeText = "";
            stopTimeInput.value = ""; // Clear time input on mode change
            stopNameInput.value = ""; // Clear name input

            switch(stopCreationStage) {
                case 'start':
                    modeText = "Definiendo Inicio (Obligatorio nombre y hora)";
                    stopTimeInput.required = true;
                    stopNameInput.placeholder = "Nombre Parada Inicio";
                    break;
                case 'end':
                    modeText = "Definiendo Fin (Obligatorio nombre y hora)";
                    stopTimeInput.required = true;
                    stopNameInput.placeholder = "Nombre Parada Fin";
                    break;
                case 'intermediate':
                    modeText = "Añadiendo Paradas Intermedias (Nombre obligatorio, hora opcional)";
                    stopTimeInput.required = false;
                    stopNameInput.placeholder = "Nombre Parada Intermedia";
                    break;
            }
            stopCreationModeEl.textContent = `(Modo: ${modeText})`;
        }

        function handleMapClick(e) {
            if (isTracking) {
                alert("Detén el seguimiento para modificar la ruta.");
                return;
            }

            const latlng = e.latlng;
            const stopName = stopNameInput.value.trim();
            const stopTime = stopTimeInput.value;

            if (!stopName) {
                alert("Por favor, ingresa un nombre para la parada.");
                stopNameInput.focus();
                return;
            }

            let newStop = { lat: latlng.lat, lng: latlng.lng, name: stopName, time: stopTime, type: stopCreationStage };

            if (stopCreationStage === 'start') {
                if (!stopTime) {
                    alert("Debes ingresar el horario de salida para la parada de Inicio.");
                    stopTimeInput.focus();
                    return;
                }
                currentRoute.stops = [newStop]; // Replace if already exists
                stopCreationStage = 'end';
            } else if (stopCreationStage === 'end') {
                if (!stopTime) {
                    alert("Debes ingresar el horario de llegada para la parada Final.");
                    stopTimeInput.focus();
                    return;
                }
                if (currentRoute.stops.length === 0) {
                     alert("Primero debes definir la parada de Inicio.");
                     stopCreationStage = 'start'; // Reset
                     updateStopCreationModeUI();
                     return;
                }
                // Ensure end time is after start time
                if (currentRoute.stops.length > 0 && parseTimeToSeconds(stopTime) <= parseTimeToSeconds(currentRoute.stops[0].time)) {
                    alert("La hora de Fin debe ser posterior a la hora de Inicio.");
                    return;
                }
                currentRoute.stops.push(newStop);
                stopCreationStage = 'intermediate';
            } else { // intermediate
                if (currentRoute.stops.length < 2) {
                    alert("Primero debes definir las paradas de Inicio y Fin.");
                    return;
                }
                // Insert intermediate stop before the 'end' stop
                currentRoute.stops.splice(currentRoute.stops.length - 1, 0, newStop);
            }
            
            if (autoCalcIntermediateTimesCheckbox.checked && currentRoute.stops.length > 2) {
                calculateAndSetIntermediateTimes();
            }

            renderRouteOnMap();
            updateStopListUI();
            updateStopCreationModeUI();
            stopNameInput.value = ""; // Clear for next input
            // stopTimeInput.value = ""; // Cleared in updateStopCreationModeUI
        }

        function calculateAndSetIntermediateTimes() {
            // Se necesitan al menos una parada de Inicio y una de Fin para este cálculo.
            if (currentRoute.stops.length < 2) {
                // console.log("calculateAndSetIntermediateTimes: No hay suficientes paradas (necesita Inicio y Fin).");
                return;
            }

            const startStop = currentRoute.stops[0];
            // La parada final siempre es la última en el array según la lógica de adición.
            const endStop = currentRoute.stops[currentRoute.stops.length - 1];

            // Asegurarse que la primera es 'start' y la última es 'end', y que ambas tienen horarios definidos.
            if (startStop.type !== 'start' || endStop.type !== 'end' || !startStop.time || !endStop.time) {
                // console.log("calculateAndSetIntermediateTimes: La ruta no tiene una parada de Inicio o Fin válida con horario definido.");
                return; 
            }

            const startTimeSeconds = parseTimeToSeconds(startStop.time);
            const endTimeSeconds = parseTimeToSeconds(endStop.time);
            const totalRouteDurationSeconds = endTimeSeconds - startTimeSeconds;

            // La duración total de la ruta debe ser positiva.
            if (totalRouteDurationSeconds <= 0) {
                // console.log("calculateAndSetIntermediateTimes: La duración total de la ruta (Fin - Inicio) no es positiva.");
                return;
            }

            // Distancia total en línea recta (Haversine) entre la parada de Inicio y la parada de Fin de la ruta.
            const totalRouteHaversineDistance = haversineDistance(startStop, endStop);

            // Si la distancia total entre Inicio y Fin es cero (están en el mismo punto):
            if (totalRouteHaversineDistance === 0) {
                // console.log("calculateAndSetIntermediateTimes: La distancia total de la ruta (Inicio-Fin) es cero.");
                // A todas las paradas intermedias sin tiempo se les podría asignar el horario de inicio.
                for (let i = 1; i < currentRoute.stops.length - 1; i++) {
                    const intermediateStop = currentRoute.stops[i];
                    if (intermediateStop.type === 'intermediate' && !intermediateStop.time) {
                        intermediateStop.time = startStop.time;
                    }
                }
                return;
            }

            // Iterar solo sobre las paradas intermedias.
            // Estas son las paradas desde el índice 1 hasta el penúltimo índice.
            for (let i = 1; i < currentRoute.stops.length - 1; i++) {
                const intermediateStop = currentRoute.stops[i];
                
                // Solo calcular si es una parada intermedia Y no tiene un horario ya asignado manualmente.
                if (intermediateStop.type === 'intermediate' && !intermediateStop.time) {
                    // Distancia en línea recta desde la parada de Inicio de la ruta hasta ESTA parada intermedia.
                    const distanceFromStartToIntermediate = haversineDistance(startStop, intermediateStop);
                    
                    // Proporción de esta distancia respecto a la distancia total de la ruta (Inicio-Fin).
                    const distanceRatio = distanceFromStartToIntermediate / totalRouteHaversineDistance;
                    
                    // Tiempo estimado para esta parada intermedia.
                    // Se calcula sumando al tiempo de inicio una porción del tiempo total del viaje,
                    // proporcional a la fracción de la distancia que esta parada representa.
                    let calculatedTimeSeconds = startTimeSeconds + (totalRouteDurationSeconds * distanceRatio);
                    
                    // Convertir los segundos calculados de vuelta a formato HH:MM y asignarlo.
                    intermediateStop.time = formatSecondsToHHMM(Math.round(calculatedTimeSeconds));
                }
            }
            // No es necesario retornar 'currentRoute.stops' ya que el array se modifica por referencia.
            // La UI se actualizará por la llamada a updateStopListUI() después de esta función.
        }

        function renderRouteOnMap() {
            // Clear existing markers and polyline
            mapMarkers.forEach(marker => map.removeLayer(marker));
            mapMarkers = [];
            if (routePolyline) {
                map.removeLayer(routePolyline);
                routePolyline = null;
            }

            if (currentRoute.stops.length === 0) return;

            const latLngs = [];
            currentRoute.stops.forEach((stop, index) => {
                latLngs.push([stop.lat, stop.lng]);
                let iconHtml;
                let className = 'custom-marker-icon ';

                if (stop.type === 'start') {
                    iconHtml = 'I';
                    className += 'start-marker';
                } else if (stop.type === 'end') {
                    iconHtml = 'F';
                    className += 'end-marker';
                } else { // intermediate
                    // Find its actual sequence number among intermediates
                    let intermediateIndex = 0;
                    for(let i=1; i < index; i++) {
                        if(currentRoute.stops[i].type === 'intermediate') intermediateIndex++;
                    }
                    iconHtml = (intermediateIndex + 1).toString();
                    className += 'intermediate-marker';
                }
                
                const customIcon = L.divIcon({
                    className: className,
                    html: iconHtml,
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                });
                const marker = L.marker([stop.lat, stop.lng], { icon: customIcon })
                    .addTo(map)
                    .bindPopup(`<b>${stop.name}</b><br>${stop.type === 'intermediate' ? 'Intermedia' : stop.type.charAt(0).toUpperCase() + stop.type.slice(1)}<br>${stop.time || 'Sin hora prog.'}`);
                mapMarkers.push(marker);
            });

            if (latLngs.length > 1) {
                routePolyline = L.polyline(latLngs, { color: 'blue' }).addTo(map);
                map.fitBounds(routePolyline.getBounds().pad(0.1)); // Adjust zoom to fit route
            } else if (latLngs.length === 1) {
                map.setView(latLngs[0], 15); // Center on the single stop
            }
        }

        function updateStopListUI() {
            stopListUl.innerHTML = ""; // Clear list
            totalStopsEl.textContent = currentRoute.stops.length;

            currentRoute.stops.forEach((stop, index) => {
                const li = document.createElement('li');
                let typeText = "";
                switch(stop.type) {
                    case 'start': typeText = "Inicio"; break;
                    case 'end': typeText = "Fin"; break;
                    case 'intermediate': typeText = "Intermedia"; break;
                }
                li.textContent = `${index + 1}. ${stop.name} (${typeText}) - ${stop.time || 'N/A'}`;
                
                if (isTracking && index === currentStopIndexForTracking) {
                    li.classList.add('next-stop-highlight');
                }
                stopListUl.appendChild(li);
            });
        }

        document.getElementById('clearCurrentRouteBtn').addEventListener('click', () => {
            if (isTracking) {
                alert("Detén el seguimiento para limpiar la ruta.");
                return;
            }
            currentRoute = { name: "", stops: [] };
            stopCreationStage = 'start';
            renderRouteOnMap();
            updateStopListUI();
            updateStopCreationModeUI();
            routeNameInput.value = "";
            alert("Ruta actual limpiada.");
        });

        // --- Persistence (localStorage) ---
        function saveRoute() {
            const name = routeNameInput.value.trim();
            if (!name) {
                alert("Por favor, ingresa un nombre para la ruta.");
                return;
            }
            if (currentRoute.stops.length < 2) {
                alert("La ruta debe tener al menos una parada de Inicio y una de Fin para ser guardada.");
                return;
            }
            currentRoute.name = name; // Assign name to current route object

            try {
                let routes = JSON.parse(localStorage.getItem('smartMoveProRoutes')) || [];
                // Check if route with same name exists, if so, update it
                const existingRouteIndex = routes.findIndex(r => r.name === name);
                if (existingRouteIndex > -1) {
                    routes[existingRouteIndex] = currentRoute;
                } else {
                    routes.push(currentRoute);
                }
                localStorage.setItem('smartMoveProRoutes', JSON.stringify(routes));
                alert(`Ruta "${name}" guardada.`);
                loadRoutesFromLocalStorage(); // Refresh dropdown
            } catch (e) {
                console.error("Error guardando en localStorage:", e);
                alert("Error al guardar la ruta. El almacenamiento local podría estar lleno o no disponible.");
            }
        }

        function loadRoutesFromLocalStorage() {
            savedRoutesListSelect.innerHTML = '<option value="">-- Cargar Ruta Guardada --</option>';
            try {
                const routes = JSON.parse(localStorage.getItem('smartMoveProRoutes')) || [];
                routes.forEach(route => {
                    const option = document.createElement('option');
                    option.value = route.name;
                    option.textContent = route.name;
                    savedRoutesListSelect.appendChild(option);
                });
            } catch (e) {
                console.error("Error cargando desde localStorage:", e);
                alert("Error al cargar rutas. El almacenamiento local podría estar corrupto.");
            }
        }

        function loadSelectedRoute() {
            if (isTracking) {
                alert("Detén el seguimiento actual antes de cargar una nueva ruta.");
                return;
            }
            const routeName = savedRoutesListSelect.value;
            if (!routeName) {
                alert("Selecciona una ruta para cargar.");
                return;
            }
            try {
                const routes = JSON.parse(localStorage.getItem('smartMoveProRoutes')) || [];
                const routeToLoad = routes.find(r => r.name === routeName);
                if (routeToLoad) {
                    currentRoute = JSON.parse(JSON.stringify(routeToLoad)); // Deep copy
                    routeNameInput.value = currentRoute.name; // Populate name field for potential re-save
                    stopCreationStage = 'intermediate'; // Assume loaded route is complete for adding more intermediates
                    renderRouteOnMap();
                    updateStopListUI();
                    updateStopCreationModeUI();
                    alert(`Ruta "${routeName}" cargada.`);
                } else {
                    alert("Ruta no encontrada.");
                }
            } catch (e) {
                console.error("Error cargando ruta seleccionada:", e);
                alert("Error al cargar la ruta seleccionada.");
            }
        }

        function deleteSelectedRoute() {
            if (isTracking) {
                alert("Detén el seguimiento actual antes de borrar una ruta.");
                return;
            }
            const routeName = savedRoutesListSelect.value;
            if (!routeName) {
                alert("Selecciona una ruta para borrar.");
                return;
            }
            if (!confirm(`¿Estás seguro de que quieres borrar la ruta "${routeName}"?`)) {
                return;
            }
            try {
                let routes = JSON.parse(localStorage.getItem('smartMoveProRoutes')) || [];
                routes = routes.filter(r => r.name !== routeName);
                localStorage.setItem('smartMoveProRoutes', JSON.stringify(routes));
                alert(`Ruta "${routeName}" borrada.`);
                loadRoutesFromLocalStorage(); // Refresh dropdown
                 // If the deleted route was the current one, clear it
                if (currentRoute.name === routeName) {
                    document.getElementById('clearCurrentRouteBtn').click();
                }
            } catch (e) {
                console.error("Error borrando ruta:", e);
                alert("Error al borrar la ruta.");
            }
        }

        document.getElementById('saveRouteBtn').addEventListener('click', saveRoute);
        document.getElementById('loadRouteBtn').addEventListener('click', loadSelectedRoute);
        document.getElementById('deleteRouteBtn').addEventListener('click', deleteSelectedRoute);

        // --- Real-Time Tracking ---
        startTrackingBtn.addEventListener('click', () => {
            if (currentRoute.stops.length < 2) {
                alert("Carga o crea una ruta con al menos Inicio y Fin para iniciar el seguimiento.");
                return;
            }
            if (!navigator.geolocation) {
                alert("Geolocalización no soportada por tu navegador.");
                return;
            }

            isTracking = true;
            startTrackingBtn.disabled = true;
            stopTrackingBtn.disabled = false;
            manualAdvanceCheckbox.disabled = true; // Disable changing mode during tracking
            prevStopBtn.disabled = !manualAdvanceCheckbox.checked;
            nextStopBtn.disabled = !manualAdvanceCheckbox.checked;

            currentStopIndexForTracking = 0; // Start from the first stop
            lastPassedStopIndex = -1; // No stop passed yet
            
            // Check if first stop is 'start' and has time
            if (currentRoute.stops[0].type !== 'start' || !currentRoute.stops[0].time) {
                 alert("La ruta debe comenzar con una parada de 'Inicio' con horario definido.");
                 stopTracking(); // Abort
                 return;
            }

            updateTrackingUI();

            geolocationWatchId = navigator.geolocation.watchPosition(
                handleLocationUpdate,
                handleLocationError,
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
            alert("Seguimiento iniciado.");
        });

        stopTrackingBtn.addEventListener('click', stopTracking);

        function stopTracking() {
            isTracking = false;
            startTrackingBtn.disabled = false;
            stopTrackingBtn.disabled = true;
            manualAdvanceCheckbox.disabled = false;
            prevStopBtn.disabled = true;
            nextStopBtn.disabled = true;

            if (geolocationWatchId !== null) {
                navigator.geolocation.clearWatch(geolocationWatchId);
                geolocationWatchId = null;
            }
            if (userLocationMarker) {
                map.removeLayer(userLocationMarker);
                userLocationMarker = null;
            }
            speedDisplayEl.textContent = "0 km/h";
            deviationDisplayEl.textContent = "00:00";
            deviationDisplayEl.className = "a-tiempo";
            nextStopDisplayEl.textContent = "-";
            currentStopIndexForTracking = 0;
            lastPassedStopIndex = -1;
            updateStopListUI(); // Clear highlights
            alert("Seguimiento detenido.");
        }

        function handleLocationUpdate(position) {
            const { latitude, longitude, speed } = position.coords;
            const userLatLng = L.latLng(latitude, longitude);

            if (!userLocationMarker) {
                const userIcon = L.divIcon({
                    className: 'user-location-marker',
                    iconSize: [15, 15],
                    iconAnchor: [7.5, 7.5]
                });
                userLocationMarker = L.marker(userLatLng, {icon: userIcon, zIndexOffset: 1000}).addTo(map);
            } else {
                userLocationMarker.setLatLng(userLatLng);
            }
            map.panTo(userLatLng); // Optionally keep user centered

            speedDisplayEl.textContent = speed ? (speed * 3.6).toFixed(1) + " km/h" : "N/A";

            if (!manualAdvanceCheckbox.checked) {
                checkStopProximityAndAdvance(userLatLng);
            }
            calculateAndDisplayDeviation(userLatLng);
            updateTrackingUI(); // To update next stop name and list highlight
        }

        function handleLocationError(error) {
            console.error("Error de Geolocalización:", error);
            let message = "Error de Geolocalización: ";
            switch(error.code) {
                case error.PERMISSION_DENIED: message += "Permiso denegado."; break;
                case error.POSITION_UNAVAILABLE: message += "Posición no disponible."; break;
                case error.TIMEOUT: message += "Timeout."; break;
                default: message += "Error desconocido."; break;
            }
            alert(message);
            // Consider stopping tracking if error is persistent
            // stopTracking(); 
        }

        function checkStopProximityAndAdvance(userLatLng) {
            if (currentStopIndexForTracking >= currentRoute.stops.length) return; // Route finished

            const nextStopTarget = currentRoute.stops[currentStopIndexForTracking];
            const distanceToNextStop = haversineDistance(userLatLng, nextStopTarget); // in km
            const proximityThresholdMeters = 50; // 50 meters

            if (distanceToNextStop * 1000 < proximityThresholdMeters) {
                advanceToNextStop();
            }
            // Rudimentary "skipped stop" detection:
            // If we are past the current nextStop (e.g. by checking projection or if distance starts increasing)
            // and closer to a subsequent stop in the route sequence, advance.
            // This is complex. For now, simple proximity.
        }
        
        function advanceToNextStop(manual = false) {
            if (currentStopIndexForTracking < currentRoute.stops.length) {
                lastPassedStopIndex = currentStopIndexForTracking;
                currentStopIndexForTracking++;
                if (manual) alert(`Avance manual a: ${currentRoute.stops[currentStopIndexForTracking]?.name || 'Fin de Ruta'}`);
                else console.log(`Avance automático a parada: ${currentRoute.stops[currentStopIndexForTracking]?.name || 'Fin de Ruta'}`);


                if (currentStopIndexForTracking >= currentRoute.stops.length) {
                    alert("¡Ruta completada!");
                    stopTracking();
                    // TODO: Handle route queue if implemented
                }
                updateTrackingUI();
            }
        }
        
        function regressToPreviousStop(manual = false) {
            if (currentStopIndexForTracking > 0) {
                currentStopIndexForTracking--;
                // Determine new lastPassedStopIndex
                lastPassedStopIndex = (currentStopIndexForTracking > 0) ? currentStopIndexForTracking - 1 : -1;
                if (manual) alert(`Retroceso manual a: ${currentRoute.stops[currentStopIndexForTracking]?.name}`);
                else console.log(`Retroceso a parada: ${currentRoute.stops[currentStopIndexForTracking]?.name}`);
                updateTrackingUI();
            }
        }

        manualAdvanceCheckbox.addEventListener('change', (e) => {
            const isManual = e.target.checked;
            prevStopBtn.disabled = !isManual || !isTracking;
            nextStopBtn.disabled = !isManual || !isTracking;
        });

        prevStopBtn.addEventListener('click', () => regressToPreviousStop(true));
        nextStopBtn.addEventListener('click', () => advanceToNextStop(true));

        function updateTrackingUI() {
            if (isTracking && currentStopIndexForTracking < currentRoute.stops.length) {
                nextStopDisplayEl.textContent = currentRoute.stops[currentStopIndexForTracking].name;
            } else {
                nextStopDisplayEl.textContent = isTracking ? "Fin de Ruta" : "-";
            }
            updateStopListUI(); // To update highlights
        }
        
        function calculateAndDisplayDeviation(currentUserLatLng) {
            if (!isTracking || currentStopIndexForTracking >= currentRoute.stops.length) {
                deviationDisplayEl.textContent = "00:00";
                deviationDisplayEl.className = "a-tiempo";
                return;
            }

            let stopA, stopB;
            // Determine Stop A (last passed or start) and Stop B (next upcoming)
            if (lastPassedStopIndex === -1) { // Before passing the first scheduled stop
                stopA = currentRoute.stops[0]; // Should be the 'start' stop
                 // Ensure there's a next stop after start, could be intermediate or end
                if (currentRoute.stops.length > 1) {
                    stopB = currentRoute.stops[currentStopIndexForTracking]; // which should be 0 initially, or 1 if start is 0
                } else { // Only a start stop, no 'next' stop defined for a segment
                    deviationDisplayEl.textContent = "N/A";
                    deviationDisplayEl.className = "a-tiempo";
                    return;
                }
            } else {
                stopA = currentRoute.stops[lastPassedStopIndex];
                stopB = currentRoute.stops[currentStopIndexForTracking];
            }

            if (!stopA || !stopB || !stopA.time || !stopB.time) {
                // console.warn("Paradas A o B o sus tiempos no definidos para cálculo de desvío.", stopA, stopB);
                deviationDisplayEl.textContent = "N/A"; // Not enough info
                deviationDisplayEl.className = "a-tiempo";
                return;
            }

            const T_A_seconds = parseTimeToSeconds(stopA.time);
            const T_B_seconds = parseTimeToSeconds(stopB.time);
            const TT_tramo_seconds = T_B_seconds - T_A_seconds;

            if (TT_tramo_seconds <= 0 && stopA !== stopB) { // Allow same stop for immediate deviation at start
                console.warn("Tiempo de tramo no positivo:", stopA.name, stopB.name, TT_tramo_seconds);
                deviationDisplayEl.textContent = "Error T.";
                deviationDisplayEl.className = "a-tiempo";
                return;
            }
            
            const D_total_km = haversineDistance(stopA, stopB);
            let D_recorrida_km;

            if (stopA === stopB) { // e.g. At the very start, comparing against the start stop itself.
                D_total_km = 1; // Arbitrary non-zero to avoid div by zero, D_recorrida will be 0 or small.
                D_recorrida_km = 0; // Effectively, we are at 0% of this "segment".
            } else {
                 D_recorrida_km = haversineDistance(stopA, currentUserLatLng);
            }


            let T_esperado_actual_seconds;
            if (D_total_km === 0) { // If stops A and B are at the same location OR D_recorrida is beyond D_total
                if (D_recorrida_km > 0.01) { // User is past B, effectively
                     T_esperado_actual_seconds = T_B_seconds;
                } else { // User is at A (or B, if they are same point)
                     T_esperado_actual_seconds = T_A_seconds;
                }
            } else {
                // Clamp D_recorrida to be at most D_total. If user overshoots, expected time is T_B
                const progressRatio = Math.min(D_recorrida_km / D_total_km, 1.0);
                T_esperado_actual_seconds = T_A_seconds + (TT_tramo_seconds * progressRatio);
            }
            
            const now_seconds = getCurrentTimeInSeconds();
            const deviation_seconds = now_seconds - T_esperado_actual_seconds;

            deviationDisplayEl.textContent = formatSecondsToSignedMMSS(deviation_seconds);
            if (deviation_seconds > 5) { // Allow 5s buffer
                deviationDisplayEl.className = "atrasado"; // Hora actual es MAYOR que la esperada -> ATRASADO
            } else if (deviation_seconds < -5) { // Allow 5s buffer
                deviationDisplayEl.className = "adelantado"; // Hora actual es MENOR que la esperada -> ADELANTADO
            } else {
                deviationDisplayEl.className = "a-tiempo";
            }
        }


        // --- Utility Functions ---
        function haversineDistance(coords1, coords2) { // coords in {lat, lng}
            const R = 6371; // Radius of the Earth in km
            const dLat = (coords2.lat - coords1.lat) * Math.PI / 180;
            const dLon = (coords2.lng - coords1.lng) * Math.PI / 180;
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(coords1.lat * Math.PI / 180) * Math.cos(coords2.lat * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // Distance in km
        }

        function parseTimeToSeconds(timeStr) { // "HH:MM"
            if (!timeStr || !timeStr.includes(':')) return 0;
            const parts = timeStr.split(':');
            return parseInt(parts[0], 10) * 3600 + parseInt(parts[1], 10) * 60;
        }

        function formatSecondsToHHMM(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }
        
        function formatSecondsToSignedMMSS(totalSeconds) {
            const sign = totalSeconds < 0 ? "-" : "+";
            totalSeconds = Math.abs(totalSeconds);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            if (sign === "-" && minutes === 0 && seconds === 0) return "00:00"; // Avoid -00:00
            return `${sign}${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function getCurrentTimeInSeconds() {
            const now = new Date();
            return now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', initMap);

    </script>
</body>
</html>
