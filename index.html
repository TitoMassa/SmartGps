<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            overflow: hidden; /* Prevent body scroll */
            display: flex;
            flex-direction: column;
        }

        #map {
            height: 50vh; /* 50% of viewport height */
            width: 100%;
            background-color: #333; /* Placeholder color */
        }

        #controls {
            height: 50vh; /* 50% of viewport height */
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .control-section:last-child {
            border-bottom: none;
        }

        h2, h3 {
            color: #FFFFFF;
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="text"], input[type="datetime-local"], select {
            width: calc(100% - 12px);
            padding: 8px;
            margin-bottom: 10px;
            background-color: #222;
            color: #FFF;
            border: 1px solid #555;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        button:hover {
            background-color: #45a049;
        }
        button.danger {
            background-color: #f44336;
        }
        button.danger:hover {
            background-color: #da190b;
        }
        button.secondary {
            background-color: #007bff;
        }
        button.secondary:hover {
            background-color: #0056b3;
        }


        #statusDisplay {
            text-align: center;
            padding: 10px;
        }
        #timeDeviation {
            font-size: 3em; /* Larger font for time deviation */
            font-weight: bold;
            margin: 10px 0;
        }
        #speedDisplay, #nextStopDisplay {
            font-size: 1.2em;
            margin: 5px 0;
        }

        .stop-item {
            background-color: #1e1e1e;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .stop-item.next-stop-highlight {
            background-color: #007bff;
            font-weight: bold;
        }

        .leaflet-div-icon {
            background: transparent;
            border: none;
            text-align: center;
            font-weight: bold;
            color: white;
        }

        .custom-marker-content {
            padding: 5px 8px;
            border-radius: 50%;
            color: white;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid white;
        }
        
        .user-location-icon {
            background-color: #007bff !important; /* Blue dot */
            border-radius: 50%;
            width: 16px !important;
            height: 16px !important;
            border: 2px solid white;
            box-shadow: 0 0 0 2px #007bff;
        }
    </style>
</head>
<body>

    <div id="map"></div>
    <div id="controls">
        <div id="statusDisplay" style="display: none;">
            <div id="timeDeviation">00:00</div>
            <div id="speedDisplay">Velocidad: 0 KM/H</div>
            <div id="nextStopDisplay">Próxima Parada: N/A</div>
        </div>

        <div class="control-section" id="routeCreationSection">
            <h3>Crear/Modificar Ruta</h3>
            <p style="font-size: 0.8em;">Toca el mapa para agregar paradas. Toca una parada existente para editarla.</p>
            <label for="pointName">Nombre Parada:</label>
            <input type="text" id="pointName" placeholder="Ej: Estación Central">
            
            <label for="pointTime">Horario Programado (DD/MM/AAAA HH:MM):</label>
            <input type="datetime-local" id="pointTime">

            <div id="editPointControls" style="display:none; margin-top:10px;">
                <button onclick="updateSelectedPoint()" class="secondary">Actualizar Parada</button>
                <button onclick="deleteSelectedPoint()" class="danger">Borrar Parada Seleccionada</button>
                <button onclick="cancelEdit()">Cancelar Edición</button>
            </div>
            <hr style="margin: 15px 0;">
            <input type="checkbox" id="autoCalcTimes" checked>
            <label for="autoCalcTimes" style="display:inline;">Calcular horarios intermedios automáticamente</label>
            <br><br>
            <button onclick="clearCurrentRoute()">Limpiar Ruta Actual</button>
        </div>

        <div class="control-section">
            <h3>Lista de Paradas</h3>
            <div id="stopsList">No hay paradas.</div>
        </div>
        
        <div class="control-section">
            <h3>Guardar/Cargar Rutas</h3>
            <label for="routeName">Nombre para Guardar Ruta:</label>
            <input type="text" id="routeName" placeholder="Ej: Ruta Mañana Lunes">
            <button onclick="saveRoute()">Guardar Ruta</button>
            <br><br>
            <label for="savedRoutes">Cargar Ruta:</label>
            <select id="savedRoutes"></select>
            <button onclick="loadRoute()">Cargar</button>
            <button onclick="deleteRoute()" class="danger">Borrar Seleccionada</button>
        </div>

        <div class="control-section">
            <h3>Seguimiento</h3>
            <button id="startTrackingBtn" onclick="startTracking()">Iniciar Seguimiento</button>
            <button id="stopTrackingBtn" onclick="stopTracking()" class="danger" style="display:none;">Detener Seguimiento</button>
            <br>
            <input type="checkbox" id="manualStopNav">
            <label for="manualStopNav" style="display:inline;">Navegación Manual de Paradas</label>
            <button id="prevStopBtn" onclick="goToPreviousStop()" style="display:none;">Anterior</button>
            <button id="nextStopBtn" onclick="goToNextStop()" style="display:none;">Siguiente</button>
        </div>
        
        <div class="control-section">
            <h3>Cola de Rutas</h3>
            <label for="routeToQueue">Añadir ruta guardada a la cola:</label>
            <select id="routeToQueue"></select>
            <button onclick="addRouteToQueue()">Añadir a Cola</button>
            <h4>En Cola:</h4>
            <div id="routeQueueDisplay">Vacía.</div>
            <button onclick="clearRouteQueue()">Limpiar Cola</button>
        </div>

    </div>

    <script>
        let map;
        let routePoints = []; // {lat, lng, name, type, scheduledTime, marker, originalIndex}
        let routeLine;
        let userMarker;
        let trackingIntervalId;
        let isTracking = false;
        let currentSegmentStartIndex = 0; // Index in routePoints for the start of the current segment
        let lastKnownPosition = null;
        let currentlyEditingPoint = null; // Para rastrear el punto seleccionado para edición

        const CACHE_PREFIX = 'smartMovePro_route_';
        const ROUTE_QUEUE_CACHE_KEY = 'smartMovePro_routeQueue';

        // --- Leaflet Icon Helpers ---
        function createDivIcon(text, bgColor = null, type = '') {
            let iconColor = bgColor;
            if (!iconColor) {
                if (type === 'start') iconColor = '#4CAF50'; // Green for Start
                else if (type === 'end') iconColor = '#f44336';   // Red for End
                else if (type === 'intermediate') iconColor = '#2196F3'; // Blue for Intermediate
                else iconColor = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`; // Default random
            }

            return L.divIcon({
                className: 'leaflet-div-icon',
                html: `<div style="background-color:${iconColor}; padding: 5px 8px; border-radius: 50%; color: white; font-size:14px; font-weight:bold; border: 1px solid white;">${text}</div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });
        }

        function createUserLocationIcon() {
            return L.divIcon({
                className: 'user-location-icon',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        // --- Map Initialization ---
        function initMap() {
            map = L.map('map').setView([-34.6037, -58.3816], 13); // Default to Buenos Aires
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            map.on('click', onMapClick);

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    map.setView([position.coords.latitude, position.coords.longitude], 13);
                }, () => {
                    console.warn("Error getting current location. Using default.");
                });
            }
        }
        
        // --- Funciones de Edición ---
        function formatDateTimeForInput(date) {
            if (!date || isNaN(new Date(date).getTime())) return "";
            const d = new Date(date);
            d.setMinutes(d.getMinutes() - d.getTimezoneOffset());
            return d.toISOString().slice(0, 16);
        }

        function activateEditModeForPoint(point) {
            if (isTracking) {
                alert("Detén el seguimiento para editar la ruta.");
                return;
            }
            currentlyEditingPoint = point;
            document.getElementById('pointName').value = point.name;
            document.getElementById('pointTime').value = point.scheduledTime ? formatDateTimeForInput(point.scheduledTime) : "";
            document.getElementById('editPointControls').style.display = 'block';
            document.getElementById('pointName').focus();
        }

        function cancelEdit() {
            currentlyEditingPoint = null;
            document.getElementById('pointName').value = "";
            document.getElementById('pointTime').value = "";
            document.getElementById('editPointControls').style.display = 'none';
        }

        function updateSelectedPoint() {
            if (!currentlyEditingPoint) return;

            const newName = document.getElementById('pointName').value;
            const newTimeValue = document.getElementById('pointTime').value;
            
            if (!newName) {
                alert("El nombre de la parada no puede estar vacío.");
                return;
            }

            let newScheduledTime = null;
            if (newTimeValue) {
                newScheduledTime = new Date(newTimeValue);
                if (isNaN(newScheduledTime.getTime())) {
                    alert("Formato de fecha/hora inválido.");
                    return;
                }
            }

            if ((currentlyEditingPoint.type === 'start' || currentlyEditingPoint.type === 'end') && !newScheduledTime) {
                alert(`El horario es obligatorio para el punto de ${currentlyEditingPoint.type === 'start' ? 'Inicio' : 'Fin'}.`);
                return;
            }

            currentlyEditingPoint.name = newName;
            currentlyEditingPoint.scheduledTime = newScheduledTime;

            if (document.getElementById('autoCalcTimes').checked) {
                calculateAndApplyIntermediateTimes();
            }
            redrawRouteLine();
            updateStopsList();
            alert(`Parada "${newName}" actualizada.`);
            cancelEdit();
        }

        function deleteSelectedPoint() {
            if (!currentlyEditingPoint) return;

            const isStartPoint = currentlyEditingPoint.type === 'start';
            const isEndPoint = currentlyEditingPoint.type === 'end';
            const startPointsCount = routePoints.filter(p => p.type === 'start').length;
            const endPointsCount = routePoints.filter(p => p.type === 'end').length;

            // Prevent deleting the sole start/end point if other points exist
            if ( (isStartPoint && startPointsCount <= 1 && routePoints.length > 1) ||
                 (isEndPoint && endPointsCount <= 1 && routePoints.length > 1) ) {
                // Allow deletion if it's one of the last two points, or the only point.
                if (routePoints.length > 2 || (routePoints.length === 2 && !(isStartPoint || isEndPoint) ) ) {
                     alert("No puedes borrar el único punto de Inicio o Fin si hay otras paradas. Define un nuevo Inicio/Fin primero o borra las intermedias.");
                     return;
                }
            }

            if (confirm(`¿Seguro que quieres borrar la parada "${currentlyEditingPoint.name}"?`)) {
                map.removeLayer(currentlyEditingPoint.marker);
                const index = routePoints.indexOf(currentlyEditingPoint);
                if (index > -1) {
                    routePoints.splice(index, 1);
                }

                renumberIntermediateMarkers();

                if (document.getElementById('autoCalcTimes').checked) {
                    calculateAndApplyIntermediateTimes();
                }
                redrawRouteLine();
                updateStopsList();
                alert(`Parada "${currentlyEditingPoint.name}" borrada.`);
            }
            cancelEdit();
        }

        function renumberIntermediateMarkers() {
            let intermediateCounter = 1;
            routePoints.forEach(p => {
                if (p.type === 'intermediate') {
                    p.marker.setIcon(createDivIcon(intermediateCounter++, null, 'intermediate'));
                }
            });
        }

        // --- Route Creation Logic ---
        function onMapClick(e) {
            if (isTracking) {
                alert("Detén el seguimiento para modificar la ruta.");
                return;
            }
            
            let targetIsMarkerIcon = false;
            if (e.originalEvent && e.originalEvent.target) {
                 try {
                    if (e.originalEvent.target.closest('.leaflet-marker-icon')) {
                        targetIsMarkerIcon = true;
                    }
                 } catch(err) {/*ignore errors from closest if not applicable*/}
            }

            if (currentlyEditingPoint && !targetIsMarkerIcon) { 
                cancelEdit();
                // Do not return, allow adding a new point if the click was on the map itself.
            }
            
            if (targetIsMarkerIcon) { // Click was on a marker, handled by marker's click event.
                return;
            }


            const nameInput = document.getElementById('pointName');
            const timeInput = document.getElementById('pointTime');
            const latlng = e.latlng;

            let type;
            let requiredTime = true;
            let pointText;
            let pointNameValue = nameInput.value.trim();


            if (routePoints.length === 0) { // First point is always Start
                type = 'start';
                pointText = 'I';
                if (!pointNameValue) nameInput.value = "Inicio"; // Suggest default name
            } else {
                const hasStart = routePoints.some(p => p.type === 'start');
                const hasEnd = routePoints.some(p => p.type === 'end');

                if (!hasStart) { // Should not happen if first point is always start, but as a fallback
                    type = 'start';
                    pointText = 'I';
                     if (!pointNameValue) nameInput.value = "Inicio";
                } else if (!hasEnd) { // If start exists but no end, this new point becomes the End
                    type = 'end';
                    pointText = 'F';
                    if (!pointNameValue) nameInput.value = "Final";
                } else { // Both Start and End exist, so this is an Intermediate point
                    type = 'intermediate';
                    const intermediateCount = routePoints.filter(p => p.type === 'intermediate').length;
                    pointText = intermediateCount + 1;
                    if (!pointNameValue) nameInput.value = `Parada ${pointText}`;
                    requiredTime = false; 
                }
            }
             pointNameValue = nameInput.value.trim() || (type === 'start' ? "Inicio" : type === 'end' ? "Final" : `Parada ${pointText}`);


            if (requiredTime && !timeInput.value) {
                alert(`El horario es obligatorio para el punto de ${type === 'start' ? 'Inicio' : 'Fin'}.`);
                return;
            }

            const scheduledTime = timeInput.value ? new Date(timeInput.value) : null;
            if (requiredTime && scheduledTime && isNaN(scheduledTime.getTime())) {
                alert("Formato de fecha/hora inválido.");
                return;
            }
            
            let insertionIndex = routePoints.length;
            if (type === 'intermediate') {
                const endIdx = routePoints.findIndex(p => p.type === 'end');
                if (endIdx !== -1) insertionIndex = endIdx; // Insert intermediate before the end point
            }


            const newPoint = {
                lat: latlng.lat,
                lng: latlng.lng,
                name: pointNameValue,
                type: type,
                scheduledTime: scheduledTime,
                marker: L.marker(latlng, { 
                    icon: createDivIcon(pointText, null, type), 
                    draggable: true 
                }).addTo(map),
                originalIndex: routePoints.length 
            };

            newPoint.marker.on('dragend', function(event) {
                if (isTracking) {
                    event.target.setLatLng(L.latLng(newPoint.lat, newPoint.lng));
                    alert("Detén el seguimiento para modificar la ruta.");
                    return;
                }
                const marker = event.target;
                const position = marker.getLatLng();
                const point = routePoints.find(p => p.marker === marker);
                if (point) {
                    point.lat = position.lat;
                    point.lng = position.lng;
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) {
                        calculateAndApplyIntermediateTimes();
                    }
                    updateStopsList();
                }
            });
            
            newPoint.marker.on('click', function() {
                if (isTracking) return;
                activateEditModeForPoint(newPoint);
            });
            
            if (type === 'intermediate') {
                routePoints.splice(insertionIndex, 0, newPoint);
                renumberIntermediateMarkers(); // Renumber after insertion
            } else {
                 routePoints.push(newPoint);
            }

            nameInput.value = "";
            // timeInput.value = ""; // Keep for potential sequential times

            if (document.getElementById('autoCalcTimes').checked) {
                calculateAndApplyIntermediateTimes();
            }
            redrawRouteLine();
            updateStopsList();
        }

        function calculateAndApplyIntermediateTimes() {
            const startPoint = routePoints.find(p => p.type === 'start');
            const endPoint = routePoints.find(p => p.type === 'end');

            if (!startPoint || !endPoint || !startPoint.scheduledTime || !endPoint.scheduledTime) {
                return;
            }

            const intermediatePoints = routePoints.filter(p => p.type === 'intermediate')
                                            .sort((a,b) => a.originalIndex - b.originalIndex); // Ensure correct order for calculation
            if (intermediatePoints.length === 0) return;

            const totalDurationMillis = endPoint.scheduledTime.getTime() - startPoint.scheduledTime.getTime();
            if (totalDurationMillis <= 0) {
                console.warn("Duración total no positiva.");
                return;
            }
            
            let pathForCalc = [startPoint, ...intermediatePoints, endPoint];
            let totalRouteDistance = 0;
            for (let i = 0; i < pathForCalc.length - 1; i++) {
                totalRouteDistance += L.latLng(pathForCalc[i].lat, pathForCalc[i].lng)
                                    .distanceTo(L.latLng(pathForCalc[i+1].lat, pathForCalc[i+1].lng));
            }

            if (totalRouteDistance === 0) return;

            let accumulatedDistance = 0;
            // Calculate times for intermediate points based on their position in the sorted list
            for (let i = 0; i < intermediatePoints.length; i++) {
                const point = intermediatePoints[i];
                const prevPoint = (i === 0) ? startPoint : intermediatePoints[i-1];
                
                let segmentDistance = L.latLng(prevPoint.lat, prevPoint.lng)
                                    .distanceTo(L.latLng(point.lat, point.lng));
                
                accumulatedDistance += segmentDistance;
                // Proportion based on distance from start to current intermediate point, along the path.
                let distFromStartToCurrentInter = 0;
                let tempPath = [startPoint];
                for(let j=0; j<=i; j++) tempPath.push(intermediatePoints[j]);

                for(let k=0; k < tempPath.length -1; k++){
                    distFromStartToCurrentInter += L.latLng(tempPath[k].lat, tempPath[k].lng)
                                                .distanceTo(L.latLng(tempPath[k+1].lat, tempPath[k+1].lng));
                }
                
                const proportionOfRoute = distFromStartToCurrentInter / totalRouteDistance;
                const timeOffsetMillis = totalDurationMillis * proportionOfRoute;
                
                point.scheduledTime = new Date(startPoint.scheduledTime.getTime() + timeOffsetMillis);
            }
            updateStopsList();
        }
        
        function clearCurrentRoute() {
            cancelEdit(); 
            routePoints.forEach(p => map.removeLayer(p.marker));
            routePoints = [];
            if (routeLine) map.removeLayer(routeLine);
            routeLine = null;
            document.getElementById('pointName').value = "";
            document.getElementById('pointTime').value = "";
            updateStopsList();
            console.log("Ruta actual limpiada.");
        }

        function redrawRouteLine() {
            if (routeLine) {
                map.removeLayer(routeLine);
            }
            
            const displayPoints = getSortedRoutePointsForDisplay(); // Use helper for consistent order
            if (displayPoints.length > 1) {
                const latlngs = displayPoints.map(p => [p.lat, p.lng]);
                routeLine = L.polyline(latlngs, {color: 'blue'}).addTo(map);
            }
        }
        
        function getSortedRoutePointsForDisplay() {
            // Helper to get points in Start -> Intermediates (sorted by originalIndex) -> End order
            const sortedPoints = [];
            const start = routePoints.find(p => p.type === 'start');
            const end = routePoints.find(p => p.type === 'end');
            const intermediates = routePoints.filter(p => p.type === 'intermediate')
                                    .sort((a,b) => {
                                        // Try to sort by scheduled time if autoCalc is off and times are manual
                                        if (!document.getElementById('autoCalcTimes').checked && a.scheduledTime && b.scheduledTime) {
                                            return new Date(a.scheduledTime).getTime() - new Date(b.scheduledTime).getTime();
                                        }
                                        return a.originalIndex - b.originalIndex; // Fallback to insertion order
                                    });

            if (start) sortedPoints.push(start);
            sortedPoints.push(...intermediates);
            if (end) sortedPoints.push(end);
            return sortedPoints;
        }


        function formatTime(date) {
            if (!date || isNaN(new Date(date).getTime())) return "N/A";
            const d = new Date(date); // Ensure it's a Date object
            return d.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }) + 
                   ` (${d.toLocaleDateString('es-ES')})`;
        }
        
        function updateStopsList() {
            const listDiv = document.getElementById('stopsList');
            const displayPoints = getSortedRoutePointsForDisplay();

            if (displayPoints.length === 0) {
                listDiv.innerHTML = "No hay paradas.";
                return;
            }

            let html = "<ul>";
            let intermediateVisualCounter = 1;
            displayPoints.forEach((p, index) => {
                let typeText = "";
                switch(p.type) {
                    case 'start': typeText = "Inicio"; break;
                    case 'intermediate': 
                        typeText = `Intermedia ${intermediateVisualCounter++}`; 
                        break;
                    case 'end': typeText = "Fin"; break;
                }
                const timeStr = p.scheduledTime ? formatTime(p.scheduledTime) : "Sin horario"; // Pass Date object
                
                let itemClass = "stop-item";
                // Highlight logic for next stop during tracking
                if (isTracking && currentSegmentStartIndex < routePoints.length -1) {
                     // The actual routePoints array (used for tracking) might be sorted differently than displayPoints
                     // We need to find the actual next stop in routePoints (tracking order)
                    const actualTrackingRoutePoints = getSortedRoutePointsForTracking();
                    if (currentSegmentStartIndex + 1 < actualTrackingRoutePoints.length) {
                        const nextTrackingStop = actualTrackingRoutePoints[currentSegmentStartIndex + 1];
                        if (p === nextTrackingStop) { // Compare object references
                            itemClass += " next-stop-highlight";
                        }
                    }
                }


                html += `<li class="${itemClass}"><b>${p.name}</b> (${typeText}) - ${timeStr}</li>`;
            });
            html += "</ul>";
            listDiv.innerHTML = html;
        }

        // --- Persistence (localStorage) ---
        function saveRoute() {
            const routeNameInput = document.getElementById('routeName');
            if (!routeNameInput.value) {
                alert("Por favor, ingresa un nombre para la ruta.");
                return;
            }
            if (!routePoints.some(p=>p.type==='start') || !routePoints.some(p=>p.type==='end')) {
                 alert("Una ruta debe tener al menos un punto de inicio y fin definidos.");
                 return;
            }
            if (routePoints.length < 2) { // General check, though covered by above
                alert("Una ruta debe tener al menos dos puntos.");
                return;
            }

            const savablePoints = routePoints.map(p => ({
                lat: p.lat, lng: p.lng, name: p.name, type: p.type, 
                scheduledTime: p.scheduledTime ? new Date(p.scheduledTime).toISOString() : null,
                originalIndex: p.originalIndex
            }));

            localStorage.setItem(CACHE_PREFIX + routeNameInput.value, JSON.stringify(savablePoints));
            alert(`Ruta "${routeNameInput.value}" guardada.`);
            loadSavedRoutesLists();
            // routeNameInput.value = ""; // Don't clear if user wants to re-save with same name
        }

        function loadRoute() {
            cancelEdit();
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) {
                alert("Selecciona una ruta para cargar.");
                return;
            }
            const savedData = localStorage.getItem(CACHE_PREFIX + selectedRouteName);
            if (!savedData) {
                alert("Error al cargar la ruta.");
                return;
            }

            clearCurrentRoute(); 
            const loadedPointsData = JSON.parse(savedData);
            
            loadedPointsData.forEach((p_data) => {
                let pointText;
                if (p_data.type === 'start') pointText = 'I';
                else if (p_data.type === 'end') pointText = 'F';
                else { // For intermediates, we need to count existing ones to set text correctly
                    pointText = routePoints.filter(rp => rp.type === 'intermediate').length + 1;
                }

                const newPoint = {
                    ...p_data,
                    scheduledTime: p_data.scheduledTime ? new Date(p_data.scheduledTime) : null,
                    marker: L.marker([p_data.lat, p_data.lng], { 
                        icon: createDivIcon(pointText, null, p_data.type),
                        draggable: true 
                    }).addTo(map)
                };
                
                newPoint.marker.on('dragend', function(event){
                    if (isTracking) {
                        event.target.setLatLng(L.latLng(newPoint.lat, newPoint.lng));
                        return;
                    }
                    const marker = event.target;
                    const position = marker.getLatLng();
                    const point = routePoints.find(p => p.marker === marker);
                    if (point) {
                        point.lat = position.lat;
                        point.lng = position.lng;
                        redrawRouteLine();
                         if (document.getElementById('autoCalcTimes').checked) {
                            calculateAndApplyIntermediateTimes();
                        }
                        updateStopsList();
                    }
                });

                newPoint.marker.on('click', function() {
                    if (isTracking) return;
                    activateEditModeForPoint(newPoint);
                });
                routePoints.push(newPoint);
            });
            
            renumberIntermediateMarkers(); // Ensure correct numbering after loading all
            redrawRouteLine();
            updateStopsList();
            if (routeLine && routeLine.getBounds().isValid()) { // Check if bounds are valid
                 map.fitBounds(routeLine.getBounds());
            } else if (routePoints.length > 0) {
                map.setView([routePoints[0].lat, routePoints[0].lng], 13);
            }
            document.getElementById('routeName').value = selectedRouteName;
            alert(`Ruta "${selectedRouteName}" cargada.`);
        }

        function deleteRoute() {
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) {
                alert("Selecciona una ruta para borrar.");
                return;
            }
            if (confirm(`¿Estás seguro de que quieres borrar la ruta "${selectedRouteName}"?`)) {
                localStorage.removeItem(CACHE_PREFIX + selectedRouteName);
                let queue = getRouteQueue();
                queue = queue.filter(name => name !== selectedRouteName);
                saveRouteQueue(queue);
                loadSavedRoutesLists();
                alert(`Ruta "${selectedRouteName}" borrada.`);
            }
        }

        function loadSavedRoutesLists() { 
            const savedRoutesSelect = document.getElementById('savedRoutes');
            const routeToQueueSelect = document.getElementById('routeToQueue');
            const currentSavedRoute = savedRoutesSelect.value; // Preserve selection if possible
            const currentQueueRoute = routeToQueueSelect.value;

            savedRoutesSelect.innerHTML = ""; 
            routeToQueueSelect.innerHTML = "";

            let hasRoutes = false;
            const routeNames = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(CACHE_PREFIX)) {
                    routeNames.push(key.substring(CACHE_PREFIX.length));
                }
            }
            routeNames.sort(); // Sort names alphabetically

            routeNames.forEach(routeName => {
                const option = document.createElement('option');
                option.value = routeName;
                option.textContent = routeName;
                savedRoutesSelect.appendChild(option.cloneNode(true));
                routeToQueueSelect.appendChild(option.cloneNode(true)); // Use cloneNode here too
                hasRoutes = true;
            });
            
            if (!hasRoutes) {
                 const option = document.createElement('option');
                 option.textContent = "No hay rutas guardadas";
                 option.disabled = true;
                 savedRoutesSelect.appendChild(option.cloneNode(true));
                 routeToQueueSelect.appendChild(option);
            } else {
                // Try to re-select previous if still exists
                if (routeNames.includes(currentSavedRoute)) savedRoutesSelect.value = currentSavedRoute;
                if (routeNames.includes(currentQueueRoute)) routeToQueueSelect.value = currentQueueRoute;
            }
            updateRouteQueueDisplay();
        }
        
        function getSortedRoutePointsForTracking() {
            const startPt = routePoints.find(p => p.type === 'start');
            const endPt = routePoints.find(p => p.type === 'end');
            // For tracking, intermediates should be sorted by scheduled time if available, else by original index
            const intermediatePts = routePoints.filter(p => p.type === 'intermediate')
                                        .sort((a, b) => {
                                            if (a.scheduledTime && b.scheduledTime) {
                                                return new Date(a.scheduledTime).getTime() - new Date(b.scheduledTime).getTime();
                                            }
                                            return a.originalIndex - b.originalIndex;
                                        });
            
            let trackingOrder = [];
            if (startPt) trackingOrder.push(startPt);
            trackingOrder.push(...intermediatePts);
            if (endPt) trackingOrder.push(endPt);
            return trackingOrder.filter(p => p); // Filter out undefined if start/end missing
        }


        // --- Real-Time Tracking ---
        function startTracking() {
            const trackingPoints = getSortedRoutePointsForTracking();
            if (trackingPoints.length < 2) {
                alert("Crea o carga una ruta con al menos inicio y fin para comenzar el seguimiento.");
                return;
            }
            const startPoint = trackingPoints[0];
            const endPoint = trackingPoints[trackingPoints.length - 1];

            if (startPoint.type !== 'start' || endPoint.type !== 'end' || !startPoint.scheduledTime || !endPoint.scheduledTime) {
                 alert("La ruta debe tener un Inicio y Fin con horarios definidos para el seguimiento.");
                 return;
            }


            isTracking = true;
            currentSegmentStartIndex = 0; 
            // Update routePoints to be the tracking order for consistency during tracking
            routePoints = trackingPoints; 

            document.getElementById('startTrackingBtn').style.display = 'none';
            document.getElementById('stopTrackingBtn').style.display = 'inline-block';
            document.getElementById('statusDisplay').style.display = 'block';
            document.getElementById('routeCreationSection').style.display = 'none'; 

            if (navigator.geolocation) {
                trackingIntervalId = navigator.geolocation.watchPosition(
                    handlePositionUpdate,
                    handleGeolocationError,
                    { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 }
                );
                if (routePoints.length > 0 && routePoints[0].lat && routePoints[0].lng) {
                    map.setView([routePoints[0].lat, routePoints[0].lng], 16); 
                }
                highlightNextStopInList();
            } else {
                alert("La geolocalización no está disponible en tu navegador.");
                stopTracking(); 
            }
             updateManualNavButtons();
        }

        function stopTracking(completedNaturally = false) {
            if (trackingIntervalId) {
                navigator.geolocation.clearWatch(trackingIntervalId);
                trackingIntervalId = null;
            }
            isTracking = false;
            lastKnownPosition = null;
            document.getElementById('startTrackingBtn').style.display = 'inline-block';
            document.getElementById('stopTrackingBtn').style.display = 'none';
            document.getElementById('statusDisplay').style.display = 'none';
            document.getElementById('routeCreationSection').style.display = 'block'; 
            
            if (userMarker) {
                map.removeLayer(userMarker);
                userMarker = null;
            }
            document.getElementById('timeDeviation').textContent = "00:00";
            document.getElementById('timeDeviation').style.color = "#FFFFFF";
            document.getElementById('speedDisplay').textContent = "Velocidad: 0 KM/H";
            
            currentSegmentStartIndex = 0; 
            // After stopping, reload the route from storage or revert to a non-tracking sorted state for `routePoints`
            // For simplicity now, we'll just update the list. A full revert might involve reloading.
            // Or, ensure `routePoints` used for display/editing is always the "originalIndex" sorted one.
            // Best: loadRoute() again if a routeName is active, or clearCurrentRoute() if not.
            // For now:
            if (document.getElementById('routeName').value) {
                 loadRoute(); // Reloads the route to restore original order if it was changed for tracking
            } else {
                 updateStopsList(); // If it was a new route not yet saved
            }
            highlightNextStopInList(); 
            updateManualNavButtons();


            if (completedNaturally) {
                alert("Ruta completada!");
                checkRouteQueue();
            } else {
                console.log("Seguimiento detenido manualmente.");
            }
        }
        
        function updateManualNavButtons() {
            const manualNav = document.getElementById('manualStopNav').checked;
            const prevBtn = document.getElementById('prevStopBtn');
            const nextBtn = document.getElementById('nextStopBtn');

            if (isTracking && manualNav) {
                prevBtn.style.display = 'inline-block';
                nextBtn.style.display = 'inline-block';
                prevBtn.disabled = currentSegmentStartIndex === 0;
                nextBtn.disabled = currentSegmentStartIndex >= routePoints.length - 2;
            } else {
                prevBtn.style.display = 'none';
                nextBtn.style.display = 'none';
            }
        }

        document.getElementById('manualStopNav').addEventListener('change', updateManualNavButtons);


        function handlePositionUpdate(position) {
            lastKnownPosition = position;
            const { latitude, longitude, speed } = position.coords;
            const userLatLng = L.latLng(latitude, longitude);

            if (!userMarker) {
                userMarker = L.marker(userLatLng, { icon: createUserLocationIcon() }).addTo(map);
            } else {
                userMarker.setLatLng(userLatLng);
            }
            // map.panTo(userLatLng); // Can be annoying if user is also panning map

            const speedKmh = speed ? (speed * 3.6).toFixed(1) : 0;
            document.getElementById('speedDisplay').textContent = `Velocidad: ${speedKmh} KM/H`;

            if (currentSegmentStartIndex < routePoints.length - 1) {
                const nextStop = routePoints[currentSegmentStartIndex + 1]; // routePoints is now tracking order
                const distanceToNextStop = userLatLng.distanceTo(L.latLng(nextStop.lat, nextStop.lng));
                
                const manualNav = document.getElementById('manualStopNav').checked;

                if (!manualNav) {
                    const detectionRadius = 50; 
                    if (distanceToNextStop < detectionRadius) {
                        advanceToNextStop();
                    } else {
                        if (currentSegmentStartIndex < routePoints.length - 2) {
                            const stopAfterNext = routePoints[currentSegmentStartIndex + 2];
                            const distanceToStopAfterNext = userLatLng.distanceTo(L.latLng(stopAfterNext.lat, stopAfterNext.lng));
                            if (distanceToStopAfterNext < distanceToNextStop && distanceToStopAfterNext < detectionRadius * 2.5) { // Increased multiplier for skip
                                console.log(`Saltando ${nextStop.name}, más cerca de ${stopAfterNext.name}`);
                                advanceToNextStop(); 
                            }
                        }
                    }
                }
                calculateTimeDeviation(position);
            } else { 
                document.getElementById('nextStopDisplay').textContent = "Ruta Completada";
                document.getElementById('timeDeviation').textContent = "00:00"; 
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                if(isTracking) stopTracking(true); // Stop if accidentally past the last point logic
            }
        }

        function advanceToNextStop() {
            currentSegmentStartIndex++;
            if (currentSegmentStartIndex >= routePoints.length - 1) {
                stopTracking(true); 
            } else {
                highlightNextStopInList();
                updateManualNavButtons();
                if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition); // Pass full position object
            }
        }
        
        function goToPreviousStop() {
            if (currentSegmentStartIndex > 0) {
                currentSegmentStartIndex--;
                highlightNextStopInList();
                updateManualNavButtons();
                if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition); // Pass full position object
            }
        }
        function goToNextStop() { 
             if (currentSegmentStartIndex < routePoints.length - 2) { 
                advanceToNextStop(); 
            } else if (currentSegmentStartIndex === routePoints.length - 2) { 
                advanceToNextStop(); 
            }
        }


        function highlightNextStopInList() {
            const listItems = document.querySelectorAll('#stopsList .stop-item');
            listItems.forEach(item => item.classList.remove('next-stop-highlight'));
            const displayPoints = getSortedRoutePointsForDisplay(); // Points for the visual list

            if (isTracking && routePoints.length > 0 && currentSegmentStartIndex < routePoints.length - 1) {
                const nextActualStop = routePoints[currentSegmentStartIndex + 1]; // From tracking-ordered routePoints
                document.getElementById('nextStopDisplay').textContent = `Próxima: ${nextActualStop.name}`;
                
                // Find this nextActualStop in the displayPoints list to highlight the correct <li>
                const displayIndex = displayPoints.findIndex(dp => dp === nextActualStop); // Compare object reference
                if (displayIndex !== -1 && listItems[displayIndex]) {
                    listItems[displayIndex].classList.add('next-stop-highlight');
                }
            } else if (!isTracking && displayPoints.length > 0) {
                 document.getElementById('nextStopDisplay').textContent = `Próxima: ${displayPoints[0].name}`;
                 if(listItems[0]) listItems[0].classList.add('next-stop-highlight');
            } else {
                document.getElementById('nextStopDisplay').textContent = "Próxima Parada: N/A";
            }
            // updateStopsList(); // Already called by many functions that change state, be careful of infinite loops
        }


        function calculateTimeDeviation(currentUserGeoPosition) { 
            if (!isTracking || currentSegmentStartIndex >= routePoints.length - 1) return; 

            const pointA = routePoints[currentSegmentStartIndex]; // routePoints is tracking order
            const pointB = routePoints[currentSegmentStartIndex + 1];

            if (!pointA || !pointB || !pointA.scheduledTime || !pointB.scheduledTime) {
                document.getElementById('timeDeviation').textContent = "N/A";
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                return;
            }

            const scheduledTimeA = new Date(pointA.scheduledTime);
            const scheduledTimeB = new Date(pointB.scheduledTime);
            const segmentTotalScheduledMillis = scheduledTimeB.getTime() - scheduledTimeA.getTime();

            if (segmentTotalScheduledMillis <= 0) {
                 document.getElementById('timeDeviation').textContent = "ERR_DUR"; 
                 document.getElementById('timeDeviation').style.color = "#FFA500"; 
                return;
            }

            const latLngA = L.latLng(pointA.lat, pointA.lng);
            const latLngB = L.latLng(pointB.lat, pointB.lng);
            const currentUserLatLng = L.latLng(currentUserGeoPosition.coords.latitude, currentUserGeoPosition.coords.longitude);

            const distanceTotalSegment = latLngA.distanceTo(latLngB); 
            
            if (distanceTotalSegment < 1) { 
                const now = new Date();
                let deviationMillis;
                if (now.getTime() < scheduledTimeA.getTime()) { 
                    deviationMillis = scheduledTimeA.getTime() - now.getTime(); 
                } else if (now.getTime() > scheduledTimeB.getTime()) { 
                     deviationMillis = scheduledTimeB.getTime() - now.getTime(); 
                } else { 
                    deviationMillis = scheduledTimeA.getTime() - now.getTime(); 
                }
                displayDeviation(deviationMillis);
                return;
            }
            
            const distToA = currentUserLatLng.distanceTo(latLngA);
            const distToB = currentUserLatLng.distanceTo(latLngB);
            let progressPercentage;

            // Prioritize checking if user is at/near B or A
            if (distToB < 10) { // Very close to B
                progressPercentage = 1.0;
            } else if (distToA < 10) { // Very close to A
                progressPercentage = 0.0;
            }
            // Check if current position is (roughly) "beyond" B relative to A
            else if (distToA > distanceTotalSegment && distToB < distToA && (distToA > distToB + distanceTotalSegment - 20) ) { 
                 progressPercentage = 1.0;
            }
            // Check if current position is (roughly) "before" A relative to B
            else if (distToB > distanceTotalSegment && distToA < distToB && (distToB > distToA + distanceTotalSegment - 20) ) {
                 progressPercentage = 0.0;
            }
            else {
                const sumDistances = distToA + distToB;
                // If fairly collinear or short segment or user is between A and B on the line.
                if (Math.abs(sumDistances - distanceTotalSegment) < Math.max(20, distanceTotalSegment * 0.25) ) { 
                    progressPercentage = distToA / distanceTotalSegment;
                } else {
                    // User is significantly off the direct line segment.
                    // Project point onto the line segment A-B
                    // Simplified: if (dot_product(AP, AB) / dot_product(AB, AB)) where P is current position
                    // For LatLng, this is complex. A robust way is to use distToA / (distToA + distToB) as approximation of progress along A-P-B path
                    // This can be problematic if P is far off.
                    // Fallback to distance from A, clamped.
                    progressPercentage = distToA / distanceTotalSegment; // This will be >1 or <0 if far off, clamped next.
                }
            }

            progressPercentage = Math.max(0, Math.min(1, progressPercentage));

            const expectedTimeElapsedMillis = segmentTotalScheduledMillis * progressPercentage;
            const expectedTimeAtCurrentPosition = new Date(scheduledTimeA.getTime() + expectedTimeElapsedMillis);
            const currentTime = new Date();
            const deviationMillis = expectedTimeAtCurrentPosition.getTime() - currentTime.getTime(); 
            displayDeviation(deviationMillis);
        }

        function displayDeviation(deviationMillis) {
            const absMillis = Math.abs(deviationMillis);
            const totalSecondsValue = Math.floor(absMillis / 1000);
            const displaySeconds = totalSecondsValue % 60; 
            const totalMinutesValue = Math.floor(totalSecondsValue / 60); 
            const sign = deviationMillis >= 0 ? "+" : "-";
            const formattedDeviation = `${sign}${totalMinutesValue}:${String(displaySeconds).padStart(2, '0')}`;
            const deviationDiv = document.getElementById('timeDeviation');
            deviationDiv.textContent = formattedDeviation;

            if (deviationMillis === 0) {
                 deviationDiv.style.color = "#FFFFFF"; 
            } else if (deviationMillis > 0) { 
                deviationDiv.style.color = "#00FF00"; 
            } else { 
                deviationDiv.style.color = "#FF0000"; 
            }
        }

        function handleGeolocationError(error) {
            console.error("Error de geolocalización: ", error);
            alert(`Error de geolocalización: ${error.message}. El seguimiento puede no funcionar.`);
        }

        // --- Route Queue Logic ---
        function getRouteQueue() {
            const storedQueue = localStorage.getItem(ROUTE_QUEUE_CACHE_KEY);
            return storedQueue ? JSON.parse(storedQueue) : [];
        }

        function saveRouteQueue(queue) {
            localStorage.setItem(ROUTE_QUEUE_CACHE_KEY, JSON.stringify(queue));
            updateRouteQueueDisplay();
        }

        function addRouteToQueue() {
            const selectedRouteName = document.getElementById('routeToQueue').value;
            if (!selectedRouteName || selectedRouteName === "No hay rutas guardadas") {
                alert("Selecciona una ruta válida para añadir a la cola.");
                return;
            }
            const queue = getRouteQueue();
            if (queue.includes(selectedRouteName)) {
                alert(`La ruta "${selectedRouteName}" ya está en la cola.`);
                return;
            }
            queue.push(selectedRouteName);
            saveRouteQueue(queue);
            alert(`Ruta "${selectedRouteName}" añadida a la cola.`);
        }

        function updateRouteQueueDisplay() {
            const queueDiv = document.getElementById('routeQueueDisplay');
            const queue = getRouteQueue();
            if (queue.length === 0) {
                queueDiv.innerHTML = "Vacía.";
            } else {
                let html = "<ol>";
                queue.forEach(routeName => {
                    html += `<li>${routeName}</li>`;
                });
                html += "</ol>";
                queueDiv.innerHTML = html;
            }
        }
        
        function clearRouteQueue() {
            if (confirm("¿Limpiar toda la cola de rutas?")) {
                 saveRouteQueue([]);
            }
        }

        function checkRouteQueue() {
            let queue = getRouteQueue();
            if (queue.length > 0) {
                const nextRouteName = queue.shift(); 
                saveRouteQueue(queue); 

                if (confirm(`La ruta actual ha finalizado. ¿Iniciar la siguiente ruta en cola: "${nextRouteName}"?`)) {
                    document.getElementById('savedRoutes').value = nextRouteName; 
                    loadRoute(); 
                    setTimeout(() => {
                        // Check if routePoints is valid before starting tracking
                        if (routePoints.some(p=>p.type==='start') && routePoints.some(p=>p.type==='end') && routePoints.length >=2) {
                            startTracking();
                        } else {
                             alert("Error al cargar la siguiente ruta de la cola o ruta inválida.")
                        }
                    }, 500);
                } else {
                    alert("Siguiente ruta de la cola no iniciada. Puedes iniciarla manualmente.");
                }
            } else {
                console.log("Cola de rutas vacía.");
            }
        }


        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadSavedRoutesLists(); 
            updateStopsList();
            updateManualNavButtons();

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => map.setView([position.coords.latitude, position.coords.longitude], 13),
                    () => console.warn("Could not get initial location.")
                );
            }
        });

    </script>
</body>
</html>
