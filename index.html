<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <style>
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent scrolling of the whole page */
        }

        #map {
            width: 100%;
            height: 50vh; /* 50% of viewport height */
            background-color: #333; /* Placeholder color for map area */
        }

        #controls {
            width: 100%;
            height: 50vh; /* 50% of viewport height */
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
            background-color: #121212;
        }

        .control-section {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
        }

        .control-section h3 {
            margin-top: 0;
            color: #00bcd4; /* Accent color for headings */
        }

        button, input, select {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #333;
            color: #fff;
            font-size: 1em;
            width: calc(100% - 24px); /* Full width minus padding */
            box-sizing: border-box;
        }
        button:hover {
            background-color: #4CAF50;
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }

        label {
            display: block;
            margin-bottom: 3px;
        }

        #stopsList li, #routeQueueList li {
            background-color: #282828;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .status-adelantado {
            color: #4CAF50; /* Green */
            font-weight: bold;
        }

        .status-atrasado {
            color: #F44336; /* Red */
            font-weight: bold;
        }

        .status-atiempo {
            color: #FFFFFF; /* White */
            font-weight: bold;
        }

        .leaflet-div-icon {
            background: transparent;
            border: none;
        }
        .custom-marker-content {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 0 5px rgba(0,0,0,0.7);
        }
        .driver-icon {
            background-color: #007bff !important; /* Blue for driver */
            border: 2px solid white;
        }
        .driver-icon::before {
            content: '➔'; /* Arrow indicating movement/direction, or use a car icon if preferred */
            font-size: 18px;
            transform: rotate(45deg); /* Example rotation */
        }

        #statusPanel {
            padding: 10px;
            background-color: #1e1e1e;
            border-radius: 5px;
        }
        #statusPanel p {
            margin: 5px 0;
        }
    </style>
</head>
<body>

    <div id="map"></div>
    <div id="controls">
        <div class="control-section">
            <h3>Crear/Editar Ruta</h3>
            <label for="routeName">Nombre de la Ruta:</label>
            <input type="text" id="routeName" placeholder="Ej: Recorrido Matutino">
            <button id="addStartPointBtn">1. Añadir Inicio (con horario)</button>
            <button id="addEndPointBtn" disabled>2. Añadir Fin (con horario)</button>
            <button id="addIntermediatePointBtn" disabled>3. Añadir Parada Intermedia</button>
            <br>
            <input type="checkbox" id="autoCalcTimes" checked>
            <label for="autoCalcTimes">Calcular horarios intermedios automáticamente</label>
            <p id="instructionText" style="font-size: 0.9em; color: #cccccc;">Haga clic en el mapa para añadir puntos.</p>
        </div>

        <div class="control-section">
            <h3>Paradas de la Ruta Actual</h3>
            <ul id="stopsList"></ul>
            <button id="clearCurrentRouteBtn">Limpiar Ruta Actual</button>
        </div>

        <div class="control-section">
            <h3>Gestionar Rutas Guardadas</h3>
            <select id="savedRoutesSelect"></select>
            <button id="loadRouteBtn">Cargar Ruta</button>
            <button id="saveRouteBtn">Guardar Ruta Actual</button>
            <button id="deleteRouteBtn">Borrar Ruta Seleccionada</button>
        </div>
        
        <div class="control-section">
            <h3>Seguimiento en Tiempo Real</h3>
            <button id="startTrackingBtn" disabled>Iniciar Seguimiento</button>
            <button id="stopTrackingBtn" disabled>Detener Seguimiento</button>
            <div id="statusPanel" style="display:none;">
                <p>Velocidad: <span id="speedDisplay">-- km/h</span></p>
                <p>Próxima Parada: <span id="nextStopDisplay">--</span></p>
                <p>Desvío Horario: <span id="timeDeviationDisplay">--:--</span></p>
            </div>
            <input type="checkbox" id="manualAdvance" disabled>
            <label for="manualAdvance">Avance Manual de Parada</label>
            <button id="prevStopBtn" style="display:none;">Anterior</button>
            <button id="nextStopBtn" style="display:none;">Siguiente</button>
        </div>

        <div class="control-section">
            <h3>Cola de Rutas</h3>
            <button id="addCurrentToQueueBtn" disabled>Añadir Ruta Actual a Cola</button>
            <ul id="routeQueueList"></ul>
            <button id="clearQueueBtn">Limpiar Cola</button>
            <br>
            <input type="checkbox" id="autoStartNextInQueue" checked>
            <label for="autoStartNextInQueue">Iniciar automáticamente siguiente ruta en cola</label>
        </div>
    </div>

    <script>
        // --- Global Variables ---
        let map;
        let currentRoute = {
            name: "",
            stops: [] // { latlng, name, type: 'start'/'intermediate'/'end', time: 'HH:MM' }
        };
        let routePolyline = null;
        let stopMarkers = [];
        let driverMarker = null;
        let watchId = null;
        let currentStopIndex = -1; // For tracking progress
        let lastKnownPosition = null;
        let isAddingStopType = null; // 'start', 'end', 'intermediate'
        let intermediateStopCounter = 1;

        const ROUTE_STORAGE_KEY = 'smartMovePro_routes';
        let routeQueue = []; // Array of route objects

        // --- DOM Elements ---
        const routeNameInput = document.getElementById('routeName');
        const addStartPointBtn = document.getElementById('addStartPointBtn');
        const addEndPointBtn = document.getElementById('addEndPointBtn');
        const addIntermediatePointBtn = document.getElementById('addIntermediatePointBtn');
        const autoCalcTimesCheckbox = document.getElementById('autoCalcTimes');
        const instructionText = document.getElementById('instructionText');
        const stopsListUI = document.getElementById('stopsList');
        
        const savedRoutesSelect = document.getElementById('savedRoutesSelect');
        const loadRouteBtn = document.getElementById('loadRouteBtn');
        const saveRouteBtn = document.getElementById('saveRouteBtn');
        const deleteRouteBtn = document.getElementById('deleteRouteBtn');
        const clearCurrentRouteBtn = document.getElementById('clearCurrentRouteBtn');

        const startTrackingBtn = document.getElementById('startTrackingBtn');
        const stopTrackingBtn = document.getElementById('stopTrackingBtn');
        const statusPanel = document.getElementById('statusPanel');
        const speedDisplay = document.getElementById('speedDisplay');
        const nextStopDisplay = document.getElementById('nextStopDisplay');
        const timeDeviationDisplay = document.getElementById('timeDeviationDisplay');
        const manualAdvanceCheckbox = document.getElementById('manualAdvance');
        const prevStopBtn = document.getElementById('prevStopBtn');
        const nextStopBtn = document.getElementById('nextStopBtn');

        const addCurrentToQueueBtn = document.getElementById('addCurrentToQueueBtn');
        const routeQueueListUI = document.getElementById('routeQueueList');
        const clearQueueBtn = document.getElementById('clearQueueBtn');
        const autoStartNextInQueueCheckbox = document.getElementById('autoStartNextInQueue');

        // --- Utility Functions ---
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function createCustomMarkerIcon(text, type) {
            let bgColor = '#777'; // Default for intermediate
            let content = text;
            if (type === 'start') {
                bgColor = getRandomColor();
                content = 'I';
            } else if (type === 'end') {
                bgColor = '#c00'; // Red for end
                content = 'F';
            }
            const markerHtml = `<div class="custom-marker-content" style="background-color:${bgColor};">${content}</div>`;
            return L.divIcon({
                className: 'leaflet-div-icon',
                html: markerHtml,
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });
        }
        
        function createDriverMarkerIcon() {
            const markerHtml = `<div class="custom-marker-content driver-icon"></div>`;
            return L.divIcon({
                className: 'leaflet-div-icon',
                html: markerHtml,
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        function timeToMinutes(timeStr) { // "HH:MM"
            if (!timeStr) return 0;
            const [hours, minutes] = timeStr.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function minutesToTime(totalMinutes) {
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }
        
        function formatTimeDeviation(minutes) {
            const sign = minutes >= 0 ? '+' : '-';
            const absMinutes = Math.abs(minutes);
            const h = Math.floor(absMinutes / 60);
            const m = Math.floor(absMinutes % 60);
            const s = Math.floor((absMinutes * 60) % 60);
            return `${sign}${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }

        // --- Map Initialization ---
        function initMap() {
            map = L.map('map').setView([-27.4606, -58.8341], 13); // Centered on Corrientes, AR
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            map.on('click', onMapClick);
            updateAddStopButtons();
        }

        // --- Route Creation ---
        function onMapClick(e) {
            if (!isAddingStopType) return;

            let stopName = "";
            let stopTime = "";

            if (isAddingStopType === 'start') {
                stopName = prompt("Nombre del Punto de Inicio:", "Inicio") || "Inicio";
                stopTime = prompt("Hora de Salida (HH:MM):", "08:00");
                if (!stopTime || !/^\d{2}:\d{2}$/.test(stopTime)) {
                    alert("Formato de hora inválido. Use HH:MM.");
                    return;
                }
                currentRoute.stops = []; // Clear previous start if any
                intermediateStopCounter = 1;
            } else if (isAddingStopType === 'end') {
                stopName = prompt("Nombre del Punto Final:", "Fin") || "Fin";
                stopTime = prompt("Hora de Llegada (HH:MM):", "09:00");
                 if (!stopTime || !/^\d{2}:\d{2}$/.test(stopTime)) {
                    alert("Formato de hora inválido. Use HH:MM.");
                    return;
                }
            } else if (isAddingStopType === 'intermediate') {
                stopName = prompt(`Nombre de Parada Intermedia ${intermediateStopCounter}:`, `Parada ${intermediateStopCounter}`) || `Parada ${intermediateStopCounter}`;
                if (!autoCalcTimesCheckbox.checked) {
                    stopTime = prompt("Hora Programada (HH:MM) (opcional):", "");
                    if (stopTime && !/^\d{2}:\d{2}$/.test(stopTime)) {
                        alert("Formato de hora inválido. Use HH:MM o deje vacío.");
                        return;
                    }
                }
            }

            const newStop = {
                latlng: e.latlng,
                name: stopName,
                type: isAddingStopType,
                time: stopTime
            };

            if (isAddingStopType === 'start') {
                currentRoute.stops.unshift(newStop); // Add to beginning
            } else if (isAddingStopType === 'end') {
                 // Ensure 'end' is always the last physical stop if it's added before intermediates
                const existingEnd = currentRoute.stops.find(s => s.type === 'end');
                if (existingEnd) { // If end already exists, replace it
                    const endIndex = currentRoute.stops.indexOf(existingEnd);
                    currentRoute.stops[endIndex] = newStop;
                } else {
                    currentRoute.stops.push(newStop);
                }
            } else if (isAddingStopType === 'intermediate') {
                // Insert intermediate stops before the 'end' stop if it exists
                const endIndex = currentRoute.stops.findIndex(s => s.type === 'end');
                if (endIndex !== -1) {
                    currentRoute.stops.splice(endIndex, 0, newStop);
                } else {
                    currentRoute.stops.push(newStop);
                }
                intermediateStopCounter++;
            }
            
            if (currentRoute.stops.length > 1 && currentRoute.stops[0].type === 'start' && currentRoute.stops[currentRoute.stops.length - 1].type === 'end') {
                 if (autoCalcTimesCheckbox.checked) {
                    calculateIntermediateTimes();
                 }
            }

            renderCurrentRouteOnMap();
            renderStopsList();
            updateAddStopButtons();
            isAddingStopType = null; // Reset for next explicit button click
            instructionText.textContent = "Haga clic en un botón para añadir el siguiente tipo de parada.";
        }

        function calculateIntermediateTimes() {
            const startStop = currentRoute.stops.find(s => s.type === 'start');
            const endStop = currentRoute.stops.find(s => s.type === 'end');

            if (!startStop || !endStop || !startStop.time || !endStop.time) return;

            const intermediateStops = currentRoute.stops.filter(s => s.type === 'intermediate');
            if (intermediateStops.length === 0) return;

            const totalDurationMinutes = timeToMinutes(endStop.time) - timeToMinutes(startStop.time);
            if (totalDurationMinutes <= 0) {
                alert("La hora de fin debe ser posterior a la hora de inicio para calcular tiempos intermedios.");
                return;
            }

            let totalDistance = 0;
            const segments = []; // { stop, distanceFromStart }

            let currentPoint = startStop.latlng;
            for (let i = 0; i < currentRoute.stops.length; i++) {
                const stop = currentRoute.stops[i];
                if (i > 0) { // Calculate distance from previous stop to current
                    const prevStop = currentRoute.stops[i-1];
                    totalDistance += L.latLng(prevStop.latlng).distanceTo(L.latLng(stop.latlng));
                }
                if (stop.type === 'intermediate' || stop.type === 'end') {
                     segments.push({ stop: stop, cumulativeDist: totalDistance });
                }
            }
            if(totalDistance === 0) return; // Avoid division by zero


            let lastCalcTime = timeToMinutes(startStop.time);
            let cumulativeDistForCalc = 0;

            for (let i = 0; i < currentRoute.stops.length; i++) {
                const stop = currentRoute.stops[i];
                if (stop.type === 'intermediate') {
                    if (i > 0) {
                        const prevStop = currentRoute.stops[i-1];
                        const segmentDistance = L.latLng(prevStop.latlng).distanceTo(L.latLng(stop.latlng));
                        cumulativeDistForCalc += segmentDistance;
                        const timePortion = (cumulativeDistForCalc / totalDistance) * totalDurationMinutes;
                        stop.time = minutesToTime(timeToMinutes(startStop.time) + Math.round(timePortion));
                    }
                }
            }
            // Ensure end time is not altered by rounding issues if there are intermediates
            endStop.time = endStop.time; 
        }


        function updateAddStopButtons() {
            const hasStart = currentRoute.stops.some(s => s.type === 'start');
            const hasEnd = currentRoute.stops.some(s => s.type === 'end');

            addStartPointBtn.disabled = hasStart;
            addEndPointBtn.disabled = !hasStart || hasEnd;
            addIntermediatePointBtn.disabled = !hasStart || !hasEnd; // Can only add intermediate if start and end are defined

            instructionText.textContent = "Seleccione un tipo de parada para añadir.";
            if (isAddingStopType) {
                 instructionText.textContent = `Haga clic en el mapa para añadir: ${isAddingStopType.toUpperCase()}.`;
            }
            startTrackingBtn.disabled = !(hasStart && hasEnd && currentRoute.stops.length >=2);
            addCurrentToQueueBtn.disabled = !(hasStart && hasEnd && currentRoute.stops.length >=2 && routeNameInput.value);
        }

        addStartPointBtn.onclick = () => { isAddingStopType = 'start'; updateAddStopButtons(); };
        addEndPointBtn.onclick = () => { isAddingStopType = 'end'; updateAddStopButtons(); };
        addIntermediatePointBtn.onclick = () => { isAddingStopType = 'intermediate'; updateAddStopButtons(); };
        
        clearCurrentRouteBtn.onclick = () => {
            if (confirm("¿Está seguro de que desea limpiar la ruta actual?")) {
                currentRoute = { name: "", stops: [] };
                intermediateStopCounter = 1;
                routeNameInput.value = "";
                renderCurrentRouteOnMap();
                renderStopsList();
                updateAddStopButtons();
                enableRouteCreation();
            }
        };

        // --- Rendering on Map and List ---
        function renderCurrentRouteOnMap() {
            stopMarkers.forEach(marker => map.removeLayer(marker));
            stopMarkers = [];
            if (routePolyline) map.removeLayer(routePolyline);

            const latlngs = currentRoute.stops.map(stop => stop.latlng);

            let stopNumber = 1;
            currentRoute.stops.forEach(stop => {
                let label = stop.name;
                if (stop.type === 'intermediate') label = String(stopNumber++);
                const marker = L.marker(stop.latlng, { icon: createCustomMarkerIcon(label, stop.type) })
                    .addTo(map)
                    .bindPopup(`${stop.name} (${stop.type})${stop.time ? ' - ' + stop.time : ''}`);
                stopMarkers.push(marker);
            });

            if (latlngs.length > 1) {
                routePolyline = L.polyline(latlngs, { color: 'blue' }).addTo(map);
                try { map.fitBounds(routePolyline.getBounds()); } catch(e) { console.warn("Cannot fit bounds, not enough points yet or invalid bounds.")}
            } else if (latlngs.length === 1) {
                map.setView(latlngs[0], 15);
            }
        }

        function renderStopsList() {
            stopsListUI.innerHTML = '';
            currentRoute.stops.forEach((stop, index) => {
                const li = document.createElement('li');
                li.textContent = `${index + 1}. ${stop.name} (${stop.type}) ${stop.time ? '- ' + stop.time : '(sin hora)'}`;
                if (index === currentStopIndex) {
                    li.style.fontWeight = 'bold';
                    li.style.backgroundColor = '#007bff'; // Highlight current/next stop
                }
                stopsListUI.appendChild(li);
            });
        }

        // --- Cache Management (localStorage) ---
        function getSavedRoutes() {
            const routesJson = localStorage.getItem(ROUTE_STORAGE_KEY);
            return routesJson ? JSON.parse(routesJson) : {};
        }

        function saveRouteToCache() {
            const name = routeNameInput.value.trim();
            if (!name) {
                alert("Por favor, ingrese un nombre para la ruta.");
                return;
            }
            if (currentRoute.stops.length < 2) {
                alert("La ruta debe tener al menos un punto de inicio y un punto final.");
                return;
            }
            currentRoute.name = name; // Assign name from input to the route object

            const routes = getSavedRoutes();
            routes[name] = JSON.parse(JSON.stringify(currentRoute)); // Deep copy
            localStorage.setItem(ROUTE_STORAGE_KEY, JSON.stringify(routes));
            alert(`Ruta "${name}" guardada.`);
            populateSavedRoutesSelect();
        }
        saveRouteBtn.onclick = saveRouteToCache;

        function populateSavedRoutesSelect() {
            const routes = getSavedRoutes();
            savedRoutesSelect.innerHTML = '';
            Object.keys(routes).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                savedRoutesSelect.appendChild(option);
            });
            loadRouteBtn.disabled = Object.keys(routes).length === 0;
            deleteRouteBtn.disabled = Object.keys(routes).length === 0;
        }

        function loadSelectedRoute() {
            const selectedName = savedRoutesSelect.value;
            if (!selectedName) {
                alert("No hay ruta seleccionada para cargar.");
                return;
            }
            const routes = getSavedRoutes();
            if (routes[selectedName]) {
                currentRoute = JSON.parse(JSON.stringify(routes[selectedName])); // Deep copy
                routeNameInput.value = currentRoute.name;
                intermediateStopCounter = currentRoute.stops.filter(s => s.type === 'intermediate').length + 1;
                renderCurrentRouteOnMap();
                renderStopsList();
                updateAddStopButtons();
                alert(`Ruta "${selectedName}" cargada.`);
                enableRouteCreation(); // Ensure editing is possible after load
            } else {
                alert("Error al cargar la ruta.");
            }
        }
        loadRouteBtn.onclick = loadSelectedRoute;

        function deleteSelectedRoute() {
            const selectedName = savedRoutesSelect.value;
            if (!selectedName) {
                alert("No hay ruta seleccionada para borrar.");
                return;
            }
            if (confirm(`¿Está seguro de que desea borrar la ruta "${selectedName}"?`)) {
                const routes = getSavedRoutes();
                delete routes[selectedName];
                localStorage.setItem(ROUTE_STORAGE_KEY, JSON.stringify(routes));
                alert(`Ruta "${selectedName}" borrada.`);
                populateSavedRoutesSelect();
            }
        }
        deleteRouteBtn.onclick = deleteSelectedRoute;

        // --- Real-Time Tracking ---
        function startTracking() {
            if (currentRoute.stops.length < 2) {
                alert("No hay ruta cargada o la ruta es inválida para el seguimiento.");
                return;
            }
            if (navigator.geolocation) {
                currentStopIndex = 0; // Start with the first stop as the next target.
                statusPanel.style.display = 'block';
                startTrackingBtn.disabled = true;
                stopTrackingBtn.disabled = false;
                manualAdvanceCheckbox.disabled = false;
                disableRouteCreation();
                updateNextStopDisplay();

                watchId = navigator.geolocation.watchPosition(
                    handlePositionUpdate,
                    handleGeolocationError,
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                );
                alert("Seguimiento iniciado.");
            } else {
                alert("Geolocalización no soportada por este navegador.");
            }
        }
        startTrackingBtn.onclick = startTracking;

        function stopTracking(completed = false) {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            if (driverMarker) {
                map.removeLayer(driverMarker);
                driverMarker = null;
            }
            lastKnownPosition = null;
            currentStopIndex = -1; // Reset progress
            
            statusPanel.style.display = 'none';
            speedDisplay.textContent = "-- km/h";
            nextStopDisplay.textContent = "--";
            timeDeviationDisplay.textContent = "--:--";
            timeDeviationDisplay.className = '';

            startTrackingBtn.disabled = !(currentRoute.stops.length >= 2);
            stopTrackingBtn.disabled = true;
            manualAdvanceCheckbox.disabled = true;
            manualAdvanceCheckbox.checked = false;
            toggleManualAdvanceButtons(false);
            enableRouteCreation();
            renderStopsList(); // Re-render to remove highlighting

            if (!completed) {
                 alert("Seguimiento detenido.");
            }

            // Check route queue
            if (completed && routeQueue.length > 0) {
                const nextRouteFromQueue = routeQueue.shift(); // Get and remove first route
                updateRouteQueueList();
                currentRoute = nextRouteFromQueue; // Load it
                routeNameInput.value = currentRoute.name;
                intermediateStopCounter = currentRoute.stops.filter(s => s.type === 'intermediate').length + 1;
                renderCurrentRouteOnMap();
                renderStopsList();
                updateAddStopButtons();
                alert(`Ruta "${currentRoute.name}" completada. Cargando siguiente ruta de la cola: "${currentRoute.name}".`);
                if (autoStartNextInQueueCheckbox.checked) {
                    startTracking();
                } else {
                    alert("La siguiente ruta de la cola está cargada. Inicie el seguimiento manualmente.");
                }
            } else if (completed) {
                alert("Ruta completada. No hay más rutas en la cola.");
            }
        }
        stopTrackingBtn.onclick = () => stopTracking(false);

        function handlePositionUpdate(position) {
            const latlng = L.latLng(position.coords.latitude, position.coords.longitude);
            lastKnownPosition = position;

            if (!driverMarker) {
                driverMarker = L.marker(latlng, { icon: createDriverMarkerIcon() }).addTo(map);
            } else {
                driverMarker.setLatLng(latlng);
            }
            map.panTo(latlng); // Optionally keep driver centered

            speedDisplay.textContent = position.coords.speed ? (position.coords.speed * 3.6).toFixed(1) + " km/h" : "-- km/h";

            if (currentStopIndex >= currentRoute.stops.length) return; // All stops passed

            // Automatic stop detection (if not in manual mode)
            if (!manualAdvanceCheckbox.checked) {
                const nextScheduledStop = currentRoute.stops[currentStopIndex];
                if (nextScheduledStop) {
                    const distanceToNextStop = latlng.distanceTo(L.latLng(nextScheduledStop.latlng));
                    // Proximity threshold in meters (e.g., 50 meters)
                    if (distanceToNextStop < 50) { 
                        advanceToNextStop();
                    } else {
                        // Check if skipped a stop (more complex logic, for now simple advance)
                        // This requires checking proximity to ALL upcoming stops to find the "most logical" one.
                        // For simplicity, we'll rely on linear progression or manual for now.
                    }
                }
            }
            calculateTimeDeviation();
            renderStopsList(); // To update highlighting
        }

        function calculateTimeDeviation() {
            if (currentStopIndex < 0 || currentStopIndex >= currentRoute.stops.length || !lastKnownPosition) {
                timeDeviationDisplay.textContent = "--:--";
                timeDeviationDisplay.className = '';
                return;
            }

            let A_stop, B_stop;
            if (currentStopIndex === 0) { // Before the first stop (or at it, aiming for it)
                A_stop = currentRoute.stops.find(s => s.type === 'start'); // Should be currentRoute.stops[0] if properly ordered
                B_stop = currentRoute.stops[currentStopIndex]; // This is the target
            } else { // Between currentStopIndex-1 and currentStopIndex
                A_stop = currentRoute.stops[currentStopIndex - 1];
                B_stop = currentRoute.stops[currentStopIndex];
            }

            if (!A_stop || !B_stop || !A_stop.time || !B_stop.time) {
                 // If it's the very first segment and A is start, A.time is departure, B.time is arrival at first actual stop.
                 // If A_stop is start and B_stop is the first actual stop (which could be an intermediate or end)
                if (A_stop.type === 'start' && B_stop) {
                    // This case is valid, proceed.
                } else {
                    timeDeviationDisplay.textContent = "Error: Tiempos de parada no definidos";
                    timeDeviationDisplay.className = '';
                    console.error("Cannot calculate deviation: stop times missing for segment.", A_stop, B_stop);
                    return;
                }
            }
            
            const timeA_scheduled_minutes = timeToMinutes(A_stop.time);
            const timeB_scheduled_minutes = timeToMinutes(B_stop.time);
            const totalSegmentDuration_scheduled_minutes = timeB_scheduled_minutes - timeA_scheduled_minutes;

            if (totalSegmentDuration_scheduled_minutes <= 0 && !(A_stop === B_stop)) { // A_stop can be B_stop if only one stop in "segment"
                 timeDeviationDisplay.textContent = "Error: Duración de tramo inválida";
                 timeDeviationDisplay.className = '';
                 console.error("Cannot calculate deviation: Segment duration non-positive.", A_stop, B_stop);
                 return;
            }

            const driverLatLng = L.latLng(lastKnownPosition.coords.latitude, lastKnownPosition.coords.longitude);
            const latLngA = L.latLng(A_stop.latlng);
            const latLngB = L.latLng(B_stop.latlng);

            const totalSegmentDistance_meters = latLngA.distanceTo(latLngB);
            
            // Project driver's current position onto the line segment A-B to find closest point on path
            // This is a more accurate way to determine "progress along the segment" than direct distance from A.
            // For simplicity here, we'll use direct distance from A along the path (assuming driver is on path).
            // A true projection might be needed for high accuracy off-route scenarios.
            
            let distanceTraveledOnSegment_meters;
            if (currentStopIndex === 0 && A_stop.type === 'start') { // If going from start to the first stop
                // Calculate distance from actual start point to current position
                 distanceTraveledOnSegment_meters = latLngA.distanceTo(driverLatLng);
            } else {
                 // For intermediate segments, it's distance from the previously passed stop (A_stop)
                 distanceTraveledOnSegment_meters = latLngA.distanceTo(driverLatLng);
            }


            let percentageTraveled = 0;
            if (totalSegmentDistance_meters > 0) {
                percentageTraveled = Math.min(1, Math.max(0, distanceTraveledOnSegment_meters / totalSegmentDistance_meters));
            } else if (A_stop === B_stop) { // At a stop
                percentageTraveled = 1; // Or 0, depending on if we consider "arrived" or "about to depart"
            }


            const timeElapsedOnSegment_expected_minutes = percentageTraveled * totalSegmentDuration_scheduled_minutes;
            const expectedTimeAtDriverLocation_minutes_since_midnight = timeA_scheduled_minutes + timeElapsedOnSegment_expected_minutes;

            const now = new Date();
            const currentTime_minutes_since_midnight = now.getHours() * 60 + now.getMinutes() + now.getSeconds() / 60;
            
            const deviation_minutes = expectedTimeAtDriverLocation_minutes_since_midnight - currentTime_minutes_since_midnight;

            timeDeviationDisplay.textContent = formatTimeDeviation(deviation_minutes);
            if (deviation_minutes > 0.25) { // More than 15s ahead
                timeDeviationDisplay.className = 'status-adelantado';
            } else if (deviation_minutes < -0.25) { // More than 15s behind
                timeDeviationDisplay.className = 'status-atrasado';
            } else {
                timeDeviationDisplay.className = 'status-atiempo';
            }
        }

        function handleGeolocationError(error) {
            let message = "Error de geolocalización: ";
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    message += "Permiso denegado.";
                    break;
                case error.POSITION_UNAVAILABLE:
                    message += "Información de ubicación no disponible.";
                    break;
                case error.TIMEOUT:
                    message += "Timeout obteniendo ubicación.";
                    break;
                default:
                    message += "Error desconocido.";
                    break;
            }
            alert(message);
            stopTracking();
        }

        function updateNextStopDisplay() {
            if (currentStopIndex >= 0 && currentStopIndex < currentRoute.stops.length) {
                const nextStop = currentRoute.stops[currentStopIndex];
                nextStopDisplay.textContent = `${nextStop.name} (${nextStop.time || 'N/A'})`;
            } else if (currentStopIndex >= currentRoute.stops.length) {
                nextStopDisplay.textContent = "Ruta Completada";
            } else {
                nextStopDisplay.textContent = "--";
            }
        }

        // --- Stop Advancement ---
        manualAdvanceCheckbox.onchange = function() {
            toggleManualAdvanceButtons(this.checked && watchId); // Only show if tracking
        };

        function toggleManualAdvanceButtons(show) {
            prevStopBtn.style.display = show ? 'inline-block' : 'none';
            nextStopBtn.style.display = show ? 'inline-block' : 'none';
        }

        function advanceToNextStop() {
            if (currentStopIndex < currentRoute.stops.length -1) {
                currentStopIndex++;
                updateNextStopDisplay();
                renderStopsList();
                alert(`Avanzando a: ${currentRoute.stops[currentStopIndex].name}`);
            } else if (currentStopIndex === currentRoute.stops.length -1) {
                currentStopIndex++; // Move past the last stop
                updateNextStopDisplay(); // Will show "Ruta Completada"
                renderStopsList();
                alert("Ha llegado al final de la ruta.");
                stopTracking(true); // True indicates completion
            }
        }
        nextStopBtn.onclick = advanceToNextStop;

        function regressToPrevStop() {
            if (currentStopIndex > 0) {
                currentStopIndex--;
                updateNextStopDisplay();
                renderStopsList();
                alert(`Retrocediendo a: ${currentRoute.stops[currentStopIndex].name}`);
            } else {
                alert("Ya está en la primera parada (o antes de ella).");
            }
        }
        prevStopBtn.onclick = regressToPrevStop;
        
        function disableRouteCreation() {
            addStartPointBtn.disabled = true;
            addEndPointBtn.disabled = true;
            addIntermediatePointBtn.disabled = true;
            routeNameInput.disabled = true;
            saveRouteBtn.disabled = true;
            loadRouteBtn.disabled = true;
            deleteRouteBtn.disabled = true;
            clearCurrentRouteBtn.disabled = true;
            addCurrentToQueueBtn.disabled = true;
        }

        function enableRouteCreation() {
            updateAddStopButtons(); // This will correctly set button states based on currentRoute
            routeNameInput.disabled = false;
            saveRouteBtn.disabled = false; // Enable if route is valid
            populateSavedRoutesSelect(); // This handles disabling load/delete if no routes
            clearCurrentRouteBtn.disabled = false;
            addCurrentToQueueBtn.disabled = !(currentRoute.stops.length >=2 && routeNameInput.value);
        }

        // --- Route Queue ---
        addCurrentToQueueBtn.onclick = () => {
            const name = routeNameInput.value.trim();
            if (!name) {
                alert("Por favor, ingrese un nombre para la ruta actual antes de añadirla a la cola.");
                return;
            }
            if (currentRoute.stops.length < 2) {
                alert("La ruta actual no es válida para añadir a la cola.");
                return;
            }
            // Make sure the currentRoute object itself has the name
            currentRoute.name = name; 
            routeQueue.push(JSON.parse(JSON.stringify(currentRoute))); // Add a copy
            updateRouteQueueList();
            alert(`Ruta "${name}" añadida a la cola.`);
        };

        function updateRouteQueueList() {
            routeQueueListUI.innerHTML = '';
            routeQueue.forEach((route, index) => {
                const li = document.createElement('li');
                li.textContent = `${index + 1}. ${route.name}`;
                routeQueueListUI.appendChild(li);
            });
            clearQueueBtn.disabled = routeQueue.length === 0;
        }
        clearQueueBtn.onclick = () => {
            if (confirm("¿Limpiar toda la cola de rutas?")) {
                routeQueue = [];
                updateRouteQueueList();
            }
        };


        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            populateSavedRoutesSelect();
            updateRouteQueueList();
            updateAddStopButtons();
        });

    </script>
</body>
</html>
