<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* Evita el scroll general de la página */
        }

        #map {
            height: 55vh; /* Aproximadamente 50-60% */
            width: 100%;
            background-color: #333; /* Color de fondo mientras carga el mapa */
        }

        #controlsArea {
            flex-grow: 1;
            padding: 10px;
            overflow-y: auto; /* Scroll solo para el área de controles si es necesario */
            display: flex;
            flex-direction: column;
        }

        .control-section {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
        }

        .control-section h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #87CEFA; /* LightSkyBlue for headers */
        }

        input[type="text"], input[type="time"], input[type="datetime-local"], select, button {
            background-color: #333;
            color: #FFFFFF;
            border: 1px solid #555;
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            width: calc(100% - 18px); /* Ajustar por padding y borde */
            box-sizing: border-box;
        }
        
        input[type="checkbox"] {
            margin-right: 5px;
            vertical-align: middle;
        }

        button {
            cursor: pointer;
            background-color: #007bff; /* Azul para botones primarios */
        }
        button:hover {
            background-color: #0056b3;
        }
        button.danger {
            background-color: #dc3545; /* Rojo para botones de peligro */
        }
        button.danger:hover {
            background-color: #c82333;
        }
        button.secondary {
            background-color: #6c757d; /* Gris para secundarios */
        }
        button.secondary:hover {
            background-color: #545b62;
        }


        #stopsList {
            list-style-type: none;
            padding: 0;
        }
        #stopsList li {
            background-color: #222;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        #stopsList li.next-stop-highlight {
            background-color: #0056b3; /* Azul oscuro para destacar próxima parada */
            font-weight: bold;
        }

        #trackingInfo {
            font-size: 1em;
        }
        #deviationDisplay.adelantado {
            color: #00FF00; /* Verde */
        }
        #deviationDisplay.atrasado {
            color: #FF0000; /* Rojo */
        }
        #deviationDisplay.atiempo {
            color: #FFFFFF; /* Blanco */
        }

        /* Estilos para los iconos de Leaflet */
        .leaflet-div-icon {
            background: transparent;
            border: none;
        }
        .custom-marker-content {
            color: white;
            font-weight: bold;
            text-align: center;
            line-height: 20px; /* Ajustar según tamaño */
            width: 20px; /* Ajustar según tamaño */
            height: 20px; /* Ajustar según tamaño */
            border-radius: 50%; /* Círculo */
            font-size: 12px;
        }
        .start-marker .custom-marker-content { background-color: blue; }
        .end-marker .custom-marker-content { background-color: darkred; }
        .intermediate-marker .custom-marker-content { background-color: orange; }
        .driver-marker {
            background-color: rgba(0, 123, 255, 0.7); /* Azul pulsante */
            border: 2px solid white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            box-shadow: 0 0 0 rgba(0, 123, 255, 0.7);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 123, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 123, 255, 0); }
        }

    </style>
</head>
<body>
    <div id="map"></div>
    <div id="controlsArea">
        <div class="control-section">
            <h3>Crear/Modificar Ruta Actual</h3>
            <p>Toca el mapa para añadir paradas. La primera es INICIO, la segunda FIN, las siguientes INTERMEDIAS.</p>
            <input type="text" id="stopName" placeholder="Nombre de la parada (opcional para intermedias)">
            <input type="time" id="stopTime" placeholder="HH:MM (obligatorio para Inicio/Fin)">
            <p id="currentStopTypeInfo">Siguiente parada a añadir: INICIO</p>
            
            <label for="autoCalcTimes">
                <input type="checkbox" id="autoCalcTimes" checked> Calcular horarios intermedios automáticamente
            </label>
            <button id="resetCurrentRouteBtn">Limpiar Paradas Actuales</button>
        </div>

        <div class="control-section">
            <h3>Ruta Actual</h3>
            <ul id="stopsList">
                </ul>
        </div>

        <div class="control-section">
            <h3>Gestión de Rutas</h3>
            <input type="text" id="routeName" placeholder="Nombre para guardar la ruta">
            <button id="saveRouteBtn">Guardar Ruta Actual</button>
            <hr>
            <select id="savedRoutesSelect">
                <option value="">-- Cargar Ruta Guardada --</option>
            </select>
            <button id="loadRouteBtn">Cargar Ruta Seleccionada</button>
            <button id="deleteRouteBtn" class="danger">Borrar Ruta Seleccionada</button>
        </div>
        
        <div class="control-section">
            <h3>Seguimiento en Tiempo Real</h3>
            <button id="startTrackingBtn">Iniciar Seguimiento</button>
            <button id="stopTrackingBtn" style="display:none;">Detener Seguimiento</button>
            <div id="trackingInfo" style="margin-top:10px;">
                <p>Próxima Parada: <span id="nextStopDisplay">-</span></p>
                <p>Velocidad: <span id="speedDisplay">- km/h</span></p>
                <p>Desvío Horario: <span id="deviationDisplay" class="atiempo">00:00</span></p>
            </div>
            <label for="manualAdvance">
                <input type="checkbox" id="manualAdvance"> Avance Manual de Parada
            </label>
            <div id="manualAdvanceControls" style="display:none; margin-top:5px;">
                <button id="prevStopBtn" class="secondary">Parada Anterior</button>
                <button id="nextStopBtn" class="secondary">Siguiente Parada</button>
            </div>
        </div>

    </div>

    <script>
        // Variables globales
        let map;
        let currentRouteStops = []; // {lat, lng, name, time, type, originalIndex, manuallySetTime}
        let routePolyline = null;
        let stopMarkers = [];
        let driverMarker = null;
        let geolocWatchId = null;
        let isTracking = false;
        let currentTrackingStopIndex = 0; // Índice en currentRouteStops (ordenado por originalIndex para seguimiento)
        const PROXIMITY_THRESHOLD = 50; // metros para detección de parada

        // --- INICIALIZACIÓN ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadSavedRoutesList();
            attachEventListeners();
            updateCurrentStopTypeInfo();
            checkLocalStorageSupport();
        });

        function checkLocalStorageSupport() {
            if (typeof(Storage) === "undefined") {
                alert("Tu navegador no soporta localStorage. No se podrán guardar ni cargar rutas.");
                document.getElementById('saveRouteBtn').disabled = true;
                document.getElementById('loadRouteBtn').disabled = true;
                document.getElementById('deleteRouteBtn').disabled = true;
                document.getElementById('routeName').disabled = true;
                document.getElementById('savedRoutesSelect').disabled = true;
            }
        }

        function initMap() {
            map = L.map('map').setView([20, 0], 2); // Vista inicial genérica
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            map.on('click', onMapClick);

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => map.setView([position.coords.latitude, position.coords.longitude], 13),
                    () => console.warn("No se pudo obtener la ubicación inicial.")
                );
            }
        }

        function attachEventListeners() {
            document.getElementById('saveRouteBtn').addEventListener('click', saveRoute);
            document.getElementById('loadRouteBtn').addEventListener('click', loadRoute);
            document.getElementById('deleteRouteBtn').addEventListener('click', deleteRoute);
            document.getElementById('resetCurrentRouteBtn').addEventListener('click', resetCurrentRoute);
            
            document.getElementById('startTrackingBtn').addEventListener('click', startTracking);
            document.getElementById('stopTrackingBtn').addEventListener('click', stopTracking);

            document.getElementById('manualAdvance').addEventListener('change', toggleManualAdvanceControls);
            document.getElementById('prevStopBtn').addEventListener('click', () => manualAdvanceStop(-1));
            document.getElementById('nextStopBtn').addEventListener('click', () => manualAdvanceStop(1));
            
            document.getElementById('autoCalcTimes').addEventListener('change', () => {
                if (document.getElementById('autoCalcTimes').checked) {
                    calculateAndApplyIntermediateTimes();
                }
                // Si se desmarca, no hacemos nada con los tiempos ya calculados/manuales.
                // El usuario tendría que editarlos uno por uno o limpiar la ruta.
            });
        }

        // --- LÓGICA DE CREACIÓN DE RUTA ---
        function onMapClick(e) {
            if (isTracking) {
                alert("Detén el seguimiento actual para modificar la ruta.");
                return;
            }

            const lat = e.latlng.lat;
            const lng = e.latlng.lng;
            const stopNameInput = document.getElementById('stopName');
            const stopTimeInput = document.getElementById('stopTime');
            let stopType;
            let stopTime = stopTimeInput.value; // HH:MM
            let manuallySetTimeFlag = false;

            if (currentRouteStops.length === 0) { // Inicio
                stopType = 'Inicio';
                if (!stopTime) { alert("Debe ingresar el horario de Salida para la parada de INICIO."); return; }
                manuallySetTimeFlag = true;
            } else if (currentRouteStops.length === 1) { // Fin
                stopType = 'Fin';
                if (!stopTime) { alert("Debe ingresar el horario de Llegada para la parada de FIN."); return; }
                manuallySetTimeFlag = true;
            } else { // Intermedia
                stopType = 'Intermedia';
                if (stopTime) { // Si el usuario proveyó tiempo para una intermedia
                    manuallySetTimeFlag = true;
                }
                // Nombre y horario son opcionales para intermedias si manuallySetTimeFlag es false
            }
            
            const stop = {
                lat: lat,
                lng: lng,
                name: stopNameInput.value || `${stopType} ${currentRouteStops.filter(s=>s.type === stopType).length + 1}`,
                time: stopTime,
                type: stopType,
                originalIndex: currentRouteStops.length,
                manuallySetTime: manuallySetTimeFlag
            };

            if (currentRouteStops.length > 1 && currentRouteStops[1].type === 'Fin' && stopType === 'Intermedia') {
                const finalStop = currentRouteStops.pop(); 
                currentRouteStops.push(stop); 
                currentRouteStops.push(finalStop); 
            } else {
                 currentRouteStops.push(stop);
            }

            stopNameInput.value = ''; 

            if (document.getElementById('autoCalcTimes').checked) {
                calculateAndApplyIntermediateTimes(); // Recalcular siempre que se añade una parada y la opción está activa
            }
            
            visualizeCurrentRoute();
            updateCurrentStopTypeInfo();
        }
        
        function updateCurrentStopTypeInfo() {
            const infoEl = document.getElementById('currentStopTypeInfo');
            if (currentRouteStops.length === 0) infoEl.textContent = "Siguiente parada a añadir: INICIO (nombre y horario obligatorios)";
            else if (currentRouteStops.length === 1) infoEl.textContent = "Siguiente parada a añadir: FIN (nombre y horario obligatorios)";
            else infoEl.textContent = "Siguiente parada a añadir: INTERMEDIA (nombre y horario opcionales)";
        }

        function resetCurrentRoute() {
            if (isTracking) {
                alert("Detén el seguimiento para limpiar la ruta.");
                return;
            }
            currentRouteStops = [];
            visualizeCurrentRoute();
            updateCurrentStopTypeInfo();
            document.getElementById('stopsList').innerHTML = '';
        }
        
        function calculateAndApplyIntermediateTimes() {
            if (currentRouteStops.length < 2) return;

            // Usar una copia para no modificar directamente mientras se itera si es complejo,
            // aunque aquí modificaremos las referencias directamente.
            // Primero, asegurarse que los objetos de currentRouteStops tengan el flag `manuallySetTime`
            // (ya debería estar por `onMapClick`)

            const startStop = currentRouteStops.find(s => s.type === 'Inicio');
            const endStop = currentRouteStops.find(s => s.type === 'Fin');

            if (!startStop || !endStop || !startStop.time || !endStop.time) {
                console.warn("Inicio o Fin no definidos o sin horario para cálculo automático.");
                return;
            }

            const startTimeSeconds = timeToSeconds(startStop.time);
            const endTimeSeconds = timeToSeconds(endStop.time);
            
            if (endTimeSeconds <= startTimeSeconds) {
                console.warn("La hora de fin debe ser posterior a la de inicio. No se calcularán tiempos intermedios.");
                // Opcionalmente, limpiar tiempos intermedios no manuales si ya existen
                currentRouteStops.forEach(stop => {
                    if (stop.type === 'Intermedia' && !stop.manuallySetTime) {
                        stop.time = '';
                    }
                });
                visualizeCurrentRoute();
                return;
            }

            // Construir la secuencia de paradas que formarán la ruta para el cálculo.
            // Incluye Inicio, todas las Intermedias (manuales o no) y Fin, ordenadas.
            let calculationPath = [startStop];
            calculationPath.push(...currentRouteStops.filter(s => s.type === 'Intermedia').sort((a, b) => a.originalIndex - b.originalIndex));
            calculationPath.push(endStop);
            
            // Eliminar duplicados si startStop o endStop fueron accidentalmente agregados como intermedias
            // (la lógica de tipos debería prevenir esto, pero por si acaso)
            calculationPath = calculationPath.filter((stop, index, self) =>
                index === self.findIndex(s => s.originalIndex === stop.originalIndex)
            );


            // Iterar por "bloques". Un bloque está definido por dos paradas consecutivas con tiempo fijo (manual o Inicio/Fin).
            let lastFixedTimeStop = startStop;
            let lastFixedTimeSeconds = startTimeSeconds;

            for (let i = 1; i < calculationPath.length; i++) {
                const currentStop = calculationPath[i];
                let currentBlockEndStop;
                let currentBlockEndTimeSeconds;

                // Determinar el final del bloque actual
                if (currentStop.type === 'Fin' || (currentStop.type === 'Intermedia' && currentStop.manuallySetTime && currentStop.time)) {
                    currentBlockEndStop = currentStop;
                    currentBlockEndTimeSeconds = timeToSeconds(currentStop.time);
                } else if (i === calculationPath.length - 1) { // Llegamos al final del path y el último es el endStop (que debe tener tiempo)
                     currentBlockEndStop = endStop;
                     currentBlockEndTimeSeconds = endTimeSeconds; // Ya lo teníamos
                } else {
                    continue; // Esta parada intermedia no es un fin de bloque, seguir buscando.
                }

                // Tenemos un bloque: desde lastFixedTimeStop hasta currentBlockEndStop
                const blockDurationSeconds = currentBlockEndTimeSeconds - lastFixedTimeSeconds;
                
                // Paradas dentro de este bloque que necesitan cálculo (excluyendo las anclas del bloque)
                const stopsInBlockForCalc = calculationPath.filter(s => 
                    s.originalIndex > lastFixedTimeStop.originalIndex && 
                    s.originalIndex < currentBlockEndStop.originalIndex &&
                    s.type === 'Intermedia' && 
                    !s.manuallySetTime
                );

                if (blockDurationSeconds < 0) {
                     console.warn(`Tiempo inconsistente en bloque: ${lastFixedTimeStop.name} (${secondsToTime(lastFixedTimeSeconds)}) a ${currentBlockEndStop.name} (${secondsToTime(currentBlockEndTimeSeconds)}). Saltando cálculo para este bloque.`);
                } else if (stopsInBlockForCalc.length > 0) {
                    // Construir la ruta física para este bloque (incluyendo anclas)
                    let blockPath = [lastFixedTimeStop, ...stopsInBlockForCalc, currentBlockEndStop];
                    
                    let blockTotalHaversineDistance = 0;
                    const blockSegmentDistances = []; // Distancias entre paradas consecutivas en blockPath
                    for(let j = 0; j < blockPath.length - 1; j++) {
                        const dist = haversineDistance(blockPath[j], blockPath[j+1]);
                        blockSegmentDistances.push(dist);
                        blockTotalHaversineDistance += dist;
                    }

                    if (blockTotalHaversineDistance === 0 && blockDurationSeconds > 0) {
                        // Mismo lugar, distribuir tiempo equitativamente
                        const timePerInternalStop = blockDurationSeconds / (stopsInBlockForCalc.length + 1);
                        let accumulatedTimeInBlock = lastFixedTimeSeconds;
                        for (let j = 0; j < stopsInBlockForCalc.length; j++) {
                            accumulatedTimeInBlock += timePerInternalStop;
                            const stopToUpdate = currentRouteStops.find(s => s.originalIndex === stopsInBlockForCalc[j].originalIndex);
                            if (stopToUpdate && !stopToUpdate.manuallySetTime) { // Doble check
                                stopToUpdate.time = secondsToTime(Math.round(accumulatedTimeInBlock));
                            }
                        }
                    } else if (blockTotalHaversineDistance > 0 && blockDurationSeconds >=0) { // Permitir duración cero si hay distancia
                        let accumulatedDistanceInBlock = 0;
                        for (let j = 0; j < stopsInBlockForCalc.length; j++) {
                            // Distancia desde lastFixedTimeStop hasta stopsInBlockForCalc[j]
                            // Necesitamos la distancia acumulada *dentro del blockPath*
                            // El primer segmento es blockSegmentDistances[0] (lastFixedTimeStop a stopsInBlockForCalc[0])
                            // El segundo es blockSegmentDistances[1] (stopsInBlockForCalc[0] a stopsInBlockForCalc[1])
                            // etc.
                            // accumulatedDistanceInBlock se refiere a la posición de stopsInBlockForCalc[j] en el blockPath
                            
                            // Sumar distancia hasta esta parada (stopsInBlockForCalc[j]) desde el inicio del bloque (lastFixedTimeStop)
                            // stopsInBlockForCalc[j] corresponde al índice j+1 en blockPath
                            let distToCurrentStopInBlock = 0;
                            for(let k=0; k <= j; k++) { // Sumar distancias de los segmentos que llevan a esta parada
                                distToCurrentStopInBlock += blockSegmentDistances[k];
                            }
                            
                            const proportionOfDistance = distToCurrentStopInBlock / blockTotalHaversineDistance;
                            const calculatedTimeSeconds = lastFixedTimeSeconds + (blockDurationSeconds * proportionOfDistance);
                            
                            const stopToUpdate = currentRouteStops.find(s => s.originalIndex === stopsInBlockForCalc[j].originalIndex);
                             if (stopToUpdate && !stopToUpdate.manuallySetTime) { // Doble check
                                stopToUpdate.time = secondsToTime(Math.round(calculatedTimeSeconds));
                            }
                        }
                    }
                }
                // Preparar para el siguiente bloque
                lastFixedTimeStop = currentBlockEndStop;
                lastFixedTimeSeconds = currentBlockEndTimeSeconds;

                if (lastFixedTimeStop.type === 'Fin') break; // Ruta completamente procesada
            }
            visualizeCurrentRoute();
        }


        // --- VISUALIZACIÓN DE RUTA ---
        function visualizeCurrentRoute() {
            stopMarkers.forEach(marker => map.removeLayer(marker));
            stopMarkers = [];
            if (routePolyline) {
                map.removeLayer(routePolyline);
                routePolyline = null;
            }

            const stopsListElement = document.getElementById('stopsList');
            stopsListElement.innerHTML = ''; 
            const latLngs = [];

            let displayStops = [];
            const start = currentRouteStops.find(s => s.type === 'Inicio');
            const end = currentRouteStops.find(s => s.type === 'Fin');
            const intermediates = currentRouteStops.filter(s => s.type === 'Intermedia').sort((a,b) => a.originalIndex - b.originalIndex);
            
            if(start) displayStops.push(start);
            displayStops.push(...intermediates);
            if(end && end !== start) displayStops.push(end); 

            displayStops.forEach((stop, index) => {
                const listItem = document.createElement('li');
                let stopTimeDisplay = stop.time || "N/A";
                if(stop.manuallySetTime && stop.time) stopTimeDisplay += " (M)";

                listItem.textContent = `${index + 1}. ${stop.name} (${stop.type}) - ${stopTimeDisplay}`;
                
                const orderedStopsForTracking = [...currentRouteStops].sort((a, b) => a.originalIndex - b.originalIndex);
                if (isTracking && orderedStopsForTracking[currentTrackingStopIndex] && stop.originalIndex === orderedStopsForTracking[currentTrackingStopIndex].originalIndex) {
                    listItem.classList.add('next-stop-highlight');
                }
                stopsListElement.appendChild(listItem);

                if (stop.lat && stop.lng) {
                    latLngs.push([stop.lat, stop.lng]);
                    let icon;
                    let markerHtml;
                    let className = 'custom-marker';

                    if (stop.type === 'Inicio') {
                        markerHtml = '<div class="custom-marker-content">I</div>';
                        className += ' start-marker';
                    } else if (stop.type === 'Fin') {
                        markerHtml = '<div class="custom-marker-content">F</div>';
                        className += ' end-marker';
                    } else {
                        const intermediateDisplayIndex = displayStops.filter(s => s.type === 'Intermedia' && s.originalIndex <= stop.originalIndex).length;
                        markerHtml = `<div class="custom-marker-content">${intermediateDisplayIndex}</div>`;
                        className += ' intermediate-marker';
                    }
                    
                    icon = L.divIcon({
                        className: className,
                        html: markerHtml,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });

                    const marker = L.marker([stop.lat, stop.lng], { icon: icon }).addTo(map);
                    marker.bindPopup(`<b>${stop.name}</b><br>${stop.type}<br>${stopTimeDisplay}`);
                    stopMarkers.push(marker);
                }
            });

            if (latLngs.length >= 2) {
                routePolyline = L.polyline(latLngs, { color: 'blue' }).addTo(map);
            }
        }

        // --- GESTIÓN DE RUTAS (localStorage) ---
        function saveRoute() {
            const routeName = document.getElementById('routeName').value;
            if (!routeName) {
                alert("Por favor, ingresa un nombre para la ruta.");
                return;
            }
            if (currentRouteStops.length < 2) {
                alert("La ruta debe tener al menos una parada de Inicio y una de Fin para ser guardada.");
                return;
            }
             if (!currentRouteStops.find(s => s.type === 'Inicio') || !currentRouteStops.find(s => s.type === 'Fin')){
                alert("La ruta debe tener una parada de Inicio y una de Fin definidas.");
                return;
            }

            try {
                localStorage.setItem(`smartmovepro_route_${routeName}`, JSON.stringify(currentRouteStops));
                alert(`Ruta "${routeName}" guardada.`);
                loadSavedRoutesList(); 
            } catch (e) {
                console.error("Error guardando en localStorage:", e);
                alert("Error al guardar la ruta. El almacenamiento podría estar lleno o no disponible.");
            }
        }

        function loadSavedRoutesList() {
            const select = document.getElementById('savedRoutesSelect');
            select.innerHTML = '<option value="">-- Cargar Ruta Guardada --</option>'; 
            try {
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('smartmovepro_route_')) {
                        const routeName = key.replace('smartmovepro_route_', '');
                        const option = document.createElement('option');
                        option.value = routeName;
                        option.textContent = routeName;
                        select.appendChild(option);
                    }
                }
            } catch (e) {
                console.error("Error leyendo de localStorage:", e);
            }
        }

        function loadRoute() {
            if (isTracking) {
                alert("Detén el seguimiento actual para cargar otra ruta.");
                return;
            }
            const routeName = document.getElementById('savedRoutesSelect').value;
            if (!routeName) {
                alert("Por favor, selecciona una ruta para cargar.");
                return;
            }
            try {
                const routeData = localStorage.getItem(`smartmovepro_route_${routeName}`);
                if (routeData) {
                    currentRouteStops = JSON.parse(routeData);
                    // Asegurar que las paradas cargadas tengan el flag manuallySetTime si no lo tenían (compatibilidad versiones antiguas)
                    currentRouteStops.forEach(s => {
                        if (s.manuallySetTime === undefined) {
                            if (s.type === 'Inicio' || s.type === 'Fin') s.manuallySetTime = true;
                            else if (s.type === 'Intermedia' && s.time) s.manuallySetTime = true;
                            else s.manuallySetTime = false;
                        }
                    });
                    visualizeCurrentRoute();
                    updateCurrentStopTypeInfo(); 
                    document.getElementById('routeName').value = routeName; 
                    alert(`Ruta "${routeName}" cargada.`);
                } else {
                    alert("No se encontró la ruta seleccionada.");
                }
            } catch (e) {
                console.error("Error cargando desde localStorage:", e);
                alert("Error al cargar la ruta.");
            }
        }

        function deleteRoute() {
             if (isTracking) {
                alert("Detén el seguimiento actual para borrar una ruta.");
                return;
            }
            const routeName = document.getElementById('savedRoutesSelect').value;
            if (!routeName) {
                alert("Por favor, selecciona una ruta para borrar.");
                return;
            }
            if (confirm(`¿Estás seguro de que quieres borrar la ruta "${routeName}"?`)) {
                try {
                    localStorage.removeItem(`smartmovepro_route_${routeName}`);
                    alert(`Ruta "${routeName}" borrada.`);
                    loadSavedRoutesList(); 
                    if (document.getElementById('routeName').value === routeName) {
                        resetCurrentRoute();
                        document.getElementById('routeName').value = "";
                    }
                } catch (e) {
                    console.error("Error borrando de localStorage:", e);
                    alert("Error al borrar la ruta.");
                }
            }
        }


        // --- SEGUIMIENTO EN TIEMPO REAL ---
        function startTracking() {
            if (currentRouteStops.length < 2) {
                alert("Carga o crea una ruta con al menos Inicio y Fin para iniciar el seguimiento.");
                return;
            }
            const startStop = currentRouteStops.find(s => s.type === 'Inicio');
            const endStop = currentRouteStops.find(s => s.type === 'Fin');

            if (!startStop || !endStop || !startStop.time || !endStop.time){
                alert("La ruta actual no tiene una parada de Inicio y/o Fin con horarios definidos.");
                return;
            }
            
            const orderedStopsForTracking = [...currentRouteStops].sort((a,b) => a.originalIndex - b.originalIndex);
            for (const stop of orderedStopsForTracking) {
                 // Solo las paradas que se usarán para el cálculo de desvío necesitan tiempo válido.
                 // Inicio, Fin, y paradas intermedias con tiempo (manual o calculado)
                if (stop.time && !isValidTime(stop.time)) {
                     alert(`La parada "${stop.name}" tiene un formato de hora inválido. Use HH:MM.`);
                     return;
                }
                 // Si una parada no tiene tiempo (intermedia opcional), no bloquea el inicio, pero el desvío podría no calcularse para ese tramo.
            }


            isTracking = true;
            currentTrackingStopIndex = 0; 
            updateNextStopDisplay();
            visualizeCurrentRoute(); 

            document.getElementById('startTrackingBtn').style.display = 'none';
            document.getElementById('stopTrackingBtn').style.display = 'inline-block';
            document.getElementById('resetCurrentRouteBtn').disabled = true;
            document.getElementById('saveRouteBtn').disabled = true;
            document.getElementById('loadRouteBtn').disabled = true;
            document.getElementById('autoCalcTimes').disabled = true;


            if (navigator.geolocation) {
                geolocWatchId = navigator.geolocation.watchPosition(
                    geolocationSuccess,
                    geolocationError,
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                );
            } else {
                alert("Geolocalización no soportada por este navegador.");
                stopTracking(); 
            }
        }

        function stopTracking() {
            isTracking = false;
            if (geolocWatchId) {
                navigator.geolocation.clearWatch(geolocWatchId);
                geolocWatchId = null;
            }
            if (driverMarker) {
                map.removeLayer(driverMarker);
                driverMarker = null;
            }
            
            document.getElementById('startTrackingBtn').style.display = 'inline-block';
            document.getElementById('stopTrackingBtn').style.display = 'none';
            document.getElementById('resetCurrentRouteBtn').disabled = false;
            document.getElementById('saveRouteBtn').disabled = false;
            document.getElementById('loadRouteBtn').disabled = false;
            document.getElementById('autoCalcTimes').disabled = false;

            document.getElementById('speedDisplay').textContent = '- km/h';
            document.getElementById('deviationDisplay').textContent = '00:00';
            document.getElementById('deviationDisplay').className = 'atiempo';
            document.getElementById('nextStopDisplay').textContent = '-';
            currentTrackingStopIndex = 0; 
            visualizeCurrentRoute(); 
            alert("Seguimiento detenido.");
        }

        function geolocationSuccess(position) {
            const { latitude, longitude, speed } = position.coords;

            if (!driverMarker) {
                const driverIcon = L.divIcon({
                    className: 'driver-marker',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });
                driverMarker = L.marker([latitude, longitude], { icon: driverIcon, zIndexOffset: 1000 }).addTo(map);
            } else {
                driverMarker.setLatLng([latitude, longitude]);
            }
            // map.panTo([latitude, longitude]); // Opcional

            const speedKmh = speed ? (speed * 3.6).toFixed(1) : '-'; 
            document.getElementById('speedDisplay').textContent = `${speedKmh} km/h`;
            
            const orderedStopsForTracking = [...currentRouteStops].sort((a,b) => a.originalIndex - b.originalIndex);
            if (orderedStopsForTracking.length > 0 && currentTrackingStopIndex < orderedStopsForTracking.length) {
                calculateAndDisplayDeviation({ lat: latitude, lng: longitude }, orderedStopsForTracking);
                
                if (!document.getElementById('manualAdvance').checked) {
                    checkAutoAdvanceStop({ lat: latitude, lng: longitude }, orderedStopsForTracking);
                }
            } else if (currentTrackingStopIndex >= orderedStopsForTracking.length && orderedStopsForTracking.length > 0) {
                 document.getElementById('nextStopDisplay').textContent = "RUTA COMPLETADA";
            }
        }

        function geolocationError(error) {
            console.error("Error de geolocalización:", error);
            let message = "Error de geolocalización: ";
            switch(error.code) {
                case error.PERMISSION_DENIED: message += "Permiso denegado."; break;
                case error.POSITION_UNAVAILABLE: message += "Posición no disponible."; break;
                case error.TIMEOUT: message += "Timeout obteniendo posición."; break;
                default: message += "Error desconocido."; break;
            }
            // No detener el tracking por errores menores de geolocalización si el usuario puede seguir manualmente.
            // Solo alertar. Si es crítico (ej. PERMISSION_DENIED persistente), el usuario detendrá.
            const deviationEl = document.getElementById('deviationDisplay');
            deviationEl.textContent = 'GPS ERR';
            deviationEl.className = 'atrasado'; // Usar color rojo para error de GPS
        }

        function calculateAndDisplayDeviation(currentLocation, orderedStops) {
            let stopA, stopB;

            if (currentTrackingStopIndex === 0) { 
                stopA = orderedStops.find(s => s.type === 'Inicio'); // La primera parada siempre es Inicio
                if (!stopA || !stopA.time) { updateDeviationDisplay(0); return; }

                const timeToStopA_seconds = timeToSeconds(stopA.time);
                const now_seconds = timeToSeconds(getCurrentHHMMSS());
                const deviationSeconds = now_seconds - timeToStopA_seconds; 
                updateDeviationDisplay(-deviationSeconds);
                return;

            } else { 
                let lastPassedStopWithTime = null;
                for(let i = currentTrackingStopIndex -1; i >=0; i--) {
                    if (orderedStops[i] && orderedStops[i].time && isValidTime(orderedStops[i].time)) {
                        lastPassedStopWithTime = orderedStops[i];
                        break;
                    }
                }
                stopA = lastPassedStopWithTime;

                let nextScheduledStop = null;
                 for(let i = currentTrackingStopIndex; i < orderedStops.length; i++) {
                    if (orderedStops[i] && orderedStops[i].time && isValidTime(orderedStops[i].time)) {
                        nextScheduledStop = orderedStops[i];
                        break;
                    }
                }
                stopB = nextScheduledStop;

                if (!stopA || !stopB ) { // No hay suficientes paradas con tiempo para calcular
                    // console.warn("No se pueden determinar paradas A y B con tiempo para calcular desvío.", stopA, stopB);
                    updateDeviationDisplay(0); 
                    return;
                }
            }

            const T_A_seconds = timeToSeconds(stopA.time);
            const T_B_seconds = timeToSeconds(stopB.time);
            const TT_tramo_seconds = T_B_seconds - T_A_seconds;

            if (TT_tramo_seconds <= 0 && stopA.originalIndex !== stopB.originalIndex) {
                const now_seconds = timeToSeconds(getCurrentHHMMSS());
                const deviationSeconds = now_seconds - T_B_seconds; // Desvío respecto a la próxima parada B
                updateDeviationDisplay(-deviationSeconds); 
                return;
            } else if (TT_tramo_seconds <= 0 && stopA.originalIndex === stopB.originalIndex) {
                const now_seconds = timeToSeconds(getCurrentHHMMSS());
                const deviationSeconds = now_seconds - T_A_seconds;
                updateDeviationDisplay(-deviationSeconds); 
                return;
            }

            const D_total = haversineDistance(stopA, stopB);
            const D_recorrida = haversineDistance(stopA, currentLocation);

            let T_esperado_actual_seconds;
            if (D_total > 0) {
                const proportion = Math.min(1, Math.max(0, D_recorrida / D_total));
                T_esperado_actual_seconds = T_A_seconds + (TT_tramo_seconds * proportion);
            } else { 
                 const now = timeToSeconds(getCurrentHHMMSS());
                 if (now < T_A_seconds) T_esperado_actual_seconds = T_A_seconds;
                 else if (now > T_B_seconds) T_esperado_actual_seconds = T_B_seconds;
                 else T_esperado_actual_seconds = now; 
            }

            const hora_actual_seconds = timeToSeconds(getCurrentHHMMSS());
            const desvio_seconds = hora_actual_seconds - T_esperado_actual_seconds;
            
            updateDeviationDisplay(-desvio_seconds);
        }

        function updateDeviationDisplay(deviationSeconds) {
            const sign = deviationSeconds > 0 ? '+' : (deviationSeconds < 0 ? '-' : '');
            const absSeconds = Math.abs(Math.round(deviationSeconds));
            const minutes = Math.floor(absSeconds / 60);
            const seconds = absSeconds % 60;
            const displayString = `${sign}${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

            const deviationEl = document.getElementById('deviationDisplay');
            deviationEl.textContent = displayString;
            if (deviationSeconds > 5) deviationEl.className = 'adelantado'; // Umbral pequeño para "a tiempo"
            else if (deviationSeconds < -5) deviationEl.className = 'atrasado';
            else deviationEl.className = 'atiempo';
        }
        
        function checkAutoAdvanceStop(currentLocation, orderedStops) {
            if (currentTrackingStopIndex >= orderedStops.length) return; 

            const nextStopTarget = orderedStops[currentTrackingStopIndex];
            if (!nextStopTarget) return;

            const distanceToNextStop = haversineDistance(currentLocation, nextStopTarget);

            if (distanceToNextStop < PROXIMITY_THRESHOLD) {
                advanceToNextLogicalStop(orderedStops);
            } else {
                let closestForwardStopIndex = -1;
                let minDistance = Infinity;

                for (let i = currentTrackingStopIndex + 1; i < orderedStops.length; i++) {
                    const forwardStop = orderedStops[i];
                    const dist = haversineDistance(currentLocation, forwardStop);
                    if (dist < PROXIMITY_THRESHOLD * 2 && dist < minDistance) { 
                        minDistance = dist;
                        closestForwardStopIndex = i;
                    }
                }
                if (closestForwardStopIndex !== -1) {
                    if (minDistance < distanceToNextStop / 2 ) { 
                        console.log(`Salto detectado a la parada: ${orderedStops[closestForwardStopIndex].name}`);
                        currentTrackingStopIndex = closestForwardStopIndex;
                        updateNextStopDisplay(orderedStops);
                        visualizeCurrentRoute(); 
                    }
                }
            }
        }
        
        function advanceToNextLogicalStop(orderedStops) {
            currentTrackingStopIndex++;
            if (currentTrackingStopIndex >= orderedStops.length) {
                document.getElementById('nextStopDisplay').textContent = "RUTA COMPLETADA";
            } else {
                updateNextStopDisplay(orderedStops);
            }
            visualizeCurrentRoute(); 
        }


        function toggleManualAdvanceControls() {
            const manualAdvanceCheckbox = document.getElementById('manualAdvance');
            const manualControlsDiv = document.getElementById('manualAdvanceControls');
            manualControlsDiv.style.display = manualAdvanceCheckbox.checked ? 'block' : 'none';
        }

        function manualAdvanceStop(direction) { 
            if (!isTracking) {
                alert("Debe iniciar el seguimiento para usar el avance manual.");
                return;
            }
            const orderedStops = [...currentRouteStops].sort((a,b) => a.originalIndex - b.originalIndex);
            const newIndex = currentTrackingStopIndex + direction;

            if (newIndex >= 0 && newIndex < orderedStops.length) {
                currentTrackingStopIndex = newIndex;
            } else if (newIndex >= orderedStops.length) {
                currentTrackingStopIndex = orderedStops.length; 
                document.getElementById('nextStopDisplay').textContent = "RUTA COMPLETADA";
                alert("Has llegado al final de la ruta (manualmente).");
            } else {
                currentTrackingStopIndex = 0;
            }
            updateNextStopDisplay(orderedStops);
            visualizeCurrentRoute(); 
        }
        
        function updateNextStopDisplay(stops = null) {
            const orderedStopsToUse = stops || [...currentRouteStops].sort((a,b) => a.originalIndex - b.originalIndex);
            const nextStopDisplayEl = document.getElementById('nextStopDisplay');
            if (currentTrackingStopIndex < orderedStopsToUse.length) {
                const nextStop = orderedStopsToUse[currentTrackingStopIndex];
                let timeDisplay = nextStop.time || 'N/A';
                if(nextStop.manuallySetTime && nextStop.time) timeDisplay += " (M)";
                nextStopDisplayEl.textContent = `${nextStop.name} (${timeDisplay})`;
            } else if (orderedStopsToUse.length > 0) { // Solo mostrar completada si había paradas
                nextStopDisplayEl.textContent = "RUTA COMPLETADA";
            } else {
                 nextStopDisplayEl.textContent = "-";
            }
        }


        // --- FUNCIONES UTILITARIAS ---
        function haversineDistance(coords1, coords2) { 
            if (!coords1 || !coords2 || typeof coords1.lat !== 'number' || typeof coords1.lng !== 'number' || typeof coords2.lat !== 'number' || typeof coords2.lng !== 'number') {
                return Infinity; 
            }
            const R = 6371e3; 
            const lat1 = coords1.lat * Math.PI/180;
            const lat2 = coords2.lat * Math.PI/180;
            const deltaLat = (coords2.lat-coords1.lat) * Math.PI/180;
            const deltaLng = (coords2.lng-coords1.lng) * Math.PI/180;

            const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                      Math.cos(lat1) * Math.cos(lat2) *
                      Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; 
        }

        function timeToSeconds(timeStr) { 
            if (!timeStr || typeof timeStr !== 'string' || !isValidTime(timeStr)) return NaN; // Importante devolver NaN si es invalido
            const parts = timeStr.split(':');
            const hours = parseInt(parts[0], 10);
            const minutes = parseInt(parts[1], 10);
            const seconds = parts[2] ? (parseInt(parts[2], 10)) : 0;
            return hours * 3600 + minutes * 60 + seconds;
        }

        function secondsToTime(totalSeconds) { 
            if (isNaN(totalSeconds) || totalSeconds < 0) return "Err"; // Manejar tiempos inválidos
            const hours = Math.floor(totalSeconds / 3600) % 24; // Asegurar que las horas no pasen de 23
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }
        
        function getCurrentHHMMSS() {
            const now = new Date();
            return `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`;
        }

        function isValidTime(timeStr) {
            if (!timeStr) return false; 
            return /^([01]\d|2[0-3]):([0-5]\d)$/.test(timeStr) || /^([01]\d|2[0-3]):([0-5]\d):([0-5]\d)$/.test(timeStr);
        }

    </script>
</body>
</html>
