<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        /* Reset y Estilos Base */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: Arial, sans-serif; /* Cambiado a Arial según la última restricción */
            background-color: #000000;
            color: #FFFFFF;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* Evitar scroll general */
        }
        #map {
            height: 50vh; /* Mitad superior para el mapa */
            width: 100%;
            background-color: #333; /* Placeholder color si el mapa no carga */
        }
        #controls {
            height: 50vh; /* Mitad inferior para controles */
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Contenedores de secciones */
        .control-section {
            background-color: #1a1a1a;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #333;
        }
        .control-section h3 {
            margin-top: 0;
            margin-bottom: 8px;
            color: #00bcd4; /* Un color de acento */
        }

        /* Formularios y Botones */
        input[type="text"], input[type="time"], select {
            width: calc(100% - 10px);
            padding: 8px;
            margin-bottom: 8px;
            background-color: #222;
            color: #fff;
            border: 1px solid #444;
            border-radius: 3px;
        }
        button {
            padding: 10px 15px;
            background-color: #007bff; /* Azul primario */
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.danger {
            background-color: #dc3545; /* Rojo para borrar */
        }
        button.danger:hover {
            background-color: #c82333;
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        /* Lista de Paradas */
        #stopsList {
            list-style: none;
            padding: 0;
        }
        #stopsList li {
            background-color: #282828;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        #stopsList li.next-stop-highlight {
            background-color: #00bcd4;
            color: #000;
            font-weight: bold;
        }

        /* Info de Seguimiento */
        #trackingInfo {
            font-size: 1.1em;
        }
        #delayStatus.adelantado {
            color: #28a745; /* Verde */
            font-weight: bold;
        }
        #delayStatus.atrasado {
            color: #dc3545; /* Rojo */
            font-weight: bold;
        }
        #delayStatus.a-tiempo {
            color: #FFFFFF;
        }

        /* Checkboxes */
        label {
            margin-right: 10px;
        }
        
        /* Ocultar elementos */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <div id="controls">
        <!-- Sección Creación de Ruta -->
        <div class="control-section">
            <h3>Crear Ruta</h3>
            <p id="routeCreationInstructions">Toca el mapa para agregar: 1. Inicio, 2. Final, 3. Paradas Intermedias (opcional).</p>
            <input type="text" id="stopName" placeholder="Nombre de la parada (ej: Terminal)">
            <input type="time" id="stopTime">
            <button id="addStopButton" disabled>Añadir Parada (selecciona en mapa)</button>
            <button id="confirmRouteButton" disabled>Confirmar y Crear Ruta</button>
            <button id="resetRouteBuilderButton">Resetear Creación</button>
            <br>
            <label for="autoCalcTimes">Calcular horarios intermedios autom.:</label>
            <input type="checkbox" id="autoCalcTimes" checked>
        </div>

        <!-- Sección Ver Ruta Actual -->
        <div class="control-section" id="currentRouteSection" class="hidden">
            <h3>Ruta Actual</h3>
            <ul id="stopsList"></ul>
        </div>

        <!-- Sección Guardar/Cargar Rutas -->
        <div class="control-section">
            <h3>Gestión de Rutas</h3>
            <input type="text" id="routeName" placeholder="Nombre para guardar la ruta">
            <button id="saveRouteButton" disabled>Guardar Ruta Actual</button>
            <br>
            <select id="savedRoutesList"></select>
            <button id="loadRouteButton">Cargar Ruta</button>
            <button id="deleteRouteButton" class="danger">Borrar Ruta Seleccionada</button>
        </div>
        
        <!-- Sección Cola de Rutas -->
        <div class="control-section">
            <h3>Cola de Rutas</h3>
            <ul id="routeQueueList"></ul>
            <button id="addCurrentToQueueButton" disabled>Añadir Ruta Actual a Cola</button>
            <button id="clearQueueButton">Limpiar Cola</button>
            <label for="autoStartNextRoute">Iniciar siguiente automáticamente:</label>
            <input type="checkbox" id="autoStartNextRoute" checked>
        </div>

        <!-- Sección Seguimiento -->
        <div class="control-section">
            <h3>Seguimiento en Tiempo Real</h3>
            <button id="startTrackingButton" disabled>Iniciar Seguimiento</button>
            <button id="stopTrackingButton" disabled>Detener Seguimiento</button>
            <div id="trackingInfo" class="hidden">
                <p>Velocidad: <span id="speedDisplay">0</span> km/h</p>
                <p>Próxima Parada: <span id="nextStopDisplay">-</span></p>
                <p>Desvío Horario: <span id="delayStatus">00:00</span></p>
            </div>
            <label for="manualAdvanceStop">Control manual de paradas:</label>
            <input type="checkbox" id="manualAdvanceStop">
            <button id="prevStopButton" disabled>Parada Anterior</button>
            <button id="nextStopButton" disabled>Parada Siguiente</button>
        </div>
    </div>

    <script>
        // Variables Globales
        let map;
        let tempStops = []; // Para la creación de rutas: [{latlng, name, time, type}]
        let currentRoute = null; // La ruta activa: {name, stops: [{latlng, name, time, type, scheduledTimeMs}]}
        let stopMarkersLayer = L.featureGroup();
        let routePolylineLayer = L.featureGroup();
        let currentPositionMarker = null;
        let watchId = null;
        let trackingIntervalId = null;
        let nextStopIndex = 0;
        let isTracking = false;
        let routeQueue = []; // [{name, stops}]

        // Elementos del DOM
        const routeCreationInstructionsEl = document.getElementById('routeCreationInstructions');
        const stopNameEl = document.getElementById('stopName');
        const stopTimeEl = document.getElementById('stopTime');
        const addStopButton = document.getElementById('addStopButton');
        const confirmRouteButton = document.getElementById('confirmRouteButton');
        const resetRouteBuilderButton = document.getElementById('resetRouteBuilderButton');
        const autoCalcTimesEl = document.getElementById('autoCalcTimes');
        
        const currentRouteSectionEl = document.getElementById('currentRouteSection');
        const stopsListEl = document.getElementById('stopsList');
        
        const routeNameEl = document.getElementById('routeName');
        const saveRouteButton = document.getElementById('saveRouteButton');
        const savedRoutesListEl = document.getElementById('savedRoutesList');
        const loadRouteButton = document.getElementById('loadRouteButton');
        const deleteRouteButton = document.getElementById('deleteRouteButton');

        const routeQueueListEl = document.getElementById('routeQueueList');
        const addCurrentToQueueButton = document.getElementById('addCurrentToQueueButton');
        const clearQueueButton = document.getElementById('clearQueueButton');
        const autoStartNextRouteEl = document.getElementById('autoStartNextRoute');

        const startTrackingButton = document.getElementById('startTrackingButton');
        const stopTrackingButton = document.getElementById('stopTrackingButton');
        const trackingInfoEl = document.getElementById('trackingInfo');
        const speedDisplayEl = document.getElementById('speedDisplay');
        const nextStopDisplayEl = document.getElementById('nextStopDisplay');
        const delayStatusEl = document.getElementById('delayStatus');
        const manualAdvanceStopEl = document.getElementById('manualAdvanceStop');
        const prevStopButton = document.getElementById('prevStopButton');
        const nextStopButton = document.getElementById('nextStopButton');

        // --- INICIALIZACIÓN ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadSavedRoutesList();
            updateButtonStates();
            
            addStopButton.addEventListener('click', handleAddStop);
            confirmRouteButton.addEventListener('click', handleConfirmRoute);
            resetRouteBuilderButton.addEventListener('click', resetRouteBuilder);

            saveRouteButton.addEventListener('click', saveRoute);
            loadRouteButton.addEventListener('click', loadRoute);
            deleteRouteButton.addEventListener('click', deleteRoute);

            addCurrentToQueueButton.addEventListener('click', addCurrentRouteToQueue);
            clearQueueButton.addEventListener('click', clearRouteQueue);

            startTrackingButton.addEventListener('click', startTracking);
            stopTrackingButton.addEventListener('click', stopTracking);

            manualAdvanceStopEl.addEventListener('change', () => {
                updateButtonStates();
                if (isTracking && !manualAdvanceStopEl.checked) { // si se desactiva manual, recalcular parada auto
                    determineNextStopAuto(currentPositionMarker.getLatLng());
                }
            });
            prevStopButton.addEventListener('click', () => advanceStopManual(-1));
            nextStopButton.addEventListener('click', () => advanceStopManual(1));
        });

        function initMap() {
            map = L.map('map').setView([ -34.6037, -58.3816 ], 13); // Centro en Buenos Aires
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            stopMarkersLayer.addTo(map);
            routePolylineLayer.addTo(map);

            map.on('click', onMapClick);
        }

        function updateButtonStates() {
            // Creación de ruta
            addStopButton.disabled = !stopNameEl.value || (tempStops.length > 0 && tempStops.length < 2 && !stopTimeEl.value); // Necesita nombre. Tiempo obligatorio para inicio/fin
            if (tempStops.length === 0 || tempStops.length === 1) { // Inicio o Fin
                stopTimeEl.required = true;
                stopTimeEl.disabled = false;
            } else { // Intermedia
                stopTimeEl.required = !autoCalcTimesEl.checked;
                stopTimeEl.disabled = autoCalcTimesEl.checked;
            }
            confirmRouteButton.disabled = tempStops.length < 2; // Necesita al menos inicio y fin

            // Gestión de rutas
            saveRouteButton.disabled = !currentRoute || !routeNameEl.value;
            loadRouteButton.disabled = savedRoutesListEl.options.length === 0;
            deleteRouteButton.disabled = savedRoutesListEl.options.length === 0;
            
            // Cola
            addCurrentToQueueButton.disabled = !currentRoute;

            // Seguimiento
            startTrackingButton.disabled = !currentRoute || isTracking;
            stopTrackingButton.disabled = !isTracking;
            prevStopButton.disabled = !isTracking || !manualAdvanceStopEl.checked || nextStopIndex <= 0;
            nextStopButton.disabled = !isTracking || !manualAdvanceStopEl.checked || nextStopIndex >= currentRoute.stops.length -1;
        }
        
        stopNameEl.addEventListener('input', updateButtonStates);
        stopTimeEl.addEventListener('input', updateButtonStates);
        routeNameEl.addEventListener('input', updateButtonStates);
        autoCalcTimesEl.addEventListener('change', updateButtonStates);

        // --- CREACIÓN DE RUTA ---
        let lastClickedLatLng = null;
        function onMapClick(e) {
            lastClickedLatLng = e.latlng;
            addStopButton.disabled = false; // Habilitar para añadir tras clic
            stopNameEl.focus();
            alert("Punto seleccionado en el mapa. Ingresa nombre y hora (si aplica) y pulsa 'Añadir Parada'.");
            updateButtonStates(); // Re-evaluar si el tiempo es necesario
        }
        
        function handleAddStop() {
            if (!lastClickedLatLng) {
                alert("Primero selecciona un punto en el mapa.");
                return;
            }
            const name = stopNameEl.value.trim();
            const time = stopTimeEl.value;

            if (!name) {
                alert("Por favor, ingresa un nombre para la parada.");
                return;
            }

            let type;
            if (tempStops.length === 0) type = 'inicio';
            else if (tempStops.length === 1) type = 'final';
            else type = 'intermedia';

            if ((type === 'inicio' || type === 'final') && !time) {
                alert("Debes ingresar un horario para la parada de inicio y final.");
                return;
            }
            if (type === 'intermedia' && !autoCalcTimesEl.checked && !time) {
                alert("Debes ingresar un horario para la parada intermedia o activar el cálculo automático.");
                return;
            }

            tempStops.push({ latlng: lastClickedLatLng, name, time: time || null, type });
            
            drawTemporaryStopMarker(lastClickedLatLng, type, tempStops.length);
            updateRouteCreationInstructions();
            
            stopNameEl.value = '';
            stopTimeEl.value = '';
            lastClickedLatLng = null;
            addStopButton.disabled = true;
            updateButtonStates();
        }
        
        function drawTemporaryStopMarker(latlng, type, index) {
            let icon;
            const randomColor = `hsl(${Math.random() * 360}, 100%, 70%)`;
            if (type === 'inicio') {
                icon = L.divIcon({ className: 'custom-div-icon', html: `<span style="background-color:${randomColor}; color:white; padding:5px; border-radius:50%;">I</span>`, iconSize: [30,30], iconAnchor: [15,15]});
            } else if (type === 'final') {
                icon = L.divIcon({ className: 'custom-div-icon', html: `<span style="background-color:${randomColor}; color:white; padding:5px; border-radius:50%;">F</span>`, iconSize: [30,30], iconAnchor: [15,15]});
            } else {
                icon = L.divIcon({ className: 'custom-div-icon', html: `<span style="background-color:${randomColor}; color:white; padding:5px; border-radius:50%;">${index - 1}</span>`, iconSize: [30,30], iconAnchor: [15,15]});
            }
            L.marker(latlng, { icon }).addTo(stopMarkersLayer).bindPopup(`${type}: ${name || 'Parada ' + index}`);
        }

        function updateRouteCreationInstructions() {
            if (tempStops.length === 0) routeCreationInstructionsEl.textContent = "Toca el mapa para agregar INICIO.";
            else if (tempStops.length === 1) routeCreationInstructionsEl.textContent = "Toca el mapa para agregar FINAL.";
            else routeCreationInstructionsEl.textContent = "Toca el mapa para agregar PARADAS INTERMEDIAS (opcional). Pulsa 'Confirmar Ruta' cuando termines.";
        }

        function resetRouteBuilder() {
            tempStops = [];
            stopMarkersLayer.clearLayers();
            routePolylineLayer.clearLayers();
            stopNameEl.value = '';
            stopTimeEl.value = '';
            lastClickedLatLng = null;
            updateRouteCreationInstructions();
            updateButtonStates();
        }

        function handleConfirmRoute() {
            if (tempStops.length < 2) {
                alert("Necesitas al menos una parada de inicio y una de final.");
                return;
            }
            // Reordenar: inicio -> intermedias -> final
            const start = tempStops.find(s => s.type === 'inicio');
            const end = tempStops.find(s => s.type === 'final');
            const intermediates = tempStops.filter(s => s.type === 'intermedia');
            
            currentRoute = { name: "Ruta sin nombre", stops: [start, ...intermediates, end] };

            // Convertir horarios a milisegundos desde medianoche para cálculo
            currentRoute.stops.forEach(stop => {
                if (stop.time) {
                    stop.scheduledTimeMs = timeToMs(stop.time);
                }
            });

            if (autoCalcTimesEl.checked) {
                calculateIntermediateTimes();
            }
            
            displayRoute(currentRoute);
            resetRouteBuilder(); // Limpia la UI de creación
            currentRouteSectionEl.classList.remove('hidden');
            updateButtonStates();
        }

        function timeToMs(timeStr) { // "HH:MM"
            if (!timeStr) return null;
            const [hours, minutes] = timeStr.split(':').map(Number);
            return (hours * 60 + minutes) * 60 * 1000;
        }

        function msToTime(ms) {
            if (ms === null || ms === undefined) return "--:--";
            const totalMinutes = Math.floor(ms / (60 * 1000));
            const hours = String(Math.floor(totalMinutes / 60)).padStart(2, '0');
            const minutes = String(totalMinutes % 60).padStart(2, '0');
            return `${hours}:${minutes}`;
        }
        
        function calculateIntermediateTimes() {
            if (!currentRoute || currentRoute.stops.length < 2) return;

            const startStop = currentRoute.stops[0];
            const endStop = currentRoute.stops[currentRoute.stops.length - 1];

            if (!startStop.scheduledTimeMs || !endStop.scheduledTimeMs) {
                alert("Error: Inicio y Fin deben tener horarios para cálculo automático.");
                currentRoute.stops.forEach(s => { if (s.type === 'intermedia') s.time = null; s.scheduledTimeMs = null; }); // Limpiar tiempos intermedios
                return;
            }

            const totalRouteTimeMs = endStop.scheduledTimeMs - startStop.scheduledTimeMs;
            if (totalRouteTimeMs <= 0) {
                 alert("Error: Hora de fin debe ser posterior a hora de inicio para cálculo automático.");
                 currentRoute.stops.forEach(s => { if (s.type === 'intermedia') s.time = null; s.scheduledTimeMs = null; });
                 return;
            }

            let totalDistance = 0;
            const segmentDistances = [];
            for (let i = 0; i < currentRoute.stops.length - 1; i++) {
                const dist = L.latLng(currentRoute.stops[i].latlng).distanceTo(L.latLng(currentRoute.stops[i+1].latlng));
                segmentDistances.push(dist);
                totalDistance += dist;
            }
            
            if (totalDistance === 0 && currentRoute.stops.length > 2) { // Evitar división por cero si solo hay inicio/fin en el mismo lugar pero con intermedias
                console.warn("Distancia total es cero, no se pueden calcular tiempos intermedios proporcionalmente.");
                currentRoute.stops.forEach((stop, i) => {
                    if (i > 0 && i < currentRoute.stops.length -1) { // intermedias
                         stop.time = msToTime(startStop.scheduledTimeMs); // O alguna otra lógica
                         stop.scheduledTimeMs = startStop.scheduledTimeMs;
                    }
                });
                return;
            }
            if (totalDistance === 0) return; // No hay nada que calcular si solo hay 2 paradas en el mismo sitio

            let accumulatedDistance = 0;
            for (let i = 1; i < currentRoute.stops.length - 1; i++) { // Iterar solo sobre paradas intermedias
                accumulatedDistance += segmentDistances[i-1];
                const timeRatio = accumulatedDistance / totalDistance;
                const intermediateTimeMs = startStop.scheduledTimeMs + (totalRouteTimeMs * timeRatio);
                currentRoute.stops[i].scheduledTimeMs = intermediateTimeMs;
                currentRoute.stops[i].time = msToTime(intermediateTimeMs);
            }
        }

        // --- VISUALIZACIÓN DE RUTA ---
        function displayRoute(route) {
            stopMarkersLayer.clearLayers();
            routePolylineLayer.clearLayers();
            stopsListEl.innerHTML = '';

            if (!route || !route.stops || route.stops.length === 0) {
                currentRouteSectionEl.classList.add('hidden');
                return;
            }
            
            currentRouteSectionEl.classList.remove('hidden');
            const latlngs = route.stops.map(stop => stop.latlng);

            route.stops.forEach((stop, index) => {
                const randomColor = `hsl(${Math.random() * 360}, 100%, 70%)`; // Diferente para cada carga de ruta
                let iconHtml;
                if (stop.type === 'inicio') iconHtml = `<span style="background-color:${randomColor}; color:white; padding:5px; border-radius:50%;">I</span>`;
                else if (stop.type === 'final') iconHtml = `<span style="background-color:${randomColor}; color:white; padding:5px; border-radius:50%;">F</span>`;
                else iconHtml = `<span style="background-color:${randomColor}; color:white; padding:5px; border-radius:50%;">${index}</span>`;
                
                const icon = L.divIcon({ className: 'custom-div-icon', html: iconHtml, iconSize: [30,30], iconAnchor: [15,15] });
                L.marker(stop.latlng, { icon }).addTo(stopMarkersLayer)
                    .bindPopup(`${stop.name} (${stop.type}) - ${stop.time || 'N/A'}`);

                const li = document.createElement('li');
                li.textContent = `${index + 1}. ${stop.name} (${stop.type}) - ${stop.time || (stop.scheduledTimeMs ? msToTime(stop.scheduledTimeMs) : 'N/A')}`;
                li.dataset.stopIndex = index;
                stopsListEl.appendChild(li);
            });

            if (latlngs.length >= 2) {
                L.polyline(latlngs, { color: 'blue' }).addTo(routePolylineLayer);
                map.fitBounds(L.latLngBounds(latlngs), { padding: [50, 50] });
            } else if (latlngs.length === 1) {
                map.setView(latlngs[0], 15);
            }
            updateButtonStates();
        }
        
        // --- PERSISTENCIA DE DATOS ---
        function saveRoute() {
            if (!currentRoute) {
                alert("No hay ruta actual para guardar.");
                return;
            }
            const name = routeNameEl.value.trim();
            if (!name) {
                alert("Por favor, ingresa un nombre para la ruta.");
                return;
            }
            currentRoute.name = name; // Asignar nombre
            try {
                // Guardar solo datos necesarios, no objetos Leaflet
                const storableRoute = {
                    name: currentRoute.name,
                    stops: currentRoute.stops.map(s => ({
                        latlng: { lat: s.latlng.lat, lng: s.latlng.lng }, // Guardar como objeto simple
                        name: s.name,
                        time: s.time,
                        type: s.type,
                        scheduledTimeMs: s.scheduledTimeMs
                    }))
                };
                localStorage.setItem('route_' + name, JSON.stringify(storableRoute));
                alert(`Ruta "${name}" guardada.`);
                loadSavedRoutesList();
                routeNameEl.value = ''; // Limpiar para el próximo guardado
            } catch (e) {
                alert("Error al guardar la ruta. Posiblemente el almacenamiento está lleno.");
                console.error("Error saving route:", e);
            }
            updateButtonStates();
        }

        function loadSavedRoutesList() {
            savedRoutesListEl.innerHTML = '';
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('route_')) {
                    const routeName = key.substring('route_'.length);
                    const option = document.createElement('option');
                    option.value = routeName;
                    option.textContent = routeName;
                    savedRoutesListEl.appendChild(option);
                }
            }
            updateButtonStates();
        }

        function loadRoute() {
            const routeName = savedRoutesListEl.value;
            if (!routeName) {
                alert("Selecciona una ruta para cargar.");
                return;
            }
            const savedData = localStorage.getItem('route_' + routeName);
            if (savedData) {
                const parsedData = JSON.parse(savedData);
                // Reconstruir latlng para Leaflet
                parsedData.stops.forEach(s => s.latlng = L.latLng(s.latlng.lat, s.latlng.lng));
                currentRoute = parsedData;
                displayRoute(currentRoute);
                routeNameEl.value = currentRoute.name; // Poner nombre en input para fácil re-guardado
                alert(`Ruta "${routeName}" cargada.`);
            } else {
                alert("No se pudo cargar la ruta.");
            }
            updateButtonStates();
        }

        function deleteRoute() {
            const routeName = savedRoutesListEl.value;
            if (!routeName) {
                alert("Selecciona una ruta para borrar.");
                return;
            }
            if (confirm(`¿Estás seguro de que quieres borrar la ruta "${routeName}"?`)) {
                localStorage.removeItem('route_' + routeName);
                loadSavedRoutesList();
                alert(`Ruta "${routeName}" borrada.`);
                // Si la ruta borrada era la actual, limpiarla
                if (currentRoute && currentRoute.name === routeName) {
                    currentRoute = null;
                    displayRoute(null);
                    routeNameEl.value = '';
                }
            }
            updateButtonStates();
        }

        // --- COLA DE RUTAS ---
        function addCurrentRouteToQueue() {
            if (!currentRoute) {
                alert("Carga o crea una ruta primero.");
                return;
            }
            // Clonar la ruta para evitar problemas si se modifica la actual
            const routeCopy = JSON.parse(JSON.stringify(currentRoute));
            // Reconstruir latlngs para Leaflet si es necesario (aunque para la cola solo se necesita la data)
            routeCopy.stops.forEach(s => s.latlng = L.latLng(s.latlng.lat, s.latlng.lng));

            routeQueue.push(routeCopy);
            updateRouteQueueUI();
            alert(`Ruta "${routeCopy.name}" añadida a la cola.`);
        }

        function updateRouteQueueUI() {
            routeQueueListEl.innerHTML = '';
            routeQueue.forEach((route, index) => {
                const li = document.createElement('li');
                li.textContent = `${index + 1}. ${route.name}`;
                routeQueueListEl.appendChild(li);
            });
        }

        function clearRouteQueue() {
            routeQueue = [];
            updateRouteQueueUI();
            alert("Cola de rutas limpiada.");
        }
        
        function startNextRouteFromQueue() {
            if (routeQueue.length > 0) {
                currentRoute = routeQueue.shift(); // Tomar y remover la primera de la cola
                updateRouteQueueUI();
                displayRoute(currentRoute);
                alert(`Iniciando siguiente ruta de la cola: "${currentRoute.name}"`);
                startTracking(); // Iniciar seguimiento de la nueva ruta
            } else {
                alert("No hay más rutas en la cola.");
                currentRoute = null; // No hay ruta activa
                displayRoute(null);
            }
        }

        // --- SEGUIMIENTO EN TIEMPO REAL ---
        function startTracking() {
            if (!currentRoute || currentRoute.stops.length < 2) {
                alert("Carga o crea una ruta válida (con al menos inicio y fin) antes de iniciar el seguimiento.");
                return;
            }
            if (isTracking) {
                alert("El seguimiento ya está activo.");
                return;
            }

            isTracking = true;
            trackingInfoEl.classList.remove('hidden');
            nextStopIndex = 0; // Empezar desde la primera parada (índice 0)
            
            // Asegurarse que todos los scheduledTimeMs están calculados si no lo estuvieron
            currentRoute.stops.forEach(stop => {
                if (stop.time && !stop.scheduledTimeMs) {
                    stop.scheduledTimeMs = timeToMs(stop.time);
                }
            });


            if (navigator.geolocation) {
                const geoOptions = { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 };
                watchId = navigator.geolocation.watchPosition(geolocationSuccess, geolocationError, geoOptions);
                // El intervalo para actualizar el desvío es independiente del de geolocalización
                // para que se actualice incluso si la posición no cambia pero el tiempo sí.
                if (trackingIntervalId) clearInterval(trackingIntervalId);
                trackingIntervalId = setInterval(updateDelayStatusRealtime, 1000); // Actualiza cada segundo
            } else {
                alert("La geolocalización no es soportada por tu navegador.");
                isTracking = false;
            }
            updateButtonStates();
            updateNextStopDisplay();
        }

        function stopTracking(completed = false) {
            if (!isTracking) return;

            isTracking = false;
            if (watchId) navigator.geolocation.clearWatch(watchId);
            watchId = null;
            if (trackingIntervalId) clearInterval(trackingIntervalId);
            trackingIntervalId = null;

            if (currentPositionMarker) {
                map.removeLayer(currentPositionMarker);
                currentPositionMarker = null;
            }
            trackingInfoEl.classList.add('hidden');
            speedDisplayEl.textContent = '0';
            delayStatusEl.textContent = '00:00';
            delayStatusEl.className = '';
            nextStopDisplayEl.textContent = '-';
            highlightNextStopInList(null); // Quitar resaltado
            
            updateButtonStates();
            alert("Seguimiento detenido.");

            if (completed) {
                if (autoStartNextRouteEl.checked && routeQueue.length > 0) {
                    startNextRouteFromQueue();
                } else if (routeQueue.length > 0) {
                    alert("Ruta completada. Hay más rutas en la cola. Iníciala manualmente si deseas.");
                } else {
                    alert("Ruta completada. No hay más rutas en la cola.");
                }
            }
        }

        function geolocationSuccess(position) {
            const latlng = L.latLng(position.coords.latitude, position.coords.longitude);
            
            if (!currentPositionMarker) {
                const driverIcon = L.divIcon({ className: 'custom-div-icon', html: '<span style="font-size:24px;">🚌</span>', iconSize: [30,30], iconAnchor: [15,15] });
                currentPositionMarker = L.marker(latlng, {icon: driverIcon}).addTo(map);
            } else {
                currentPositionMarker.setLatLng(latlng);
            }
            map.panTo(latlng); // Opcional: centrar mapa en el chofer

            const speedKmh = position.coords.speed ? (position.coords.speed * 3.6).toFixed(1) : 0;
            speedDisplayEl.textContent = speedKmh;

            if (!manualAdvanceStopEl.checked) {
                determineNextStopAuto(latlng);
            }
            // El cálculo de desvío ahora se hace en updateDelayStatusRealtime
        }
        
        function updateDelayStatusRealtime() {
            if (!isTracking || !currentRoute || !currentPositionMarker) return;
            calculateAndDisplayDelay(currentPositionMarker.getLatLng());
        }

        function geolocationError(error) {
            console.warn(`ERROR(${error.code}): ${error.message}`);
            // Podrías mostrar un mensaje al usuario
            // stopTracking(); // Opcional: detener si hay error persistente
        }

        function determineNextStopAuto(currentLatLng) {
            if (!currentRoute || currentRoute.stops.length === 0) return;

            let closestStopIndex = -1;
            let minDistance = Infinity;
            
            // Considerar solo paradas futuras a partir de nextStopIndex
            // O buscar la más cercana en general y luego ver si tiene sentido como "siguiente"
            // Para simplificar, vamos a ver si estamos cerca de la `nextStopIndex` actual.
            
            const currentTargetStop = currentRoute.stops[nextStopIndex];
            if (!currentTargetStop) return; // Ruta terminada o error

            const distanceToNext = currentLatLng.distanceTo(L.latLng(currentTargetStop.latlng));
            const PROXIMITY_THRESHOLD_METERS = 50; // 50 metros para considerar llegada

            if (distanceToNext < PROXIMITY_THRESHOLD_METERS) {
                if (nextStopIndex < currentRoute.stops.length - 1) {
                    nextStopIndex++;
                    updateNextStopDisplay();
                    alert(`Llegada detectada a: ${currentTargetStop.name}. Próxima: ${currentRoute.stops[nextStopIndex].name}`);
                } else { // Llegó a la última parada
                    alert(`Llegada a destino final: ${currentTargetStop.name}.`);
                    stopTracking(true); // Ruta completada
                    return;
                }
            } else {
                 // Lógica para saltar paradas si se pasa de largo (más complejo)
                 // Podría buscar la parada más cercana en la dirección de viaje.
                 // Por ahora, nos mantenemos con la detección simple de proximidad a la siguiente.
            }
        }
        
        function advanceStopManual(direction) { // direction: 1 para siguiente, -1 para anterior
            if (!isTracking || !currentRoute) return;
            
            const newIndex = nextStopIndex + direction;
            if (newIndex >= 0 && newIndex < currentRoute.stops.length) {
                nextStopIndex = newIndex;
                updateNextStopDisplay();
                if (newIndex === currentRoute.stops.length - 1) {
                     alert(`Avanzaste manualmente a la parada final: ${currentRoute.stops[nextStopIndex].name}.`);
                }
            }
            updateButtonStates(); // Actualizar botones Anterior/Siguiente
        }

        function updateNextStopDisplay() {
            if (!currentRoute || !currentRoute.stops[nextStopIndex]) {
                nextStopDisplayEl.textContent = '-';
                highlightNextStopInList(null);
                return;
            }
            const stop = currentRoute.stops[nextStopIndex];
            nextStopDisplayEl.textContent = `${stop.name} (${stop.time || msToTime(stop.scheduledTimeMs) || 'N/A'})`;
            highlightNextStopInList(nextStopIndex);
        }

        function highlightNextStopInList(indexToHighlight) {
            const items = stopsListEl.querySelectorAll('li');
            items.forEach((item, idx) => {
                if (idx === indexToHighlight) {
                    item.classList.add('next-stop-highlight');
                } else {
                    item.classList.remove('next-stop-highlight');
                }
            });
        }
        
        function calculateAndDisplayDelay(currentLatLng) {
            if (nextStopIndex < 0 || nextStopIndex >= currentRoute.stops.length) {
                delayStatusEl.textContent = "N/A (fuera de tramo)";
                delayStatusEl.className = '';
                return;
            }

            const previousStopIndex = Math.max(0, nextStopIndex -1); // Para el inicio, previousStop es la misma start
            const fromStop = currentRoute.stops[previousStopIndex];
            const toStop = currentRoute.stops[nextStopIndex];

            if (!fromStop || !toStop || fromStop.scheduledTimeMs === null || toStop.scheduledTimeMs === null) {
                delayStatusEl.textContent = "N/A (horarios no definidos)";
                delayStatusEl.className = '';
                return;
            }
            
            // Si estamos en la primera parada y aún no salimos, el desvío es respecto a la hora de salida.
            if (nextStopIndex === 0) {
                const nowMs = timeToMs(new Date().toLocaleTimeString('en-GB', {hour: '2-digit', minute:'2-digit'}));
                const scheduledDepartureMs = fromStop.scheduledTimeMs;
                const delayMs = nowMs - scheduledDepartureMs; // Positivo si es más tarde (atrasado)

                displayDelay(delayMs * -1); // Invertir para que positivo sea adelantado
                return;
            }
            
            // Para tramos intermedios o el tramo hacia la primera parada (si ya se "salió")
            const segmentTotalDistance = L.latLng(fromStop.latlng).distanceTo(L.latLng(toStop.latlng));
            const segmentScheduledTimeMs = toStop.scheduledTimeMs - fromStop.scheduledTimeMs;

            if (segmentScheduledTimeMs < 0) { // Hora de "toStop" es anterior a "fromStop", error en datos
                delayStatusEl.textContent = "Error horario tramo";
                delayStatusEl.className = 'atrasado';
                return;
            }
            if (segmentTotalDistance <= 1) { // Evitar división por cero o distancias muy pequeñas
                 // Si la distancia es negligible, el tiempo esperado es el de la parada 'fromStop' hasta que llegue a 'toStop'.
                 // O, si ya pasó 'fromStop', comparar contra 'toStop.scheduledTimeMs'
                const nowMs = timeToMs(new Date().toLocaleTimeString('en-GB', {hour: '2-digit', minute:'2-digit'}));
                const delayMs = nowMs - toStop.scheduledTimeMs; // Atraso respecto a la llegada a la siguiente parada
                displayDelay(delayMs * -1);
                return;
            }

            const distanceFromFromStop = L.latLng(fromStop.latlng).distanceTo(currentLatLng);
            
            // Proyección en el segmento (simplificado, asume que está en la línea)
            // Una forma más robusta sería proyectar el punto actual sobre el segmento de línea.
            // Pero para este caso, la distancia directa a `fromStop` puede ser una aproximación.
            // Es importante que `distanceFromFromStop` no exceda `segmentTotalDistance`.
            const distanceCoveredInSegment = Math.min(distanceFromFromStop, segmentTotalDistance);
            
            const percentageCovered = distanceCoveredInSegment / segmentTotalDistance;
            
            const timeElapsedAsPerScheduleMs = segmentScheduledTimeMs * percentageCovered;
            const expectedTimeAtCurrentPositionMs = fromStop.scheduledTimeMs + timeElapsedAsPerScheduleMs;
            
            const currentTimeMs = timeToMs(new Date().toLocaleTimeString('en-GB', {hour: '2-digit', minute:'2-digit'}));
            
            const delayMs = expectedTimeAtCurrentPositionMs - currentTimeMs; // Positivo = adelantado, Negativo = atrasado

            displayDelay(delayMs);
        }

        function displayDelay(delayMs) {
            const absDelaySec = Math.abs(Math.round(delayMs / 1000));
            const minutes = String(Math.floor(absDelaySec / 60)).padStart(2, '0');
            const seconds = String(absDelaySec % 60).padStart(2, '0');
            const sign = delayMs >= 0 ? '+' : '-';

            delayStatusEl.textContent = `${sign}${minutes}:${seconds}`;

            if (Math.abs(delayMs) < 15000) { // Menos de 15 segundos de desvío = a tiempo
                 delayStatusEl.className = 'a-tiempo';
            } else if (delayMs > 0) {
                delayStatusEl.className = 'adelantado';
            } else {
                delayStatusEl.className = 'atrasado';
            }
        }

    </script>
</body>
</html>
