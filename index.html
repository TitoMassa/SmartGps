<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        /* Estilos CSS (Mayormente sin cambios, ajustes menores para nuevo input/display) */
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; background-color: #f4f4f4; }
        body { display: flex; flex-direction: column; }
        header { background-color: #333; color: white; padding: 8px 15px; text-align: center; flex-shrink: 0; font-size: 1.1em; }
        main { display: flex; flex-direction: column; flex: 1; overflow: hidden; padding: 5px; }
        #map-container { height: 45vh; /* Un poco menos para dar espacio a controles */ display: flex; flex-direction: column; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 10px; flex-shrink: 0; }
        #map-header { padding: 8px; background-color: #eee; border-bottom: 1px solid #ccc; border-radius: 8px 8px 0 0; font-weight: bold; font-size: 0.9em; text-align: center; flex-shrink: 0; }
        #map { flex: 1; border-radius: 0 0 8px 8px; cursor: crosshair; }
        #controls { flex: 1; display: flex; flex-direction: column; gap: 10px; padding: 10px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow-y: auto; width: auto; }
        #add-stop-form, #route-info, #status-section { border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 10px; }
        #status-section { border-bottom: none; margin-bottom: 0; }
        #add-stop-form h3, #route-info h3, #status-section h3 { margin-top: 0; margin-bottom: 8px; font-size: 1em; color: #333; }
        #add-stop-form label { display: block; margin-bottom: 3px; font-weight: bold; font-size: 0.85em; }
        #add-stop-form .time-inputs { display: flex; gap: 10px; margin-bottom: 8px; } /* Contenedor para horas */
        #add-stop-form .time-inputs > div { flex: 1; } /* Cada input de hora ocupa mitad */
        #add-stop-form input[type="text"], #add-stop-form input[type="time"], #add-stop-form input[type="number"],
        #add-stop-form button, #startRouteBtn, #finishRouteBtn {
            width: 100%; padding: 8px 10px; margin-bottom: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9em;
        }
        #add-stop-form input[readonly] { background-color: #e9e9e9; }
        #add-stop-form button, #startRouteBtn, #finishRouteBtn { background-color: #007bff; color: white; border: none; cursor: pointer; transition: background-color 0.3s ease; }
        #add-stop-form button:hover, #startRouteBtn:hover, #finishRouteBtn:hover { background-color: #0056b3; }
        #finishRouteBtn { background-color: #28a745; }
        #finishRouteBtn:hover { background-color: #218838; }
        #startRouteBtn:disabled, #finishRouteBtn:disabled { background-color: #cccccc; cursor: not-allowed; }

        #stops-list { list-style: none; padding: 0; margin: 5px 0 0 0; max-height: 110px; /* Reducido un poco */ overflow-y: auto; border-top: 1px solid #eee; }
        #stops-list li { padding: 5px; /* Más compacto */ border-bottom: 1px solid #eee; font-size: 0.8em; /* Más pequeño */ display: flex; justify-content: space-between; align-items: center; gap: 5px; }
        #stops-list li .stop-details { flex-grow: 1; }
        #stops-list li .stop-times { font-size: 0.9em; color: #555; text-align: right; white-space: nowrap; } /* Mostrar horas juntas */
        #stops-list li button { background-color: #dc3545; color: white; border: none; padding: 2px 5px; border-radius: 3px; cursor: pointer; font-size: 0.75em; flex-shrink: 0; }
        #stops-list li button:hover { background-color: #c82333; }
        #stops-list li.active-stop { background-color: #e0e8ff; font-weight: bold; }
        body.tracking-active #stops-list li button { display: none; }

        #route-indicator { font-size: 0.8em; color: #555; margin-bottom: 5px; text-align: center; font-weight: bold; }
        #status-display { margin-top: 5px; padding: 10px; border-radius: 5px; text-align: center; font-size: 1.3em; /* Reducido */ font-weight: bold; line-height: 1.3; min-height: 4em; /* Espacio para 2 líneas */ display: flex; flex-direction: column; justify-content: center; }
        #status-display .status-info { font-size: 0.8em; font-weight: normal; color: #333; margin-bottom: 4px;}
        #status-display .status-time { font-size: 1.3em; font-weight: bold; } /* Tamaño relativo al contenedor */
        #status-display.on-time { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        #status-display.late { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        #status-display.early { background-color: #cce5ff; color: #004085; border: 1px solid #b8daff; }
        #status-display.idle { background-color: #e2e3e5; color: #383d41; border: 1px solid #d6d8db; font-size: 1em; justify-content: center; }
        #gps-status { font-size: 0.75em; text-align: center; color: #666; margin-top: 5px; padding: 0; }
        .leaflet-popup-content button { padding: 4px 8px; font-size: 0.8em; }
        .leaflet-control-zoom { transform: scale(1.1); transform-origin: top left; }
    </style>
</head>
<body class=""> <!-- Clase 'tracking-active' se gestiona con JS -->

    <header><h1>Smart Move Pro</h1></header>

    <main>
        <div id="map-container">
            <div id="map-header">Toca el mapa para fijar ubicación</div>
            <div id="map"></div>
        </div>

        <div id="controls">
            <div id="status-section">
                <h3>Estado Actual</h3>
                <div id="status-display" class="idle">
                    <span class="status-info">Añade paradas e inicia ruta</span>
                    <span class="status-time">--:--</span>
                </div>
                 <p id="gps-status">GPS: Esperando señal...</p>
            </div>

            <div id="add-stop-form">
                <h3 id="add-stop-title">Añadir Parada (Ruta 1)</h3>
                <label for="stop-lat">Ubicación (Lat/Lng):</label>
                <div style="display: flex; gap: 5px; margin-bottom: 8px;">
                    <input type="number" id="stop-lat" step="any" placeholder="Toca mapa" readonly style="flex: 1;">
                    <input type="number" id="stop-lng" step="any" placeholder="Toca mapa" readonly style="flex: 1;">
                </div>
                <label for="stop-name">Nombre Parada:</label>
                <input type="text" id="stop-name" placeholder="Ej: Parada Centro">
                <div class="time-inputs">
                    <div>
                        <label for="stop-time">Llegada (HH:MM):</label>
                        <input type="time" id="stop-time">
                    </div>
                    <div>
                         <label for="stop-departure-time">Salida (HH:MM):</label>
                        <input type="time" id="stop-departure-time"> <!-- Nuevo Input -->
                    </div>
                </div>
                <button id="addStopBtn">Añadir Parada</button>
                <button id="finishRouteBtn" disabled>Finalizar Ruta / Iniciar Siguiente</button>
            </div>

            <div id="route-info">
                <h3 id="route-list-title">Editando Ruta 1</h3>
                <div id="route-indicator">Total Rutas: 0</div>
                <ul id="stops-list"></ul>
                <button id="startRouteBtn" disabled>Iniciar Seguimiento</button>
            </div>
        </div>
    </main>

    <script>
        // --- Variables Globales ---
        let map;
        let routes = [[]];
        let currentLocationMarker = null;
        let stopMarkers = {};
        let currentRouteIndex = -1;
        let currentStopIndex = -1; // Índice de la *próxima* parada a alcanzar
        let currentRouteBeingBuiltIndex = 0;
        let watchId = null;
        let lastKnownPosition = null;
        const R = 6371;
        let arrivalMarker = null;
        let currentStatusInfo = { phase: 'idle', text: 'Esperando inicio' }; // Para saber qué se está calculando

        // --- Elementos del DOM ---
        const stopNameInput = document.getElementById('stop-name');
        const stopTimeInput = document.getElementById('stop-time');
        const stopDepartureTimeInput = document.getElementById('stop-departure-time'); // Nuevo
        const stopLatInput = document.getElementById('stop-lat');
        const stopLngInput = document.getElementById('stop-lng');
        const addStopBtn = document.getElementById('addStopBtn');
        const finishRouteBtn = document.getElementById('finishRouteBtn');
        const stopsList = document.getElementById('stops-list');
        const startRouteBtn = document.getElementById('startRouteBtn');
        const statusDisplay = document.getElementById('status-display');
        const gpsStatus = document.getElementById('gps-status');
        const addStopTitle = document.getElementById('add-stop-title');
        const routeListTitle = document.getElementById('route-list-title');
        const routeIndicator = document.getElementById('route-indicator');

        // --- Inicialización ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeMap();
            addStopBtn.addEventListener('click', addStop);
            finishRouteBtn.addEventListener('click', finishCurrentRoute);
            startRouteBtn.addEventListener('click', startRouteTracking);
            updateUIBasedOnState();

            navigator.geolocation.getCurrentPosition(
                (pos) => { map.setView([pos.coords.latitude, pos.coords.longitude], 14); updateGPSStatus(`Precisión: ${pos.coords.accuracy.toFixed(0)}m`); },
                () => { map.setView([-34.6037, -58.3816], 12); updateGPSStatus("GPS inicial no disponible."); },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        });

        function initializeMap() {
             map = L.map('map', { zoomControl: true }).setView([-34.6037, -58.3816], 12);
             map.zoomControl.setPosition('bottomright');
             L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OSM', maxZoom: 19 }).addTo(map);
             map.on('click', (e) => {
                stopLatInput.value = e.latlng.lat.toFixed(6);
                stopLngInput.value = e.latlng.lng.toFixed(6);
                 // Feedback visual
                 if (arrivalMarker) map.removeLayer(arrivalMarker);
                 arrivalMarker = L.circleMarker(e.latlng, { radius: 6, color: '#ff4136', fillOpacity: 0.7, weight: 1 }).addTo(map);
                 setTimeout(() => { if (arrivalMarker && map.hasLayer(arrivalMarker)) map.removeLayer(arrivalMarker); arrivalMarker = null; }, 1000);
             });
        }

        // --- Gestión de Paradas y Rutas ---
        function addStop() {
            if (currentRouteIndex !== -1) { alert("No se pueden añadir paradas durante el seguimiento."); return; }

            const arrivalTime = stopTimeInput.value;
            const departureTime = stopDepartureTimeInput.value; // Nuevo
            const lat = parseFloat(stopLatInput.value);
            const lng = parseFloat(stopLngInput.value);

            if (!arrivalTime || !departureTime || isNaN(lat) || isNaN(lng)) {
                alert("Completa ubicación (mapa), hora de llegada y hora de salida.");
                return;
            }

            // Validación simple: salida >= llegada
             const arrivalDate = parseTimeString(arrivalTime);
             const departureDate = parseTimeString(departureTime);
             if (!arrivalDate || !departureDate || departureDate < arrivalDate) {
                  alert("La hora de salida debe ser igual o posterior a la hora de llegada.");
                  return;
             }

            const name = stopNameInput.value.trim() || `Parada (${lat.toFixed(3)})`;
            const stopId = Date.now();
            // Objeto parada ahora incluye departureTime
            const newStop = { id: stopId, name, time: arrivalTime, departureTime: departureTime, lat, lng };

            if (!routes[currentRouteBeingBuiltIndex]) routes[currentRouteBeingBuiltIndex] = [];
            routes[currentRouteBeingBuiltIndex].push(newStop);
            routes[currentRouteBeingBuiltIndex].sort((a, b) => a.time.localeCompare(b.time));

            addStopMarker(newStop);
            clearAddStopForm();
            renderStopsList();
            updateUIBasedOnState();
        }

        function removeStop(stopId) {
            if (currentRouteIndex !== -1) return;
            const routeToEdit = routes[currentRouteBeingBuiltIndex];
            if (!routeToEdit) return;
            const stopIndex = routeToEdit.findIndex(stop => stop.id === stopId);
            if (stopIndex > -1) {
                const removedStop = routeToEdit.splice(stopIndex, 1)[0];
                if (stopMarkers[removedStop.id]) { map.removeLayer(stopMarkers[removedStop.id]); delete stopMarkers[removedStop.id]; }
                renderStopsList();
                updateUIBasedOnState();
            }
        }

        function finishCurrentRoute() {
            if (currentRouteIndex !== -1) return;
            const currentRoute = routes[currentRouteBeingBuiltIndex];
            if (!currentRoute || currentRoute.length === 0) { alert("Añade paradas antes de finalizar."); return; }
            currentRouteBeingBuiltIndex++;
            routes[currentRouteBeingBuiltIndex] = [];
            renderStopsList();
            updateUIBasedOnState();
        }

        function clearAddStopForm() {
             stopNameInput.value = '';
             stopTimeInput.value = '';
             stopDepartureTimeInput.value = ''; // Limpiar nuevo input
             stopLatInput.value = '';
             stopLngInput.value = '';
        }

        function addStopMarker(stop) {
             const routeNum = routes.findIndex(r => r.some(s => s.id === stop.id)) + 1;
             const marker = L.marker([stop.lat, stop.lng]).addTo(map)
                .bindPopup(`<b>${stop.name}</b><br>(Ruta ${routeNum})<br>Lleg: ${stop.time} / Sal: ${stop.departureTime}`);
             stopMarkers[stop.id] = marker;
        }

        // --- Renderizado y UI ---
        function renderStopsList() {
            stopsList.innerHTML = '';
            let routeToDisplay = null;
            let routeNumber = -1;

            if (currentRouteIndex !== -1) {
                routeToDisplay = routes[currentRouteIndex];
                routeNumber = currentRouteIndex + 1;
            } else {
                routeToDisplay = routes[currentRouteBeingBuiltIndex];
                routeNumber = currentRouteBeingBuiltIndex + 1;
            }

            if (routeToDisplay && routeToDisplay.length > 0) {
                routeToDisplay.sort((a, b) => a.time.localeCompare(b.time));
                routeToDisplay.forEach((stop, index) => {
                    const li = document.createElement('li');
                    li.dataset.stopId = stop.id;
                    const removeButtonHtml = currentRouteIndex === -1 ? `<button onclick="removeStop(${stop.id})" aria-label="Eliminar ${stop.name}">X</button>` : '';
                    // Mostrar ambas horas
                    li.innerHTML = `
                        <div class="stop-details">${index + 1}. ${stop.name}</div>
                        <div class="stop-times">${stop.time} / ${stop.departureTime}</div>
                        ${removeButtonHtml}
                    `;
                    if (currentRouteIndex !== -1 && index === currentStopIndex) {
                        li.classList.add('active-stop');
                    }
                    stopsList.appendChild(li);
                });
                const activeLi = stopsList.querySelector('.active-stop');
                if (activeLi) { activeLi.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }
            } else {
                stopsList.innerHTML = '<li>No hay paradas en esta ruta.</li>';
            }
        }

         function updateUIBasedOnState() {
             const isTracking = currentRouteIndex !== -1;
             const currentBuildRoute = routes[currentRouteBeingBuiltIndex];
             const totalRoutes = routes.filter(r => r && r.length > 0).length;
             const buildRouteNum = currentRouteBeingBuiltIndex + 1;

             addStopTitle.textContent = `Añadir Parada (Ruta ${buildRouteNum})`;
             routeListTitle.textContent = isTracking ? `Siguiendo Ruta ${currentRouteIndex + 1}` : `Editando Ruta ${buildRouteNum}`;
             routeIndicator.textContent = `Total Rutas Creadas: ${totalRoutes}`;
             document.body.classList.toggle('tracking-active', isTracking);

             addStopBtn.disabled = isTracking;
             finishRouteBtn.disabled = isTracking || !currentBuildRoute || currentBuildRoute.length === 0;
             startRouteBtn.disabled = isTracking || totalRoutes === 0;

             if (isTracking) clearAddStopForm();
             // Habilitar/deshabilitar inputs específicos durante tracking (ya hecho con body class)
             stopNameInput.readOnly = isTracking;
             stopTimeInput.readOnly = isTracking;
             stopDepartureTimeInput.readOnly = isTracking;
             stopLatInput.readOnly = true; // Siempre readonly
             stopLngInput.readOnly = true; // Siempre readonly
         }

        // --- Seguimiento de Ruta y GPS ---
        function startRouteTracking() {
             if (routes.length === 0 || !routes[0] || routes[0].length === 0) { alert("Crea al menos una ruta con paradas."); return; }
             if (watchId) return;

             // Validación extra: asegurar que todas las paradas en todas las rutas a seguir tienen hora de salida
             for (let r = 0; r < routes.length; r++) {
                 if (!routes[r] || routes[r].length === 0) continue; // Ignorar rutas vacías
                 for (let s = 0; s < routes[r].length; s++) {
                     if (!routes[r][s].departureTime) {
                         alert(`Error: La parada "${routes[r][s].name}" en la Ruta ${r+1} no tiene hora de salida programada.`);
                         return;
                     }
                 }
             }


            currentRouteIndex = 0;
            currentStopIndex = 0; // Apunta a la *próxima* parada
            currentStatusInfo = { phase: 'approaching_first', text: `Hacia ${routes[0][0].name}` }; // Estado inicial
            console.log(`Iniciando seguimiento. Ruta ${currentRouteIndex + 1}, Hacia parada ${currentStopIndex + 1}`);
            renderStopsList();
            updateUIBasedOnState();
            updateStatusDisplayContent("idle", "Iniciando GPS...", "--:--"); // Limpiar display

            if (navigator.geolocation) {
                 const options = { enableHighAccuracy: true, timeout: 15000, maximumAge: 3000 };
                 watchId = navigator.geolocation.watchPosition(handleLocationUpdate, handleLocationError, options);
                 updateGPSStatus("Activado, buscando señal...");
            } else {
                alert("Geolocalización no soportada.");
                stopTracking("error_gps");
            }
        }

         function stopTracking(reason = "detenido") {
             if (watchId) { navigator.geolocation.clearWatch(watchId); watchId = null; }
             const wasTracking = currentRouteIndex !== -1;
             currentRouteIndex = -1; currentStopIndex = -1; lastKnownPosition = null;
             currentStatusInfo = { phase: 'idle', text: `Seguimiento ${reason}` };

             if (currentLocationMarker) { map.removeLayer(currentLocationMarker); currentLocationMarker = null; }

             let finalText = `Seguimiento ${reason}.`;
             if (reason === "completed") finalText = "¡Ruta(s) completada(s)!";
             else if (reason === "error_gps") finalText = "Error: GPS no disponible.";
             else if (reason === "error_data") finalText = "Error en datos de ruta.";

             updateStatusDisplayContent("idle", finalText, "--:--");
             updateGPSStatus("GPS desactivado.");
             if (wasTracking) renderStopsList();
             updateUIBasedOnState();
             console.log("Seguimiento detenido:", reason);
         }


        function handleLocationUpdate(position) {
            lastKnownPosition = position;
            const now = new Date();
            const { latitude, longitude, accuracy } = position.coords;
            updateGPSStatus(`Activo | Precisión: ${accuracy.toFixed(0)}m`);

            const userLatLng = [latitude, longitude];
            if (!currentLocationMarker) {
                currentLocationMarker = L.circleMarker(userLatLng, { radius: 7, fillColor: "#007bff", color: "#ffffff", weight: 2, opacity: 1, fillOpacity: 0.9 }).addTo(map).bindPopup("Ubicación actual");
            } else { currentLocationMarker.setLatLng(userLatLng); }

            if (currentRouteIndex === -1 || currentRouteIndex >= routes.length || !routes[currentRouteIndex] || routes[currentRouteIndex].length === 0) {
                console.warn("handleLocationUpdate sin ruta activa."); stopTracking("estado inválido"); return;
            }
            const currentRoute = routes[currentRouteIndex];
            if (currentStopIndex < 0 || currentStopIndex >= currentRoute.length) {
                 console.warn("handleLocationUpdate sin parada destino válida."); stopTracking("estado inválido"); return;
            }

            const nextStop = currentRoute[currentStopIndex]; // La parada a la que vamos
            const previousStop = (currentStopIndex > 0) ? currentRoute[currentStopIndex - 1] : null; // La parada anterior (null si es la primera)

            let timeDifferenceMs = 0;
            let statusText = "";
            let calculationPhase = "idle";

            // Calcular distancia a la PRÓXIMA parada para detectar llegada
            const distanceToNextStopM = calculateDistance(latitude, longitude, nextStop.lat, nextStop.lng) * 1000;
            const arrivalThresholdMeters = 50;

            // Calcular distancia a la parada ANTERIOR (si existe) para saber si estamos 'at_stop'
            let distanceToPreviousStopM = Infinity;
            if (previousStop) {
                 distanceToPreviousStopM = calculateDistance(latitude, longitude, previousStop.lat, previousStop.lng) * 1000;
            }

            // --- Determinar Fase y Calcular Diferencia ---

            if (previousStop && distanceToPreviousStopM < arrivalThresholdMeters) {
                // FASE: En la parada anterior, esperando salida
                calculationPhase = 'at_stop';
                statusText = `En ${previousStop.name}, Salida: ${previousStop.departureTime}`;
                const scheduledDepartureTime = parseTimeString(previousStop.departureTime);
                if (scheduledDepartureTime) {
                    timeDifferenceMs = now.getTime() - scheduledDepartureTime.getTime(); // Negativo=temprano, Positivo=tarde para salir
                } else { console.error("Error parseando hora salida 'at_stop'"); timeDifferenceMs = 0; }

            } else if (!previousStop) {
                // FASE: Acercándose a la primera parada de la ruta
                calculationPhase = 'approaching_first';
                statusText = `Hacia ${nextStop.name}`;
                const scheduledArrivalTime = parseTimeString(nextStop.time);
                if (scheduledArrivalTime) {
                    timeDifferenceMs = now.getTime() - scheduledArrivalTime.getTime(); // Negativo=llegará temprano, Positivo=llegará tarde
                } else { console.error("Error parseando hora llegada 'approaching_first'"); timeDifferenceMs = 0; }

            } else {
                 // FASE: En ruta entre 'previousStop' y 'nextStop'
                 calculationPhase = 'en_route';
                 statusText = `Hacia ${nextStop.name}`;

                 const scheduledDeparturePrev = parseTimeString(previousStop.departureTime);
                 const scheduledArrivalNext = parseTimeString(nextStop.time);

                 if (scheduledDeparturePrev && scheduledArrivalNext && scheduledArrivalNext > scheduledDeparturePrev) {
                     const scheduledSegmentDurationMs = scheduledArrivalNext.getTime() - scheduledDeparturePrev.getTime();
                     const totalSegmentDistanceKm = calculateDistance(previousStop.lat, previousStop.lng, nextStop.lat, nextStop.lng);
                     let distanceTraveledOnSegmentKm = calculateDistance(previousStop.lat, previousStop.lng, latitude, longitude);

                     let segmentCompletionRatio = 0;
                     if (totalSegmentDistanceKm > 0.001) { // Evitar división por cero/distancias muy pequeñas
                          // Asegurar que la distancia recorrida no sea mayor que la total (puede pasar por GPS impreciso)
                         distanceTraveledOnSegmentKm = Math.max(0, Math.min(distanceTraveledOnSegmentKm, totalSegmentDistanceKm));
                         segmentCompletionRatio = distanceTraveledOnSegmentKm / totalSegmentDistanceKm;
                     } else if (distanceTraveledOnSegmentKm > 0) {
                          segmentCompletionRatio = 1; // Si estamos lejos pero el segmento es "0", considerar completado
                     }


                     const scheduledTimeElapsedOnSegmentMs = segmentCompletionRatio * scheduledSegmentDurationMs;
                     const actualTimeElapsedSinceScheduledDepartureMs = now.getTime() - scheduledDeparturePrev.getTime();

                     timeDifferenceMs = actualTimeElapsedSinceScheduledDepartureMs - scheduledTimeElapsedOnSegmentMs;

                 } else {
                     console.error("Error en tiempos/distancia para cálculo 'en_route'");
                     timeDifferenceMs = 0; // Fallback
                 }
            }

            currentStatusInfo = { phase: calculationPhase, text: statusText };
            updateStatusDisplayWithDifference(timeDifferenceMs, currentStatusInfo);

            // --- Lógica de AVANCE (Basada en proximidad a NEXT stop) ---
            if (distanceToNextStopM < arrivalThresholdMeters) {
                 console.log(`Llegada detectada a ${nextStop.name} (Dist: ${distanceToNextStopM.toFixed(1)}m)`);
                 // El avance real ocurre en la función advanceStopOrRoute
                 // que se encarga de actualizar currentStopIndex/currentRouteIndex
                 // y el estado cambiará en el *siguiente* tick de handleLocationUpdate
                 advanceStopOrRoute();
            }
        }


         function advanceStopOrRoute() {
             const currentRoute = routes[currentRouteIndex];
             const arrivedStop = currentRoute[currentStopIndex]; // La parada a la que acabamos de llegar

             // Marcar parada actual como 'llegada' (visual)
             if (stopMarkers[arrivedStop.id]) { stopMarkers[arrivedStop.id].setOpacity(0.6); }
             if (arrivalMarker) map.removeLayer(arrivalMarker);
             arrivalMarker = L.circleMarker([arrivedStop.lat, arrivedStop.lng], { radius: 10, color: '#2ECC40', fillColor: '#2ECC40', fillOpacity: 0.4, weight: 1 }).addTo(map);
             setTimeout(() => { if (arrivalMarker && map.hasLayer(arrivalMarker)) map.removeLayer(arrivalMarker); arrivalMarker = null; }, 2000);

             // Avanzar índice de la *próxima* parada
             currentStopIndex++;

             if (currentStopIndex >= currentRoute.length) { // Fin de la ruta actual
                 console.log(`Fin de Ruta ${currentRouteIndex + 1}.`);
                 advanceRoute(); // Intentar pasar a la siguiente ruta
             } else { // Siguiente parada en la misma ruta
                 const nextUpcomingStop = currentRoute[currentStopIndex];
                 console.log(`Avanzando. Próxima parada: ${currentStopIndex + 1} (${nextUpcomingStop.name})`);
                 // El estado se recalculará en el siguiente tick, entrando en fase 'at_stop' (esperando salir de 'arrivedStop')
                 // o 'en_route' si la salida es inmediata.
                 currentStatusInfo = { phase: 'at_stop', text: `En ${arrivedStop.name}, Salida: ${arrivedStop.departureTime}` }; // Actualizar estado intermedio
                 updateStatusDisplayContent('idle', currentStatusInfo.text + "<br>Calculando...", "--:--"); // Mostrar estado de espera
                 renderStopsList(); // Actualizar resaltado
             }
         }

         function advanceRoute() {
              currentRouteIndex++;
              if (currentRouteIndex >= routes.length || !routes[currentRouteIndex] || routes[currentRouteIndex].length === 0) {
                  console.log("¡Todas las rutas completadas!");
                  stopTracking("completed");
              } else {
                  currentStopIndex = 0; // Empezar desde la primera parada de la nueva ruta
                  const firstStopNextRoute = routes[currentRouteIndex][currentStopIndex];
                  console.log(`Cambiando a Ruta ${currentRouteIndex + 1}. Próxima: ${firstStopNextRoute.name}`);
                  currentStatusInfo = { phase: 'approaching_first', text: `Iniciando Ruta ${currentRouteIndex + 1}: Hacia ${firstStopNextRoute.name}` };
                  updateStatusDisplayContent('idle', currentStatusInfo.text + "<br>Calculando...", "--:--");
                  renderStopsList();
                  updateUIBasedOnState();
              }
         }

        function handleLocationError(error) {
            console.warn("Error GPS:", error);
            let message = "Error GPS: "; let shouldStop = false;
            switch(error.code) {
                case error.PERMISSION_DENIED: message += "Permiso denegado."; shouldStop = true; break;
                case error.POSITION_UNAVAILABLE: message += "Señal no disponible."; break;
                case error.TIMEOUT: message += "Timeout."; break;
                default: message += "Desconocido."; break;
            }
            updateGPSStatus(message);
            if (shouldStop) { stopTracking("error_gps"); }
        }

        // Modificado para aceptar statusInfo
        function updateStatusDisplayWithDifference(differenceMs, statusInfo) {
            const totalSeconds = Math.round(Math.abs(differenceMs) / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

            let timeString;
            let statusClass;
            const onTimeThresholdSeconds = 30; // Umbral +/- 30 seg para 'a horario'

            // Determinar clase y string de tiempo (+/-)
            if (Math.abs(differenceMs) <= onTimeThresholdSeconds * 1000) {
                timeString = "~00:00"; statusClass = "on-time";
            } else if (differenceMs > 0) { // Positivo = Tarde / Atrasado
                timeString = `-${formattedTime}`; statusClass = "late";
            } else { // Negativo = Temprano / Adelantado
                timeString = `+${formattedTime}`; statusClass = "early";
            }

             // Ajustar interpretación para 'at_stop'
             let interpretedTimeString = timeString;
             if (statusInfo.phase === 'at_stop') {
                 // Si estamos esperando en parada, la diferencia es vs la hora de SALIDA
                 // differenceMs > 0 significa que YA DEBERÍAMOS HABER SALIDO (atraso para salir) -> -MM:SS
                 // differenceMs < 0 significa que FALTA PARA SALIR (adelanto para salir) -> +MM:SS
                 // El cálculo ya lo hace bien, solo confirmamos la interpretación.
                 // No es necesario cambiar `timeString` o `statusClass` aquí si la lógica base es correcta.
             }

             updateStatusDisplayContent(statusClass, statusInfo.text, interpretedTimeString);
        }

        // Nueva función para actualizar el contenido del display de estado
        function updateStatusDisplayContent(className, infoText, timeText) {
             statusDisplay.className = `status-display ${className}`; // Aplica clase de color/fondo
             // Actualiza los spans internos
             const infoSpan = statusDisplay.querySelector('.status-info');
             const timeSpan = statusDisplay.querySelector('.status-time');
             if (infoSpan) infoSpan.innerHTML = infoText; // Usar innerHTML por si hay <br>
             if (timeSpan) timeSpan.textContent = timeText;
        }


         function updateGPSStatus(text) { gpsStatus.textContent = `GPS: ${text}`; }

        // --- Funciones de Utilidad ---
        function calculateDistance(lat1, lon1, lat2, lon2) {
             if (lat1 == lat2 && lon1 == lon2) return 0;
            const dLat = deg2rad(lat2 - lat1); const dLon = deg2rad(lon2 - lon1);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // km
        }
        function deg2rad(deg) { return deg * (Math.PI / 180); }
        function parseTimeString(timeString) {
             try {
                 if (!timeString || typeof timeString !== 'string' || !timeString.includes(':')) return null;
                 const [hours, minutes] = timeString.split(':').map(Number);
                 if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) return null;
                 const date = new Date(); date.setHours(hours, minutes, 0, 0); return date;
             } catch (e) { console.error("Error parsing time:", timeString, e); return null; }
         }

    </script>

</body>
</html>
