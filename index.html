<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            overflow: hidden; /* Prevent body scroll */
            display: flex;
            flex-direction: column;
        }

        #map {
            height: 50vh; /* 50% of viewport height */
            width: 100%;
            background-color: #333; /* Placeholder color */
        }

        #controls {
            height: 50vh; /* 50% of viewport height */
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .control-section:last-child {
            border-bottom: none;
        }

        h2, h3 {
            color: #FFFFFF;
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="text"], input[type="datetime-local"], input[type="number"], select {
            width: calc(100% - 12px);
            padding: 8px;
            margin-bottom: 10px;
            background-color: #222;
            color: #FFF;
            border: 1px solid #555;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        button:hover {
            background-color: #45a049;
        }
        button.danger {
            background-color: #f44336;
        }
        button.danger:hover {
            background-color: #da190b;
        }
        button.secondary {
            background-color: #007bff;
        }
        button.secondary:hover {
            background-color: #0056b3;
        }
        button.info {
            background-color: #17a2b8;
        }
        button.info:hover {
            background-color: #117a8b;
        }


        #statusDisplay {
            text-align: center;
            padding: 10px;
        }
        #timeDeviation {
            font-size: 3em; /* Larger font for time deviation */
            font-weight: bold;
            margin: 10px 0;
        }
        #speedDisplay, #nextStopDisplay {
            font-size: 1.2em;
            margin: 5px 0;
        }

        .stop-item {
            background-color: #1e1e1e;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .stop-item.next-stop-highlight {
            background-color: #007bff;
            font-weight: bold;
        }

        .leaflet-div-icon {
            background: transparent;
            border: none;
            text-align: center;
            font-weight: bold;
            color: white;
        }
        .waypoint-marker { /* For waypoint divIcon base */
            /* Style applied via JS, but good for overrides */
        }

        .user-location-icon {
            background-color: #007bff !important; /* Blue dot */
            border-radius: 50%;
            width: 16px !important;
            height: 16px !important;
            border: 2px solid white;
            box-shadow: 0 0 0 2px #007bff;
        }
    </style>
</head>
<body>

    <div id="map"></div>
    <div id="controls">
        <div id="statusDisplay" style="display: none;">
            <div id="timeDeviation">00:00</div>
            <div id="speedDisplay">Velocidad: 0 KM/H</div>
            <div id="nextStopDisplay">Próxima Parada: N/A</div>
        </div>

        <div class="control-section" id="routeCreationSection">
            <h3>Crear/Modificar Ruta</h3>
            <p style="font-size: 0.8em;">Toca el mapa para agregar paradas. Toca una parada existente para editarla. Usa "Añadir Punto de Paso" para ajustar la traza.</p>
            
            <button onclick="toggleAddWaypointMode()" id="addWaypointBtn" class="info">Añadir Punto de Paso</button>
            <p id="waypointModeStatus" style="font-size: 0.8em; color: #17a2b8; display: none;">Modo 'Añadir Punto de Paso' ACTIVO. Toca el mapa.</p>
            <hr style="margin: 10px 0;">

            <label for="pointName">Nombre Parada (para paradas, no puntos de paso):</label>
            <input type="text" id="pointName" placeholder="Ej: Estación Central">
            
            <label for="pointTime">Horario Programado (DD/MM/AAAA HH:MM):</label>
            <input type="datetime-local" id="pointTime">

            <div id="editPointControls" style="display:none; margin-top:10px;">
                <button onclick="updateSelectedPoint()" class="secondary">Actualizar Parada</button>
                <button onclick="deleteSelectedPoint()" class="danger">Borrar Parada Seleccionada</button>
                <button onclick="cancelEdit()">Cancelar Edición</button>
            </div>
            <hr style="margin: 15px 0;">
            <input type="checkbox" id="autoCalcTimes" checked>
            <label for="autoCalcTimes" style="display:inline;">Calcular horarios intermedios automáticamente</label>
            <br><br>
            <button onclick="clearCurrentRoute()">Limpiar Ruta Actual</button>
        </div>

        <div class="control-section">
            <h3>Configuración de Visualización</h3>
            <label for="stopRadiusInput">Radio de Paradas (metros):</label>
            <input type="number" id="stopRadiusInput" value="50" min="10" max="500" onchange="updateGlobalStopRadiusSettings()">
        </div>

        <div class="control-section">
            <h3>Lista de Paradas (No incluye Puntos de Paso)</h3>
            <div id="stopsList">No hay paradas.</div>
        </div>
        
        <div class="control-section">
            <h3>Guardar/Cargar Rutas</h3>
            <label for="routeName">Nombre para Guardar Ruta:</label>
            <input type="text" id="routeName" placeholder="Ej: Ruta Mañana Lunes">
            <button onclick="saveRoute()">Guardar Ruta</button>
            <br><br>
            <label for="savedRoutes">Cargar Ruta:</label>
            <select id="savedRoutes"></select>
            <button onclick="loadRoute()">Cargar</button>
            <button onclick="deleteRoute()" class="danger">Borrar Seleccionada</button>
        </div>

        <div class="control-section">
            <h3>Seguimiento</h3>
            <button id="startTrackingBtn" onclick="startTracking()">Iniciar Seguimiento</button>
            <button id="stopTrackingBtn" onclick="stopTracking()" class="danger" style="display:none;">Detener Seguimiento</button>
            <br>
            <input type="checkbox" id="manualStopNav">
            <label for="manualStopNav" style="display:inline;">Navegación Manual de Paradas</label>
            <button id="prevStopBtn" onclick="goToPreviousStop()" style="display:none;">Anterior</button>
            <button id="nextStopBtn" onclick="goToNextStop()" style="display:none;">Siguiente</button>
        </div>
        
        <div class="control-section">
            <h3>Cola de Rutas</h3>
            <label for="routeToQueue">Añadir ruta guardada a la cola:</label>
            <select id="routeToQueue"></select>
            <button onclick="addRouteToQueue()">Añadir a Cola</button>
            <h4>En Cola:</h4>
            <div id="routeQueueDisplay">Vacía.</div>
            <button onclick="clearRouteQueue()">Limpiar Cola</button>
        </div>

    </div>

    <script>
        'use strict';
        let map;
        // routePoints: {lat, lng, name, pointCategory ('stop'|'waypoint'), type ('start'|'end'|'intermediate' - for stops only), scheduledTime (for stops only), marker, originalIndex, radiusCircle (for stops only)}
        let routePoints = []; 
        let routeLine;
        let userMarker;
        let trackingIntervalId;
        let isTracking = false;
        let currentSegmentStartIndex = 0; 
        let lastKnownPosition = null;
        let currentlyEditingPoint = null; 
        let currentStopRadius = 50; 
        let addingWaypointMode = false;

        const CACHE_PREFIX = 'smartMovePro_route_';
        const ROUTE_QUEUE_CACHE_KEY = 'smartMovePro_routeQueue';

        // --- Leaflet Icon Helpers ---
        function createDivIcon(text, bgColor = null, pointType = '') { // pointType can be 'start', 'end', 'intermediate', 'waypoint'
            let iconColor = bgColor;
            if (pointType === 'waypoint') {
                iconColor = iconColor || '#888888'; // Default grey for waypoint
                return L.divIcon({
                    className: 'leaflet-div-icon waypoint-marker',
                    html: `<div style="background-color:${iconColor}; width: 10px; height: 10px; border-radius: 50%; border: 1px solid #FFFFFF; box-sizing: border-box;"></div>`,
                    iconSize: [12, 12],
                    iconAnchor: [6, 6]
                });
            }

            if (!iconColor) {
                if (pointType === 'start') iconColor = '#4CAF50'; 
                else if (pointType === 'end') iconColor = '#f44336';   
                else if (pointType === 'intermediate') iconColor = '#2196F3'; 
                else iconColor = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`; // Fallback for stops
            }

            return L.divIcon({
                className: 'leaflet-div-icon',
                html: `<div style="background-color:${iconColor}; padding: 5px 8px; border-radius: 50%; color: white; font-size:14px; font-weight:bold; border: 1px solid white;">${text || ''}</div>`,
                iconSize: [30,30], 
                iconAnchor: [15,15] 
            });
        }
        
        function createUserLocationIcon() {
            return L.divIcon({
                className: 'user-location-icon',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        // --- Map Initialization ---
        function initMap() {
            map = L.map('map').setView([-34.6037, -58.3816], 13); 
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            map.on('click', onMapClick);

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    map.setView([position.coords.latitude, position.coords.longitude], 13);
                }, () => {
                    console.warn("Error getting current location. Using default.");
                });
            }
            document.getElementById('stopRadiusInput').value = currentStopRadius;
        }
        
        // --- Waypoint Mode ---
        function toggleAddWaypointMode() {
            if (isTracking) {
                alert("Detén el seguimiento para modificar la ruta.");
                return;
            }
            addingWaypointMode = !addingWaypointMode;
            const statusP = document.getElementById('waypointModeStatus');
            const button = document.getElementById('addWaypointBtn');
            if (addingWaypointMode) {
                cancelEdit(); // Exit stop editing mode
                statusP.style.display = 'block';
                button.classList.add('danger'); 
                button.textContent = "Cancelar Añadir Punto de Paso";
            } else {
                statusP.style.display = 'none';
                button.classList.remove('danger');
                button.textContent = "Añadir Punto de Paso";
            }
        }


        // --- Funciones de Edición ---
        function formatDateTimeForInput(date) {
            if (!date || isNaN(new Date(date).getTime())) return "";
            const d = new Date(date);
            d.setMinutes(d.getMinutes() - d.getTimezoneOffset());
            return d.toISOString().slice(0, 16);
        }

        function activateEditModeForPoint(point) {
            if (isTracking || point.pointCategory === 'waypoint') {
                return;
            }
            currentlyEditingPoint = point;
            document.getElementById('pointName').value = point.name;
            document.getElementById('pointTime').value = point.scheduledTime ? formatDateTimeForInput(point.scheduledTime) : "";
            document.getElementById('editPointControls').style.display = 'block';
            document.getElementById('pointName').focus();
            if (addingWaypointMode) toggleAddWaypointMode(); 
        }

        function cancelEdit() {
            currentlyEditingPoint = null;
            document.getElementById('pointName').value = "";
            document.getElementById('pointTime').value = "";
            document.getElementById('editPointControls').style.display = 'none';
        }

        function updateSelectedPoint() {
            if (!currentlyEditingPoint || currentlyEditingPoint.pointCategory === 'waypoint') return;

            const newName = document.getElementById('pointName').value.trim();
            const newTimeValue = document.getElementById('pointTime').value;
            
            if (!newName) {
                alert("El nombre de la parada no puede estar vacío.");
                return;
            }

            let newScheduledTime = null;
            if (newTimeValue) {
                newScheduledTime = new Date(newTimeValue);
                if (isNaN(newScheduledTime.getTime())) {
                    alert("Formato de fecha/hora inválido.");
                    return;
                }
            }

            if ((currentlyEditingPoint.type === 'start' || currentlyEditingPoint.type === 'end') && !newScheduledTime) {
                alert(`El horario es obligatorio para el punto de ${currentlyEditingPoint.type === 'start' ? 'Inicio' : 'Fin'}.`);
                return;
            }

            currentlyEditingPoint.name = newName;
            currentlyEditingPoint.scheduledTime = newScheduledTime;

            if (document.getElementById('autoCalcTimes').checked) {
                calculateAndApplyIntermediateTimes();
            }
            updateAllMarkerIconsAndLabels(); 
            redrawRouteLine();
            updateStopsList();
            alert(`Parada "${newName}" actualizada.`);
            cancelEdit();
        }

        function deleteSelectedPoint() { // For STOPS only, via edit controls
            if (!currentlyEditingPoint || currentlyEditingPoint.pointCategory === 'waypoint') return;
        
            const numStops = routePoints.filter(p => p.pointCategory === 'stop').length;
            const isStartPoint = currentlyEditingPoint.type === 'start';
            const isEndPoint = currentlyEditingPoint.type === 'end';
            const startPointsCount = routePoints.filter(p => p.pointCategory === 'stop' && p.type === 'start').length;
            const endPointsCount = routePoints.filter(p => p.pointCategory === 'stop' && p.type === 'end').length;
        
            if (numStops > 2) { 
                if (isStartPoint && startPointsCount <= 1) {
                    alert("No puedes borrar el único punto de Inicio si hay otras paradas. Define un nuevo Inicio primero o borra las paradas intermedias/fin.");
                    return;
                }
                if (isEndPoint && endPointsCount <= 1) {
                    alert("No puedes borrar el único punto de Fin si hay otras paradas. Define un nuevo Fin primero o borra las paradas intermedias/inicio.");
                    return;
                }
            }
        
            if (confirm(`¿Seguro que quieres borrar la parada "${currentlyEditingPoint.name}"?`)) {
                map.removeLayer(currentlyEditingPoint.marker);
                if (currentlyEditingPoint.radiusCircle) {
                    map.removeLayer(currentlyEditingPoint.radiusCircle);
                }
                const index = routePoints.indexOf(currentlyEditingPoint);
                if (index > -1) {
                    routePoints.splice(index, 1);
                }
        
                const currentStops = routePoints.filter(p => p.pointCategory === 'stop');
                if (currentStops.length > 0) {
                    if (!currentStops.some(p => p.type === 'start')) {
                        currentStops[0].type = 'start';
                    }
                    if (currentStops.length > 1 && !currentStops.some(p => p.type === 'end')) {
                        currentStops[currentStops.length - 1].type = 'end';
                    } else if (currentStops.length === 1 && currentStops[0].type !== 'start') {
                         currentStops[0].type = 'start'; 
                    }
                }
                
                updateAllMarkerIconsAndLabels();
        
                if (document.getElementById('autoCalcTimes').checked) {
                    calculateAndApplyIntermediateTimes();
                }
                redrawRouteLine();
                updateStopsList();
                alert(`Parada "${currentlyEditingPoint.name}" borrada.`);
            }
            cancelEdit();
        }
        
        function updateAllMarkerIconsAndLabels() {
            let intermediateStopCounter = 1;
            routePoints.forEach(p => {
                if (p.marker) {
                    if (p.pointCategory === 'stop') {
                        let text = '';
                        if (p.type === 'start') text = 'I';
                        else if (p.type === 'end') text = 'F';
                        else if (p.type === 'intermediate') text = intermediateStopCounter++;
                        p.marker.setIcon(createDivIcon(text, null, p.type));
                    } else if (p.pointCategory === 'waypoint') {
                        p.marker.setIcon(createDivIcon(null, null, 'waypoint'));
                    }
                }
            });
        }


        // --- Route Creation Logic ---
        function onMapClick(e) {
            if (isTracking) {
                alert("Detén el seguimiento para modificar la ruta.");
                return;
            }
            
            let targetIsMarkerIcon = false;
            if (e.originalEvent && e.originalEvent.target) {
                 try {
                    if (e.originalEvent.target.closest('.leaflet-marker-icon')) {
                        targetIsMarkerIcon = true;
                    }
                 } catch(err) {/*ignore*/}
            }

            if (currentlyEditingPoint && !targetIsMarkerIcon) { 
                cancelEdit();
            }
            if (targetIsMarkerIcon) return; 

            const latlng = e.latlng;

            if (addingWaypointMode) {
                const waypoint = {
                    lat: latlng.lat,
                    lng: latlng.lng,
                    name: `Paso ${routePoints.filter(p => p.pointCategory === 'waypoint').length + 1}`,
                    pointCategory: 'waypoint',
                    type: null, scheduledTime: null,
                    marker: L.marker(latlng, {
                        icon: createDivIcon(null, null, 'waypoint'),
                        draggable: true
                    }).addTo(map),
                    radiusCircle: null,
                    originalIndex: routePoints.length
                };

                waypoint.marker.on('dragend', function(event) {
                    if (isTracking) { event.target.setLatLng(L.latLng(waypoint.lat, waypoint.lng)); alert("Detén el seguimiento para modificar la ruta."); return; }
                    const pos = event.target.getLatLng();
                    waypoint.lat = pos.lat; waypoint.lng = pos.lng;
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyIntermediateTimes();
                });

                waypoint.marker.on('click', function(ev) {
                    L.DomEvent.stopPropagation(ev);
                    if (isTracking) return;
                    if (currentlyEditingPoint) cancelEdit();
                    if (confirm(`¿Borrar este punto de paso "${waypoint.name}"?`)) {
                        map.removeLayer(waypoint.marker);
                        const index = routePoints.indexOf(waypoint);
                        if (index > -1) routePoints.splice(index, 1);
                        redrawRouteLine();
                        if (document.getElementById('autoCalcTimes').checked) calculateAndApplyIntermediateTimes();
                    }
                });
                routePoints.push(waypoint);
                redrawRouteLine();
                if (document.getElementById('autoCalcTimes').checked) calculateAndApplyIntermediateTimes();
                return; 
            }

            // --- Adding a STOP ---
            const nameInput = document.getElementById('pointName');
            const timeInput = document.getElementById('pointTime');
            let pointNameValue = nameInput.value.trim();
            
            let type;
            let requiredTime = true;
            let pointText;

            const currentStops = routePoints.filter(p => p.pointCategory === 'stop');
            if (currentStops.length === 0) {
                type = 'start'; pointText = 'I';
            } else {
                const hasStart = currentStops.some(p => p.type === 'start');
                const hasEnd = currentStops.some(p => p.type === 'end');
                if (!hasStart) { type = 'start'; pointText = 'I'; }
                else if (!hasEnd) { type = 'end'; pointText = 'F'; }
                else {
                    type = 'intermediate';
                    const intermediateCount = currentStops.filter(p => p.type === 'intermediate').length;
                    pointText = intermediateCount + 1;
                    requiredTime = false;
                }
            }
            
            if (!pointNameValue) { 
                if (type === 'start') pointNameValue = "Inicio";
                else if (type === 'end') pointNameValue = "Final";
                else pointNameValue = `Parada ${pointText}`;
            }

            if (requiredTime && !timeInput.value) {
                alert(`El horario es obligatorio para el punto de ${type === 'start' ? 'Inicio' : 'Fin'}.`);
                return;
            }
            const scheduledTime = timeInput.value ? new Date(timeInput.value) : null;
            if (requiredTime && scheduledTime && isNaN(scheduledTime.getTime())) {
                alert("Formato de fecha/hora inválido."); return;
            }
            
            const newPoint = {
                lat: latlng.lat, lng: latlng.lng, name: pointNameValue,
                pointCategory: 'stop', type: type, scheduledTime: scheduledTime,
                marker: L.marker(latlng, { 
                    icon: createDivIcon(pointText, null, type), draggable: true 
                }).addTo(map),
                radiusCircle: L.circle(latlng, {
                    radius: currentStopRadius, color: 'blue', weight: 1, opacity: 0.5, 
                    fillColor: 'blue', fillOpacity: 0.2
                }).addTo(map),
                originalIndex: routePoints.length 
            };

            newPoint.marker.on('dragend', function(event) {
                if (isTracking) { event.target.setLatLng(L.latLng(newPoint.lat, newPoint.lng)); alert("Detén el seguimiento para modificar la ruta."); return; }
                const marker = event.target; const position = marker.getLatLng();
                const point = routePoints.find(p => p.marker === marker);
                if (point) {
                    point.lat = position.lat; point.lng = position.lng;
                    if (point.radiusCircle) point.radiusCircle.setLatLng(position);
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyIntermediateTimes();
                    updateStopsList(); 
                }
            });
            
            newPoint.marker.on('click', function(ev) {
                L.DomEvent.stopPropagation(ev);
                if (isTracking) return;
                activateEditModeForPoint(newPoint);
            });
            
            if (type === 'intermediate') {
                const endStopIndex = routePoints.findIndex(p => p.pointCategory === 'stop' && p.type === 'end');
                if (endStopIndex !== -1) {
                    routePoints.splice(endStopIndex, 0, newPoint);
                } else {
                    routePoints.push(newPoint);
                }
            } else {
                 routePoints.push(newPoint);
            }

            nameInput.value = ""; 
            updateAllMarkerIconsAndLabels();
            if (document.getElementById('autoCalcTimes').checked) calculateAndApplyIntermediateTimes();
            redrawRouteLine();
            updateStopsList();
        }
        
        function getSortedPointsForPolyline() { // Includes stops and waypoints
            const start = routePoints.find(p => p.pointCategory === 'stop' && p.type === 'start');
            const end = routePoints.find(p => p.pointCategory === 'stop' && p.type === 'end');
            
            const middlePoints = routePoints.filter(p =>
                !(p.pointCategory === 'stop' && (p.type === 'start' || p.type === 'end'))
            ).sort((a, b) => a.originalIndex - b.originalIndex);

            let polylinePoints = [];
            if (start) polylinePoints.push(start);
            polylinePoints.push(...middlePoints);
            if (end && end !== start) polylinePoints.push(end);
            
            return polylinePoints;
        }


        function calculateAndApplyIntermediateTimes() {
            const startPoint = routePoints.find(p => p.pointCategory === 'stop' && p.type === 'start');
            const endPoint = routePoints.find(p => p.pointCategory === 'stop' && p.type === 'end');

            routePoints.filter(p => p.pointCategory === 'stop' && p.type === 'intermediate')
                       .forEach(p => p.scheduledTime = null);

            if (!startPoint || !endPoint || !startPoint.scheduledTime || !endPoint.scheduledTime) {
                updateStopsList(); return;
            }
            
            const intermediateStops = routePoints.filter(p => p.pointCategory === 'stop' && p.type === 'intermediate')
                                            .sort((a,b) => a.originalIndex - b.originalIndex);
            
            const totalDurationMillis = endPoint.scheduledTime.getTime() - startPoint.scheduledTime.getTime();
            if (totalDurationMillis <= 0) {
                console.warn("Duración total no positiva."); updateStopsList(); return;
            }
            
            let pathForDistanceCalc = getSortedPointsForPolyline();
            let totalRouteDistance = 0;
            for (let i = 0; i < pathForDistanceCalc.length - 1; i++) {
                totalRouteDistance += L.latLng(pathForDistanceCalc[i].lat, pathForDistanceCalc[i].lng)
                                    .distanceTo(L.latLng(pathForDistanceCalc[i+1].lat, pathForDistanceCalc[i+1].lng));
            }

            if (totalRouteDistance === 0) { 
                const numSegments = intermediateStops.length + 1;
                const timePerSegment = totalDurationMillis / numSegments;
                 intermediateStops.forEach((stop, index) => {
                    stop.scheduledTime = new Date(startPoint.scheduledTime.getTime() + (timePerSegment * (index + 1)));
                });
                updateStopsList(); return;
            }

            intermediateStops.forEach(currentIntermediateStop => {
                let distFromStartToCurrentStop = 0;
                const indexOfCurrentStopInPath = pathForDistanceCalc.findIndex(p => p === currentIntermediateStop);

                if (indexOfCurrentStopInPath <= 0 && pathForDistanceCalc[0] !== currentIntermediateStop) { 
                     console.warn("Intermediate stop not found correctly in path or is start.", currentIntermediateStop); return;
                }

                for(let k=0; k < indexOfCurrentStopInPath; k++){ 
                    distFromStartToCurrentStop += L.latLng(pathForDistanceCalc[k].lat, pathForDistanceCalc[k].lng)
                                                .distanceTo(L.latLng(pathForDistanceCalc[k+1].lat, pathForDistanceCalc[k+1].lng));
                }
                
                const proportionOfRoute = distFromStartToCurrentStop / totalRouteDistance;
                const timeOffsetMillis = totalDurationMillis * proportionOfRoute;
                currentIntermediateStop.scheduledTime = new Date(startPoint.scheduledTime.getTime() + timeOffsetMillis);
            });
            updateStopsList();
        }
        
        function clearCurrentRoute() {
            cancelEdit(); 
            if (addingWaypointMode) toggleAddWaypointMode();
            routePoints.forEach(p => {
                map.removeLayer(p.marker);
                if (p.radiusCircle) map.removeLayer(p.radiusCircle);
            });
            routePoints = [];
            if (routeLine) map.removeLayer(routeLine);
            routeLine = null;
            document.getElementById('pointName').value = "";
            document.getElementById('pointTime').value = "";
            updateStopsList();
            updateAllMarkerIconsAndLabels(); 
            console.log("Ruta actual limpiada.");
        }

        function redrawRouteLine() {
            if (routeLine) {
                map.removeLayer(routeLine);
                routeLine = null;
            }
            
            const polylineDisplayPoints = getSortedPointsForPolyline(); 
            if (polylineDisplayPoints.length > 1) {
                const latlngs = polylineDisplayPoints.map(p => [p.lat, p.lng]);
                routeLine = L.polyline(latlngs, {color: 'blue'}).addTo(map);
            }
        }
        
        function getSortedRoutePointsForDisplay() { // STOPS ONLY for the list
            const stops = routePoints.filter(p => p.pointCategory === 'stop');
            const sortedStops = [];
            const start = stops.find(p => p.type === 'start');
            const end = stops.find(p => p.type === 'end');
            const intermediates = stops.filter(p => p.type === 'intermediate')
                                    .sort((a,b) => {
                                        if (!document.getElementById('autoCalcTimes').checked && a.scheduledTime && b.scheduledTime) {
                                            return new Date(a.scheduledTime).getTime() - new Date(b.scheduledTime).getTime();
                                        }
                                        return a.originalIndex - b.originalIndex; 
                                    });

            if (start) sortedStops.push(start);
            sortedStops.push(...intermediates);
            if (end && end !== start) sortedStops.push(end); 
            return sortedStops;
        }


        function formatTime(dateObj) { 
            if (!dateObj || isNaN(dateObj.getTime())) return "N/A";
            return dateObj.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }) + 
                   ` (${dateObj.toLocaleDateString('es-ES', {day:'2-digit', month:'2-digit'})})`;
        }
        
        function updateStopsList() {
            const listDiv = document.getElementById('stopsList');
            const displayPoints = getSortedRoutePointsForDisplay(); 

            if (displayPoints.length === 0) {
                listDiv.innerHTML = "No hay paradas.";
                return;
            }

            let html = "<ul>";
            let intermediateVisualCounter = 1; 
            displayPoints.forEach((p) => { 
                let typeText = "";
                switch(p.type) {
                    case 'start': typeText = "Inicio"; break;
                    case 'intermediate': typeText = `Intermedia ${intermediateVisualCounter++}`; break;
                    case 'end': typeText = "Fin"; break;
                }
                const timeStr = p.scheduledTime ? formatTime(new Date(p.scheduledTime)) : "Sin horario";
                
                let itemClass = "stop-item";
                // Highlight logic moved to highlightNextStopInList, called after this.
                html += `<li class="${itemClass}"><b>${p.name}</b> (${typeText}) - ${timeStr}</li>`;
            });
            html += "</ul>";
            listDiv.innerHTML = html;
            highlightNextStopInList(); 
        }

        // --- Persistence (localStorage) ---
        function saveRoute() {
            const routeNameInput = document.getElementById('routeName');
            if (!routeNameInput.value) { alert("Por favor, ingresa un nombre para la ruta."); return; }
            
            const stops = routePoints.filter(p => p.pointCategory === 'stop');
            if (!stops.some(p=>p.type==='start') || !stops.some(p=>p.type==='end')) {
                 alert("Una ruta debe tener al menos un punto de inicio y fin definidos."); return;
            }
            if (stops.length < 2) { alert("Una ruta debe tener al menos dos paradas (inicio y fin)."); return; }

            const savablePoints = routePoints.map(p => ({ 
                lat: p.lat, lng: p.lng, name: p.name, 
                pointCategory: p.pointCategory,
                type: p.type, 
                scheduledTime: p.scheduledTime ? new Date(p.scheduledTime).toISOString() : null,
                originalIndex: p.originalIndex 
            }));

            localStorage.setItem(CACHE_PREFIX + routeNameInput.value, JSON.stringify(savablePoints));
            alert(`Ruta "${routeNameInput.value}" guardada.`);
            loadSavedRoutesLists();
        }

        function loadRoute() {
            cancelEdit();
            if (addingWaypointMode) toggleAddWaypointMode();
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) { alert("Selecciona una ruta para cargar."); return; }
            const savedData = localStorage.getItem(CACHE_PREFIX + selectedRouteName);
            if (!savedData) { alert("Error al cargar la ruta."); return; }

            clearCurrentRoute(); 
            const loadedPointsData = JSON.parse(savedData);
            
            const tempLoadedPoints = [];

            loadedPointsData.forEach((p_data) => {
                const pointCat = p_data.pointCategory || 'stop'; 
                const iconMarkerType = pointCat === 'waypoint' ? 'waypoint' : p_data.type;

                const newPoint = {
                    ...p_data,
                    pointCategory: pointCat,
                    scheduledTime: p_data.scheduledTime ? new Date(p_data.scheduledTime) : null,
                    marker: L.marker([p_data.lat, p_data.lng], { 
                        icon: createDivIcon(null, null, iconMarkerType), 
                        draggable: true 
                    }).addTo(map),
                    radiusCircle: pointCat === 'stop' ? L.circle([p_data.lat, p_data.lng], {
                        radius: currentStopRadius, color: 'blue', weight: 1, opacity: 0.5, 
                        fillColor: 'blue', fillOpacity: 0.2
                    }).addTo(map) : null
                };
                
                newPoint.marker.on('dragend', function(event){
                    if (isTracking) { event.target.setLatLng(L.latLng(newPoint.lat, newPoint.lng)); alert("Detén el seguimiento para modificar la ruta."); return; }
                    const marker = event.target; const position = marker.getLatLng();
                    const point = routePoints.find(p => p.marker === marker); 
                    if (point) {
                        point.lat = position.lat; point.lng = position.lng;
                        if (point.radiusCircle) point.radiusCircle.setLatLng(position);
                        redrawRouteLine();
                         if (document.getElementById('autoCalcTimes').checked) calculateAndApplyIntermediateTimes();
                        if (point.pointCategory === 'stop') updateStopsList();
                    }
                });

                if (newPoint.pointCategory === 'stop') {
                    newPoint.marker.on('click', function(ev) {
                        L.DomEvent.stopPropagation(ev);
                        if (isTracking) return;
                        activateEditModeForPoint(newPoint);
                    });
                } else { 
                     newPoint.marker.on('click', function(ev) {
                        L.DomEvent.stopPropagation(ev);
                        if (isTracking) return;
                        if (currentlyEditingPoint) cancelEdit();
                        if (confirm(`¿Borrar este punto de paso "${newPoint.name}"?`)) {
                            map.removeLayer(newPoint.marker);
                            const index = routePoints.indexOf(newPoint);
                            if (index > -1) routePoints.splice(index, 1);
                            redrawRouteLine();
                            if (document.getElementById('autoCalcTimes').checked) calculateAndApplyIntermediateTimes();
                        }
                    });
                }
                tempLoadedPoints.push(newPoint);
            });
            
            routePoints = tempLoadedPoints; 
            updateAllMarkerIconsAndLabels(); 
            redrawRouteLine();
            updateStopsList();

            const polylineBoundsPoints = getSortedPointsForPolyline();
            if (polylineBoundsPoints.length > 0) {
                const bounds = L.latLngBounds(polylineBoundsPoints.map(p => [p.lat, p.lng]));
                if (bounds.isValid()) {
                    map.fitBounds(bounds);
                } else if (polylineBoundsPoints.length > 0){ 
                    map.setView([polylineBoundsPoints[0].lat, polylineBoundsPoints[0].lng], 13);
                }
            }
            document.getElementById('routeName').value = selectedRouteName;
            alert(`Ruta "${selectedRouteName}" cargada.`);
        }

        function deleteRoute() {
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) {
                alert("Selecciona una ruta para borrar.");
                return;
            }
            if (confirm(`¿Estás seguro de que quieres borrar la ruta "${selectedRouteName}"?`)) {
                localStorage.removeItem(CACHE_PREFIX + selectedRouteName);
                let queue = getRouteQueue();
                queue = queue.filter(name => name !== selectedRouteName);
                saveRouteQueue(queue);
                loadSavedRoutesLists(); 
                alert(`Ruta "${selectedRouteName}" borrada.`);
            }
        }

        function loadSavedRoutesLists() { 
            const savedRoutesSelect = document.getElementById('savedRoutes');
            const routeToQueueSelect = document.getElementById('routeToQueue');
            const currentSavedRouteValue = savedRoutesSelect.value;
            const currentQueueRouteValue = routeToQueueSelect.value;

            savedRoutesSelect.innerHTML = ""; 
            routeToQueueSelect.innerHTML = "";

            let hasRoutes = false;
            const routeNames = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(CACHE_PREFIX)) {
                    routeNames.push(key.substring(CACHE_PREFIX.length));
                }
            }
            routeNames.sort(); 

            routeNames.forEach(routeName => {
                const option = document.createElement('option');
                option.value = routeName;
                option.textContent = routeName;
                savedRoutesSelect.appendChild(option.cloneNode(true));
                routeToQueueSelect.appendChild(option.cloneNode(true));
                hasRoutes = true;
            });
            
            if (!hasRoutes) {
                 const option = document.createElement('option');
                 option.textContent = "No hay rutas guardadas";
                 option.disabled = true;
                 savedRoutesSelect.appendChild(option.cloneNode(true));
                 routeToQueueSelect.appendChild(option);
            } else {
                if (routeNames.includes(currentSavedRouteValue)) savedRoutesSelect.value = currentSavedRouteValue;
                if (routeNames.includes(currentQueueRouteValue)) routeToQueueSelect.value = currentQueueRouteValue;
            }
            updateRouteQueueDisplay();
        }
        
        function getSortedRoutePointsForTracking() { // STOPS ONLY
            const stops = routePoints.filter(p => p.pointCategory === 'stop');
            const startPt = stops.find(p => p.type === 'start');
            const endPt = stops.find(p => p.type === 'end');
            const intermediatePts = stops.filter(p => p.type === 'intermediate')
                                        .sort((a, b) => {
                                            if (a.scheduledTime && b.scheduledTime) {
                                                return new Date(a.scheduledTime).getTime() - new Date(b.scheduledTime).getTime();
                                            }
                                            return a.originalIndex - b.originalIndex; 
                                        });
            
            let trackingOrder = [];
            if (startPt) trackingOrder.push(startPt);
            trackingOrder.push(...intermediatePts);
            if (endPt && endPt !== startPt) trackingOrder.push(endPt);
            return trackingOrder;
        }


        // --- Real-Time Tracking ---
        function startTracking() {
            if (addingWaypointMode) toggleAddWaypointMode(); 
            const trackingPointsOrdered = getSortedRoutePointsForTracking(); 
            if (trackingPointsOrdered.length < 2) {
                alert("La ruta debe tener al menos un Inicio y Fin definidos para el seguimiento.");
                return;
            }
            const startPoint = trackingPointsOrdered[0];
            const endPoint = trackingPointsOrdered[trackingPointsOrdered.length - 1];

            if (startPoint.type !== 'start' || endPoint.type !== 'end' || !startPoint.scheduledTime || !endPoint.scheduledTime) {
                 alert("La ruta debe tener un Inicio y Fin con horarios definidos para el seguimiento.");
                 return;
            }

            isTracking = true;
            currentSegmentStartIndex = 0; 
            
            document.getElementById('startTrackingBtn').style.display = 'none';
            document.getElementById('stopTrackingBtn').style.display = 'inline-block';
            document.getElementById('statusDisplay').style.display = 'block';
            document.getElementById('routeCreationSection').style.display = 'none'; 

            if (navigator.geolocation) {
                trackingIntervalId = navigator.geolocation.watchPosition(
                    handlePositionUpdate,
                    handleGeolocationError,
                    { enableHighAccuracy: true, maximumAge: 3000, timeout: 7000 } 
                );
                if (trackingPointsOrdered.length > 0 && trackingPointsOrdered[0].lat && trackingPointsOrdered[0].lng) {
                    map.setView([trackingPointsOrdered[0].lat, trackingPointsOrdered[0].lng], 16); 
                }
                highlightNextStopInList(); 
            } else {
                alert("La geolocalización no está disponible en tu navegador.");
                stopTracking(false); 
            }
             updateManualNavButtons();
        }

        function stopTracking(completedNaturally = false) {
            if (trackingIntervalId) {
                navigator.geolocation.clearWatch(trackingIntervalId);
                trackingIntervalId = null;
            }
            isTracking = false;
            lastKnownPosition = null;
            document.getElementById('startTrackingBtn').style.display = 'inline-block';
            document.getElementById('stopTrackingBtn').style.display = 'none';
            document.getElementById('statusDisplay').style.display = 'none';
            document.getElementById('routeCreationSection').style.display = 'block'; 
            
            if (userMarker) { map.removeLayer(userMarker); userMarker = null; }
            document.getElementById('timeDeviation').textContent = "00:00";
            document.getElementById('timeDeviation').style.color = "#FFFFFF";
            document.getElementById('speedDisplay').textContent = "Velocidad: 0 KM/H";
            
            const currentRouteName = document.getElementById('routeName').value;
            if (currentRouteName && localStorage.getItem(CACHE_PREFIX + currentRouteName)) {
                 loadRoute(); 
            } else {
                updateAllMarkerIconsAndLabels();
                updateStopsList(); 
            }
            currentSegmentStartIndex = 0; 
            updateManualNavButtons();

            if (completedNaturally) {
                alert("Ruta completada!");
                checkRouteQueue();
            } else {
                console.log("Seguimiento detenido.");
            }
        }
        
        function updateManualNavButtons() {
            const manualNav = document.getElementById('manualStopNav').checked;
            const prevBtn = document.getElementById('prevStopBtn');
            const nextBtn = document.getElementById('nextStopBtn');
            const trackingStops = getSortedRoutePointsForTracking();

            if (isTracking && manualNav && trackingStops.length > 0) {
                prevBtn.style.display = 'inline-block';
                nextBtn.style.display = 'inline-block';
                prevBtn.disabled = currentSegmentStartIndex === 0;
                nextBtn.disabled = currentSegmentStartIndex >= trackingStops.length - 2; 
            } else {
                prevBtn.style.display = 'none';
                nextBtn.style.display = 'none';
            }
        }

        document.getElementById('manualStopNav').addEventListener('change', updateManualNavButtons);

        function handlePositionUpdate(position) {
            lastKnownPosition = position;
            const { latitude, longitude, speed } = position.coords;
            const userLatLng = L.latLng(latitude, longitude);

            if (!userMarker) userMarker = L.marker(userLatLng, { icon: createUserLocationIcon() }).addTo(map);
            else userMarker.setLatLng(userLatLng);
            map.panTo(userLatLng, {animate: true, duration: 0.5}); 

            const speedKmh = speed ? (speed * 3.6).toFixed(1) : 0;
            document.getElementById('speedDisplay').textContent = `Velocidad: ${speedKmh} KM/H`;

            const trackingStops = getSortedRoutePointsForTracking();
            if (currentSegmentStartIndex < trackingStops.length - 1) { 
                const manualNav = document.getElementById('manualStopNav').checked;
                let advancedOrJumpedThisTick = false; 

                if (!manualNav) {
                    const currentTargetStopIndexInTrackingList = currentSegmentStartIndex + 1;
                    const currentTargetStop = trackingStops[currentTargetStopIndexInTrackingList]; 
                    
                    let bestCandidateStop = currentTargetStop;
                    let bestCandidateStopIndexInTrackingList = currentTargetStopIndexInTrackingList;
                    let minDistanceToCandidate = userLatLng.distanceTo(L.latLng(currentTargetStop.lat, currentTargetStop.lng));

                    const lookAheadWindowSize = 3; 
                    const firstStopInWindowIndex = currentTargetStopIndexInTrackingList;
                    const lastStopInWindowExclusiveIndex = Math.min(trackingStops.length, firstStopInWindowIndex + lookAheadWindowSize);

                    for (let i = firstStopInWindowIndex; i < lastStopInWindowExclusiveIndex; i++) {
                        const potentialStop = trackingStops[i];
                        const distanceToPotentialStop = userLatLng.distanceTo(L.latLng(potentialStop.lat, potentialStop.lng));

                        if (distanceToPotentialStop < minDistanceToCandidate) {
                            minDistanceToCandidate = distanceToPotentialStop;
                            bestCandidateStop = potentialStop;
                            bestCandidateStopIndexInTrackingList = i;
                        }
                    }
                    
                    const arrivalRadius = currentStopRadius; 
                    const jumpConsiderationRadius = arrivalRadius * 2.5;
                    
                    if (bestCandidateStopIndexInTrackingList !== currentTargetStopIndexInTrackingList && minDistanceToCandidate < jumpConsiderationRadius ) {
                        currentSegmentStartIndex = bestCandidateStopIndexInTrackingList - 1; 
                        advanceToNextStop(); 
                        advancedOrJumpedThisTick = true;
                    }
                    else if (bestCandidateStopIndexInTrackingList === currentTargetStopIndexInTrackingList && minDistanceToCandidate < arrivalRadius) {
                        advanceToNextStop();
                        advancedOrJumpedThisTick = true;
                    }
                }

                if (!advancedOrJumpedThisTick) {
                    calculateTimeDeviation(position); 
                }

            } else { 
                document.getElementById('nextStopDisplay').textContent = "Ruta Completada";
                document.getElementById('timeDeviation').textContent = "00:00"; 
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                if(isTracking) stopTracking(true); 
            }
        }

        function advanceToNextStop() {
            const trackingStops = getSortedRoutePointsForTracking();
            currentSegmentStartIndex++;
            if (currentSegmentStartIndex >= trackingStops.length - 1) { 
                 if (isTracking) stopTracking(true); 
            } else {
                highlightNextStopInList();
                updateManualNavButtons();
                if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition); 
            }
        }
        
        function goToPreviousStop() {
            if (currentSegmentStartIndex > 0) {
                currentSegmentStartIndex--;
                highlightNextStopInList();
                updateManualNavButtons();
                if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition);
            }
        }

        function goToNextStop() { 
            const trackingStops = getSortedRoutePointsForTracking();
             if (currentSegmentStartIndex < trackingStops.length - 2) { 
                advanceToNextStop(); 
            } else if (currentSegmentStartIndex === trackingStops.length - 2) { 
                advanceToNextStop(); 
            }
        }

        function highlightNextStopInList() {
            const listItems = document.querySelectorAll('#stopsList .stop-item');
            listItems.forEach(item => item.classList.remove('next-stop-highlight'));
            
            const displayStops = getSortedRoutePointsForDisplay(); 
            const trackingStops = getSortedRoutePointsForTracking(); 

            if (isTracking && trackingStops.length > 0 && currentSegmentStartIndex < trackingStops.length - 1) {
                const nextActualTrackingStop = trackingStops[currentSegmentStartIndex + 1]; 
                document.getElementById('nextStopDisplay').textContent = `Próxima: ${nextActualTrackingStop.name}`;
                
                const displayIndex = displayStops.findIndex(dp => dp === nextActualTrackingStop);
                if (displayIndex !== -1 && listItems[displayIndex]) {
                    listItems[displayIndex].classList.add('next-stop-highlight');
                }
            } else if (!isTracking && displayStops.length > 0) {
                 document.getElementById('nextStopDisplay').textContent = `Próxima: ${displayStops[0].name}`;
                 if(listItems[0]) listItems[0].classList.add('next-stop-highlight'); 
            } else {
                document.getElementById('nextStopDisplay').textContent = "Próxima Parada: N/A";
            }
        }

        function calculateTimeDeviation(currentUserGeoPosition) { 
            const trackingStops = getSortedRoutePointsForTracking();
            if (!isTracking || currentSegmentStartIndex >= trackingStops.length - 1) return;

            const pointA = trackingStops[currentSegmentStartIndex];
            const pointB = trackingStops[currentSegmentStartIndex + 1];

            if (!pointA || !pointB || !pointA.scheduledTime || !pointB.scheduledTime) {
                document.getElementById('timeDeviation').textContent = "N/A_T";
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                return;
            }
            const scheduledTimeA = new Date(pointA.scheduledTime);
            const scheduledTimeB = new Date(pointB.scheduledTime);
            const segmentTotalScheduledMillis = scheduledTimeB.getTime() - scheduledTimeA.getTime();

            if (segmentTotalScheduledMillis <= 0) {
                document.getElementById('timeDeviation').textContent = "ERR_DUR";
                document.getElementById('timeDeviation').style.color = "#FFA500";
                return;
            }

            const latLngA = L.latLng(pointA.lat, pointA.lng);
            const latLngB = L.latLng(pointB.lat, pointB.lng);
            const currentUserLatLng = L.latLng(currentUserGeoPosition.coords.latitude, currentUserGeoPosition.coords.longitude);

            const distanceTotalSegment = latLngA.distanceTo(latLngB); 
            let progressPercentage;

            if (distanceTotalSegment < 1.0) { 
                const now = new Date();
                let expectedTimeAtCurrentPosMillis;
                if (currentUserLatLng.distanceTo(latLngB) < currentUserLatLng.distanceTo(latLngA)) {
                    expectedTimeAtCurrentPosMillis = scheduledTimeB.getTime();
                } else {
                    expectedTimeAtCurrentPosMillis = scheduledTimeA.getTime();
                }
                const deviationMillisSpecial = expectedTimeAtCurrentPosMillis - now.getTime();
                displayDeviation(deviationMillisSpecial);
                return;
            }

            const distToA = currentUserLatLng.distanceTo(latLngA); 
            const distToB = currentUserLatLng.distanceTo(latLngB); 

            if (distToA < 10.0) progressPercentage = 0.0;
            else if (distToB < 10.0) progressPercentage = 1.0;
            else if (Math.abs(distToA - (distanceTotalSegment + distToB)) < 20.0 && distToA > distanceTotalSegment) progressPercentage = 1.0; 
            else if (Math.abs(distToB - (distanceTotalSegment + distToA)) < 20.0 && distToB > distanceTotalSegment) progressPercentage = 0.0; 
            else {
                const dist_A_to_P_prime_on_AB = (Math.pow(distanceTotalSegment, 2) + Math.pow(distToA, 2) - Math.pow(distToB, 2)) / (2 * distanceTotalSegment);
                progressPercentage = dist_A_to_P_prime_on_AB / distanceTotalSegment;
            }
            progressPercentage = Math.max(0, Math.min(1, progressPercentage));
            const expectedTimeElapsedMillis = segmentTotalScheduledMillis * progressPercentage;
            const expectedTimeAtCurrentPosition = new Date(scheduledTimeA.getTime() + expectedTimeElapsedMillis);
            const currentTime = new Date();
            const deviationMillis = expectedTimeAtCurrentPosition.getTime() - currentTime.getTime();
            displayDeviation(deviationMillis);
        }

        function displayDeviation(deviationMillis) { 
            const absMillis = Math.abs(deviationMillis);
            const totalSecondsValue = Math.floor(absMillis / 1000);
            const displaySeconds = totalSecondsValue % 60;
            const totalMinutesValue = Math.floor(totalSecondsValue / 60);
            const sign = deviationMillis >= 0 ? "+" : "-";
            
            const formattedDeviation = `${sign}${String(totalMinutesValue).padStart(2, '0')}:${String(displaySeconds).padStart(2, '0')}`;
            const deviationDiv = document.getElementById('timeDeviation');
            deviationDiv.textContent = formattedDeviation;

            if (deviationMillis >= -59999 && deviationMillis <= 59999) deviationDiv.style.color = "#FFFFFF"; 
            else if (deviationMillis > 59999) deviationDiv.style.color = "#00FF00"; 
            else deviationDiv.style.color = "#FF0000"; 
        }

        function handleGeolocationError(error) { 
            console.error("Error de geolocalización: ", error);
            alert(`Error de geolocalización: ${error.message}. El seguimiento puede no funcionar correctamente.`);
            if (isTracking) stopTracking(false); 
        }

        // --- Route Queue Logic ---
        function getRouteQueue() { 
            const storedQueue = localStorage.getItem(ROUTE_QUEUE_CACHE_KEY);
            return storedQueue ? JSON.parse(storedQueue) : [];
        }
        function saveRouteQueue(queue) { 
            localStorage.setItem(ROUTE_QUEUE_CACHE_KEY, JSON.stringify(queue));
            updateRouteQueueDisplay();
        }
        function addRouteToQueue() { 
             const selectedRouteName = document.getElementById('routeToQueue').value;
            if (!selectedRouteName || document.getElementById('routeToQueue').options[0]?.disabled) { 
                alert("Selecciona una ruta válida para añadir a la cola.");
                return;
            }
            const queue = getRouteQueue();
            if (queue.includes(selectedRouteName)) {
                alert(`La ruta "${selectedRouteName}" ya está en la cola.`);
                return;
            }
            queue.push(selectedRouteName);
            saveRouteQueue(queue);
            alert(`Ruta "${selectedRouteName}" añadida a la cola.`);
        }
        function updateRouteQueueDisplay() { 
            const queueDiv = document.getElementById('routeQueueDisplay');
            const queue = getRouteQueue();
            if (queue.length === 0) {
                queueDiv.innerHTML = "Vacía.";
            } else {
                let html = "<ol>";
                queue.forEach(routeName => {
                    html += `<li>${routeName}</li>`;
                });
                html += "</ol>";
                queueDiv.innerHTML = html;
            }
        }
        function clearRouteQueue() { 
            if (confirm("¿Limpiar toda la cola de rutas?")) {
                 saveRouteQueue([]);
            }
        }
        function checkRouteQueue() { 
            let queue = getRouteQueue();
            if (queue.length > 0) {
                const nextRouteName = queue.shift(); 
                saveRouteQueue(queue); 

                if (confirm(`La ruta actual ha finalizado. ¿Iniciar la siguiente ruta en cola: "${nextRouteName}"?`)) {
                    const savedRoutesSelect = document.getElementById('savedRoutes');
                    if (Array.from(savedRoutesSelect.options).some(opt => opt.value === nextRouteName)) {
                        savedRoutesSelect.value = nextRouteName; 
                        loadRoute(); 
                        setTimeout(() => {
                            const currentLoadedStopsForTracking = getSortedRoutePointsForTracking(); 
                            if (currentLoadedStopsForTracking.length >= 2 && 
                                currentLoadedStopsForTracking.some(p=>p.type==='start') && 
                                currentLoadedStopsForTracking.some(p=>p.type==='end')) {
                                startTracking();
                            } else {
                                 alert("Error al cargar la siguiente ruta de la cola ('" + nextRouteName + "') o la ruta es inválida para seguimiento (requiere inicio/fin con horarios).")
                            }
                        }, 500); 
                    } else {
                        alert(`La ruta "${nextRouteName}" no se encontró en las rutas guardadas. No se pudo cargar.`);
                    }
                } else {
                    alert("Siguiente ruta de la cola no iniciada. Puedes iniciarla manualmente.");
                }
            } else {
                console.log("Cola de rutas vacía.");
            }
        }

        // --- Radius Settings ---
        function updateGlobalStopRadiusSettings() { 
             const newRadius = parseInt(document.getElementById('stopRadiusInput').value, 10);
            if (!isNaN(newRadius) && newRadius >= 10 && newRadius <= 500) {
                currentStopRadius = newRadius;
                routePoints.forEach(point => {
                    if (point.pointCategory === 'stop' && point.radiusCircle) { 
                        point.radiusCircle.setRadius(currentStopRadius);
                    }
                });
            } else {
                alert("Radio inválido. Debe estar entre 10 y 500 metros.");
                document.getElementById('stopRadiusInput').value = currentStopRadius;
            }
        }

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadSavedRoutesLists(); 
            updateStopsList(); 
            updateManualNavButtons();
        });

    </script>
</body>
</html>
