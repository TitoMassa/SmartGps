<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Evita scroll en el body */
        }

        #map {
            flex-grow: 1;
            min-height: 50vh; /* Asegura que el mapa tenga una altura mínima */
            background-color: #111; /* Fondo oscuro para el mapa antes de cargar */
        }

        #controls-container {
            padding: 10px;
            background-color: #1A1A1A;
            overflow-y: auto; /* Permite scroll si los controles exceden el espacio */
            flex-shrink: 0; /* Evita que se encoja demasiado */
            max-height: 50vh; /* Límite para que no ocupe toda la pantalla */
        }

        .control-section {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #333333;
            border-radius: 5px;
        }

        .control-section h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #4CAF50; /* Un toque de color para los títulos */
        }

        button, input, select {
            background-color: #333333;
            color: #FFFFFF;
            border: 1px solid #555555;
            padding: 8px 12px;
            margin: 5px 2px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        button:hover {
            background-color: #4CAF50;
        }
        
        button:disabled {
            background-color: #555;
            color: #888;
            cursor: not-allowed;
        }

        input[type="text"], input[type="time"] {
            width: calc(100% - 28px); /* Ajustar padding y borde */
        }
        
        input[type="checkbox"] {
            vertical-align: middle;
        }

        label {
            margin-right: 5px;
        }

        #stop-list ul {
            list-style: none;
            padding: 0;
        }

        #stop-list li {
            background-color: #282828;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        #stop-list li.next-stop {
            background-color: #4CAF50;
            color: #000;
            font-weight: bold;
        }

        #tracking-info div {
            margin-bottom: 5px;
            font-size: 1em;
        }

        #time-deviation.adelantado {
            color: #4CAF50; /* Verde */
            font-weight: bold;
        }

        #time-deviation.atrasado {
            color: #F44336; /* Rojo */
            font-weight: bold;
        }
        
        #time-deviation.atiempo {
            color: #FFFFFF; 
        }

        /* Estilos para el modal de inputs */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: #1A1A1A;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 350px;
            border-radius: 8px;
        }
        .modal-content label {
            display: block;
            margin-bottom: 5px;
        }
        .modal-content input {
            width: calc(100% - 24px);
            margin-bottom: 10px;
        }
        .modal-buttons button {
            width: 48%;
        }

        /* Iconos de Leaflet */
        .leaflet-div-icon {
            background: transparent;
            border: none;
        }
        .custom-icon-content {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .user-position-icon {
            background-color: #2196F3 !important; /* Azul para el usuario */
            border: 2px solid white;
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <div id="controls-container">
        <!-- Sección de Creación de Ruta -->
        <div id="route-creation-section" class="control-section">
            <h3>Crear Ruta</h3>
            <p>Toca el mapa para agregar paradas: Inicio (con hora) -> Final (con hora) -> Intermedias (opcional).</p>
            <button id="btn-reset-temp-route">Limpiar Paradas Temporales</button>
            <button id="btn-finalize-route" disabled>Finalizar y Nombrar Ruta</button>
            <div>
                <label for="chk-auto-horarios">Calcular horarios intermedios automáticamente:</label>
                <input type="checkbox" id="chk-auto-horarios" checked>
            </div>
            <div id="temp-stop-list">
                <h4>Paradas Temporales:</h4>
                <ul></ul>
            </div>
        </div>

        <!-- Modal para ingresar datos de parada -->
        <div id="stop-details-modal" class="modal">
            <div class="modal-content">
                <h4 id="modal-title">Detalles de Parada</h4>
                <label for="stop-name">Nombre:</label>
                <input type="text" id="stop-name" placeholder="Ej: Estación Central">
                <label for="stop-time" id="label-stop-time">Hora (HH:MM):</label>
                <input type="time" id="stop-time">
                <div class="modal-buttons">
                    <button id="btn-confirm-stop-details">Aceptar</button>
                    <button id="btn-cancel-stop-details">Cancelar</button>
                </div>
            </div>
        </div>
        
        <!-- Modal para nombrar ruta al guardar -->
        <div id="save-route-modal" class="modal">
            <div class="modal-content">
                <h4>Guardar Ruta</h4>
                <label for="route-name-save">Nombre de la Ruta:</label>
                <input type="text" id="route-name-save" placeholder="Ej: Recorrido Matutino">
                <div class="modal-buttons">
                    <button id="btn-confirm-save-route">Guardar</button>
                    <button id="btn-cancel-save-route">Cancelar</button>
                </div>
            </div>
        </div>

        <!-- Sección de Rutas Guardadas -->
        <div id="saved-routes-section" class="control-section">
            <h3>Rutas Guardadas</h3>
            <select id="saved-routes-dropdown"></select>
            <button id="btn-load-route">Cargar Ruta</button>
            <button id="btn-delete-route">Borrar Ruta</button>
            <button id="btn-add-to-queue">Añadir a Cola</button>
        </div>

        <!-- Sección de Visualización de Ruta Actual -->
        <div id="current-route-display-section" class="control-section" style="display: none;">
            <h3 id="current-route-name-display">Ruta Actual</h3>
            <div id="stop-list">
                <ul></ul>
            </div>
        </div>
        
        <!-- Sección de Seguimiento -->
        <div id="tracking-section" class="control-section" style="display: none;">
            <h3>Seguimiento en Tiempo Real</h3>
            <button id="btn-start-tracking">Iniciar Seguimiento</button>
            <button id="btn-stop-tracking" disabled>Detener Seguimiento</button>
            <div id="tracking-info" style="margin-top: 10px;">
                <div>Velocidad: <span id="current-speed">--</span> km/h</div>
                <div>Desvío Horario: <span id="time-deviation">--:--</span></div>
                <div>Próxima Parada: <span id="next-stop-name">--</span></div>
            </div>
            <div>
                <input type="checkbox" id="chk-manual-advance" checked>
                <label for="chk-manual-advance">Avance Manual de Parada</label>
            </div>
            <button id="btn-prev-stop" disabled>Parada Anterior</button>
            <button id="btn-next-stop" disabled>Parada Siguiente</button>
        </div>

        <!-- Sección Cola de Rutas -->
        <div id="route-queue-section" class="control-section">
            <h3>Cola de Rutas</h3>
            <ul id="route-queue-list"></ul>
            <button id="btn-clear-queue">Limpiar Cola</button>
             <div>
                <input type="checkbox" id="chk-auto-start-next-route" checked>
                <label for="chk-auto-start-next-route">Iniciar siguiente ruta automáticamente</label>
            </div>
        </div>

    </div>

    <script>
        // Variables globales
        let map;
        let tempStops = []; // { latlng, name, time (string HH:MM), type: 'start'/'intermediate'/'end' }
        let currentRoute = null; // { name: string, stops: [], polylinePoints: [] }
        let stopMarkers = [];
        let routePolyline = null;
        let userMarker = null;
        let watchId = null;
        let isTracking = false;
        let currentStopIndex = 0; // Índice de la PRÓXIMA parada en currentRoute.stops
        let routeQueue = []; // Array de nombres de rutas
        
        const CACHE_NAME = 'smartmove-pro-routes';

        // Elementos del DOM
        const btnResetTempRoute = document.getElementById('btn-reset-temp-route');
        const btnFinalizeRoute = document.getElementById('btn-finalize-route');
        const chkAutoHorarios = document.getElementById('chk-auto-horarios');
        const tempStopListUl = document.querySelector('#temp-stop-list ul');
        
        const stopDetailsModal = document.getElementById('stop-details-modal');
        const modalTitle = document.getElementById('modal-title');
        const stopNameInput = document.getElementById('stop-name');
        const stopTimeInput = document.getElementById('stop-time');
        const labelStopTime = document.getElementById('label-stop-time');
        const btnConfirmStopDetails = document.getElementById('btn-confirm-stop-details');
        const btnCancelStopDetails = document.getElementById('btn-cancel-stop-details');
        
        const saveRouteModal = document.getElementById('save-route-modal');
        const routeNameSaveInput = document.getElementById('route-name-save');
        const btnConfirmSaveRoute = document.getElementById('btn-confirm-save-route');
        const btnCancelSaveRoute = document.getElementById('btn-cancel-save-route');

        const savedRoutesDropdown = document.getElementById('saved-routes-dropdown');
        const btnLoadRoute = document.getElementById('btn-load-route');
        const btnDeleteRoute = document.getElementById('btn-delete-route');
        const btnAddToQueue = document.getElementById('btn-add-to-queue');

        const currentRouteDisplaySection = document.getElementById('current-route-display-section');
        const currentRouteNameDisplay = document.getElementById('current-route-name-display');
        const stopListUl = document.querySelector('#stop-list ul');
        
        const trackingSection = document.getElementById('tracking-section');
        const btnStartTracking = document.getElementById('btn-start-tracking');
        const btnStopTracking = document.getElementById('btn-stop-tracking');
        const currentSpeedSpan = document.getElementById('current-speed');
        const timeDeviationSpan = document.getElementById('time-deviation');
        const nextStopNameSpan = document.getElementById('next-stop-name');
        const chkManualAdvance = document.getElementById('chk-manual-advance');
        const btnPrevStop = document.getElementById('btn-prev-stop');
        const btnNextStop = document.getElementById('btn-next-stop');
        
        const routeQueueListUl = document.getElementById('route-queue-list');
        const btnClearQueue = document.getElementById('btn-clear-queue');
        const chkAutoStartNextRoute = document.getElementById('chk-auto-start-next-route');

        let currentMapClickCallback = null; // Para manejar promesas de clicks en mapa

        // --- INICIALIZACIÓN ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadRoutesFromCache();
            setupEventListeners();
            updateTempStopListDisplay(); // Inicialmente vacía
        });

        function initMap() {
            map = L.map('map').setView([ -34.6037, -58.3816 ], 13); // Buenos Aires como ejemplo
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            map.on('click', onMapClick);
            
            // Intentar obtener ubicación inicial para centrar el mapa
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    map.setView([position.coords.latitude, position.coords.longitude], 15);
                }, () => {
                    console.warn("No se pudo obtener la ubicación inicial.");
                });
            }
        }

        function setupEventListeners() {
            btnResetTempRoute.addEventListener('click', resetTempRoute);
            btnFinalizeRoute.addEventListener('click', () => {
                if (tempStops.length < 2) {
                    alert("Necesitas al menos una parada de inicio y una de fin.");
                    return;
                }
                routeNameSaveInput.value = '';
                saveRouteModal.style.display = 'flex';
            });

            btnConfirmStopDetails.addEventListener('click', confirmStopDetails);
            btnCancelStopDetails.addEventListener('click', () => {
                stopDetailsModal.style.display = 'none';
                if (currentMapClickCallback) currentMapClickCallback(null); // Resuelve promesa con null
            });

            btnConfirmSaveRoute.addEventListener('click', handleSaveRoute);
            btnCancelSaveRoute.addEventListener('click', () => saveRouteModal.style.display = 'none');
            
            btnLoadRoute.addEventListener('click', loadSelectedRoute);
            btnDeleteRoute.addEventListener('click', deleteSelectedRoute);
            btnAddToQueue.addEventListener('click', addSelectedRouteToQueue);

            btnStartTracking.addEventListener('click', startTracking);
            btnStopTracking.addEventListener('click', stopTracking);
            
            chkManualAdvance.addEventListener('change', () => {
                btnPrevStop.disabled = !isTracking || !chkManualAdvance.checked;
                btnNextStop.disabled = !isTracking || !chkManualAdvance.checked;
            });
            btnPrevStop.addEventListener('click', manualPrevStop);
            btnNextStop.addEventListener('click', manualNextStop);

            btnClearQueue.addEventListener('click', clearRouteQueue);
        }

        // --- LÓGICA DE CREACIÓN DE RUTA ---
        function onMapClick(e) {
            let type;
            let requiresTime = false;
            let modalTitleText = "Añadir Parada Intermedia";

            if (tempStops.length === 0) {
                type = 'start';
                requiresTime = true;
                modalTitleText = "Definir Inicio de Ruta";
            } else if (tempStops.length === 1) {
                type = 'end';
                requiresTime = true;
                modalTitleText = "Definir Fin de Ruta";
            } else {
                type = 'intermediate';
                requiresTime = !chkAutoHorarios.checked; // Solo si no es auto
                modalTitleText = "Añadir Parada Intermedia";
            }

            stopNameInput.value = type.charAt(0).toUpperCase() + type.slice(1) + " " + (type === 'intermediate' ? tempStops.length -1 : '');
            stopTimeInput.value = '';
            stopTimeInput.style.display = requiresTime ? 'block' : 'none';
            labelStopTime.style.display = requiresTime ? 'block' : 'none';
            modalTitle.textContent = modalTitleText;

            stopDetailsModal.style.display = 'flex';
            
            // Guardar el callback para cuando se cierre el modal
            currentMapClickCallback = (details) => {
                if (details) {
                    tempStops.push({ 
                        latlng: e.latlng, 
                        name: details.name, 
                        time: details.time, // Puede ser null si no se requiere
                        type: type 
                    });
                    updateTempStopListDisplay();
                    checkFinalizeButton();
                }
                currentMapClickCallback = null; // Limpiar callback
            };
        }

        function confirmStopDetails() {
            const name = stopNameInput.value.trim();
            let time = stopTimeInput.value;
            
            const type = tempStops.length === 0 ? 'start' : (tempStops.length === 1 ? 'end' : 'intermediate');
            const requiresTime = (type === 'start' || type === 'end' || (type === 'intermediate' && !chkAutoHorarios.checked));

            if (!name) {
                alert("El nombre de la parada es obligatorio.");
                return;
            }
            if (requiresTime && !time) {
                alert("La hora es obligatoria para esta parada.");
                return;
            }
            if (!requiresTime) time = null; // Asegurarse que sea null si no se requiere

            if (currentMapClickCallback) {
                currentMapClickCallback({ name, time });
            }
            stopDetailsModal.style.display = 'none';
        }
        
        function updateTempStopListDisplay() {
            tempStopListUl.innerHTML = '';
            tempStops.forEach((stop, index) => {
                const li = document.createElement('li');
                let text = `${index + 1}. ${stop.name} (${stop.type})`;
                if (stop.time) text += ` - ${stop.time}`;
                li.textContent = text;
                tempStopListUl.appendChild(li);
            });
            checkFinalizeButton();
        }

        function checkFinalizeButton() {
            // Se necesitan al menos inicio y fin
            btnFinalizeRoute.disabled = !(tempStops.find(s => s.type === 'start') && tempStops.find(s => s.type === 'end'));
        }

        function resetTempRoute() {
            tempStops = [];
            updateTempStopListDisplay();
            clearMapFeatures(); // Limpia marcadores temporales si los hubiera
        }

        function handleSaveRoute() {
            const routeName = routeNameSaveInput.value.trim();
            if (!routeName) {
                alert("El nombre de la ruta es obligatorio.");
                return;
            }

            if (tempStops.length < 2) {
                alert("La ruta debe tener al menos un inicio y un fin.");
                return;
            }
            
            let newRoute = {
                name: routeName,
                stops: JSON.parse(JSON.stringify(tempStops)), // Clonar para evitar problemas de referencia
                polylinePoints: tempStops.map(s => [s.latlng.lat, s.latlng.lng])
            };

            if (chkAutoHorarios.checked && newRoute.stops.length > 2) {
                calculateIntermediateTimes(newRoute.stops);
            }
            
            // Validar que las horas sean secuenciales
            for (let i = 0; i < newRoute.stops.length - 1; i++) {
                if (newRoute.stops[i].time && newRoute.stops[i+1].time && 
                    timeToMinutes(newRoute.stops[i+1].time) < timeToMinutes(newRoute.stops[i].time)) {
                    alert(`Error en horarios: La parada "${newRoute.stops[i+1].name}" (${newRoute.stops[i+1].time}) no puede ser antes que "${newRoute.stops[i].name}" (${newRoute.stops[i].time}).`);
                    return;
                }
            }

            saveRouteToCache(newRoute)
                .then(() => {
                    alert(`Ruta "${routeName}" guardada.`);
                    saveRouteModal.style.display = 'none';
                    resetTempRoute();
                    loadRoutesFromCache(); // Recargar dropdown
                    setCurrentRoute(newRoute); // Cargar la ruta recién creada
                })
                .catch(err => {
                    console.error("Error guardando ruta:", err);
                    alert("Error al guardar la ruta.");
                });
        }

        function calculateIntermediateTimes(stops) {
            const startIndex = stops.findIndex(s => s.type === 'start');
            const endIndex = stops.findIndex(s => s.type === 'end');

            if (startIndex === -1 || endIndex === -1 || !stops[startIndex].time || !stops[endIndex].time) {
                console.warn("No se pueden calcular horarios automáticos: falta inicio/fin o sus horarios.");
                return;
            }

            const startTime = timeToMinutes(stops[startIndex].time);
            const endTime = timeToMinutes(stops[endIndex].time);
            const totalDurationMinutes = endTime - startTime;

            if (totalDurationMinutes <= 0) {
                console.warn("Duración total no positiva, no se pueden calcular horarios.");
                return;
            }

            let relevantStops = [];
            let currentTotalDistance = 0;
            
            // Considerar solo las paradas entre el inicio y el fin, incluyéndolas.
            // Esto asume que las paradas intermedias están entre inicio y fin en el array tempStops
            // Lo cual debería ser por el orden de creación.
            let inRelevantSegment = false;
            for (let i = 0; i < stops.length; i++) {
                if (stops[i].type === 'start') inRelevantSegment = true;
                if (inRelevantSegment) {
                    relevantStops.push(stops[i]);
                    if (stops[i].type === 'end') break; 
                }
            }
            
            if (relevantStops.length <= 2) return; // No hay intermedias entre inicio y fin.

            for (let i = 0; i < relevantStops.length - 1; i++) {
                currentTotalDistance += L.latLng(relevantStops[i].latlng).distanceTo(L.latLng(relevantStops[i+1].latlng));
            }
            
            if (currentTotalDistance === 0) return; // Evitar división por cero

            let accumulatedDistance = 0;
            for (let i = 1; i < relevantStops.length - 1; i++) { // Iterar solo sobre intermedias
                if (relevantStops[i].type === 'intermediate') {
                    accumulatedDistance += L.latLng(relevantStops[i-1].latlng).distanceTo(L.latLng(relevantStops[i].latlng));
                    const timeOffset = Math.round((accumulatedDistance / currentTotalDistance) * totalDurationMinutes);
                    relevantStops[i].time = minutesToTime(startTime + timeOffset);
                } else { // Si no es intermedia, pero está entre start y end (puede ser una 'end' que no es la última del array)
                     accumulatedDistance += L.latLng(relevantStops[i-1].latlng).distanceTo(L.latLng(relevantStops[i].latlng));
                }
            }
             // Actualizar las paradas en el array original 'stops'
            stops.forEach(originalStop => {
                const updatedStop = relevantStops.find(rs => rs.latlng.lat === originalStop.latlng.lat && rs.latlng.lng === originalStop.latlng.lng);
                if (updatedStop && updatedStop.time) {
                    originalStop.time = updatedStop.time;
                }
            });
        }

        // --- PERSISTENCIA (Cache API) ---
        async function saveRouteToCache(route) {
            const cache = await caches.open(CACHE_NAME);
            // Usamos el nombre de la ruta como clave para la Request
            // El cuerpo de la Response será la ruta serializada en JSON
            await cache.put(new Request(route.name), new Response(JSON.stringify(route)));
        }

        async function loadRoutesFromCache() {
            savedRoutesDropdown.innerHTML = '<option value="">Seleccionar ruta...</option>';
            try {
                const cache = await caches.open(CACHE_NAME);
                const requests = await cache.keys();
                for (const request of requests) {
                    // El nombre de la ruta está en request.url (que será el nombre que le dimos)
                    // Para evitar problemas con URLs base, es mejor usar un identificador único si fuera posible
                    // pero para este caso, el nombre de la ruta como parte de la URL simulada funcionará.
                    const routeName = request.url.substring(request.url.lastIndexOf('/') + 1);
                    const option = document.createElement('option');
                    option.value = routeName;
                    option.textContent = decodeURIComponent(routeName); // Decodificar si hay caracteres especiales
                    savedRoutesDropdown.appendChild(option);
                }
            } catch (error) {
                console.error("Error cargando rutas desde cache:", error);
            }
        }
        
        async function getRouteFromCache(routeName) {
            const cache = await caches.open(CACHE_NAME);
            // Es importante que la Request que uses para match sea la misma que usaste para put.
            const response = await cache.match(new Request(routeName));
            if (response) {
                return await response.json();
            }
            return null;
        }

        async function deleteRouteFromCache(routeName) {
            const cache = await caches.open(CACHE_NAME);
            return await cache.delete(new Request(routeName));
        }

        async function loadSelectedRoute() {
            const routeName = savedRoutesDropdown.value;
            if (!routeName) return;

            const route = await getRouteFromCache(routeName);
            if (route) {
                setCurrentRoute(route);
                alert(`Ruta "${route.name}" cargada.`);
            } else {
                alert("No se pudo cargar la ruta.");
            }
        }

        async function deleteSelectedRoute() {
            const routeName = savedRoutesDropdown.value;
            if (!routeName) return;

            if (confirm(`¿Seguro que quieres borrar la ruta "${routeName}"?`)) {
                const success = await deleteRouteFromCache(routeName);
                if (success) {
                    alert(`Ruta "${routeName}" borrada.`);
                    loadRoutesFromCache(); // Recargar dropdown
                    if (currentRoute && currentRoute.name === routeName) {
                        clearCurrentRoute();
                    }
                } else {
                    alert("No se pudo borrar la ruta. Puede que no exista.");
                }
            }
        }

        // --- VISUALIZACIÓN DE RUTA ---
        function setCurrentRoute(route) {
            currentRoute = route;
            clearMapFeatures();
            displayRouteOnMap();
            updateStopListUIDisplay();
            
            currentRouteDisplaySection.style.display = 'block';
            trackingSection.style.display = 'block';
            btnStartTracking.disabled = false;
            btnStopTracking.disabled = true;
            currentRouteNameDisplay.textContent = `Ruta Actual: ${route.name}`;
            
            // Resetear estado de tracking
            currentStopIndex = 0;
            updateNextStopDisplay();
        }

        function clearCurrentRoute() {
            currentRoute = null;
            clearMapFeatures();
            stopListUl.innerHTML = '';
            currentRouteDisplaySection.style.display = 'none';
            trackingSection.style.display = 'none';
            currentRouteNameDisplay.textContent = 'Ruta Actual';
        }

        function clearMapFeatures() {
            stopMarkers.forEach(marker => map.removeLayer(marker));
            stopMarkers = [];
            if (routePolyline) {
                map.removeLayer(routePolyline);
                routePolyline = null;
            }
            if (userMarker) {
                map.removeLayer(userMarker);
                userMarker = null;
            }
        }

        function displayRouteOnMap() {
            if (!currentRoute || !currentRoute.stops || currentRoute.stops.length === 0) return;

            const latLngs = currentRoute.stops.map(stop => stop.latlng);
            routePolyline = L.polyline(latLngs, { color: '#4CAF50' }).addTo(map);
            map.fitBounds(routePolyline.getBounds().pad(0.1)); // pad para dar margen

            currentRoute.stops.forEach((stop, index) => {
                let iconHtml;
                let bgColor = getRandomColor(); // Color aleatorio para fondo de 'I'
                let markerText = '';

                if (stop.type === 'start') {
                    markerText = 'I';
                } else if (stop.type === 'end') {
                    markerText = 'F';
                    bgColor = getRandomColor(); // Diferente color para 'F'
                } else { // intermediate
                    markerText = (currentRoute.stops.filter(s => s.type === 'intermediate').findIndex(is => is === stop) + 1).toString();
                    bgColor = '#777777'; // Gris para intermedias
                }
                
                iconHtml = `<div class="custom-icon-content" style="background-color:${bgColor};">${markerText}</div>`;
                
                const customIcon = L.divIcon({
                    className: 'leaflet-div-icon',
                    html: iconHtml,
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                });

                const marker = L.marker(stop.latlng, { icon: customIcon })
                    .addTo(map)
                    .bindPopup(`<b>${stop.name}</b><br>${stop.type}${stop.time ? '<br>Hora: ' + stop.time : ''}`);
                stopMarkers.push(marker);
            });
        }
        
        function updateStopListUIDisplay() {
            stopListUl.innerHTML = '';
            if (!currentRoute || !currentRoute.stops) return;

            currentRoute.stops.forEach((stop, index) => {
                const li = document.createElement('li');
                li.textContent = `${stop.name} (${stop.type})${stop.time ? ' - ' + stop.time : ''}`;
                if (isTracking && index === currentStopIndex) {
                    li.classList.add('next-stop');
                }
                stopListUl.appendChild(li);
            });
        }

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            // Evitar colores muy claros que no contrasten con texto blanco
            const r = parseInt(color.slice(1,3), 16);
            const g = parseInt(color.slice(3,5), 16);
            const b = parseInt(color.slice(5,7), 16);
            if (r > 200 && g > 200 && b > 200) return getRandomColor(); // Intentar de nuevo
            return color;
        }

        // --- SEGUIMIENTO EN TIEMPO REAL ---
        function startTracking() {
            if (!currentRoute) {
                alert("Carga una ruta primero.");
                return;
            }
            if (isTracking) return;

            if (navigator.geolocation) {
                isTracking = true;
                btnStartTracking.disabled = true;
                btnStopTracking.disabled = false;
                btnLoadRoute.disabled = true; // No cargar otra ruta mientras se rastrea
                btnDeleteRoute.disabled = true; 
                btnAddToQueue.disabled = true;

                btnPrevStop.disabled = !chkManualAdvance.checked;
                btnNextStop.disabled = !chkManualAdvance.checked;
                
                currentStopIndex = 0; // Empezar desde la primera parada
                updateNextStopDisplay();
                updateStopListUIDisplay(); // Para marcar la próxima parada

                const options = { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 };
                watchId = navigator.geolocation.watchPosition(onPositionUpdate, onPositionError, options);
                
                // Mostrar mensaje de inicio
                timeDeviationSpan.textContent = "Iniciando...";
                timeDeviationSpan.className = 'atiempo';
                currentSpeedSpan.textContent = "0";
            } else {
                alert("Geolocalización no soportada por este navegador.");
            }
        }

        function stopTracking(completed = false) {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            isTracking = false;
            btnStartTracking.disabled = (currentRoute === null);
            btnStopTracking.disabled = true;
            btnLoadRoute.disabled = false;
            btnDeleteRoute.disabled = false;
            btnAddToQueue.disabled = false;

            btnPrevStop.disabled = true;
            btnNextStop.disabled = true;
            
            currentSpeedSpan.textContent = '--';
            timeDeviationSpan.textContent = '--:--';
            timeDeviationSpan.className = '';
            nextStopNameSpan.textContent = '--';
            if(userMarker) map.removeLayer(userMarker);
            userMarker = null;

            updateStopListUIDisplay(); // Quitar resaltado de próxima parada

            if (completed) {
                alert("Ruta completada!");
                processRouteQueue(true); // Intentar iniciar la siguiente ruta de la cola
            } else {
                 processRouteQueue(false); // No iniciar automáticamente si se detuvo manualmente
            }
        }

        function onPositionUpdate(position) {
            const { latitude, longitude, speed } = position.coords;
            const userLatlng = L.latLng(latitude, longitude);

            if (!userMarker) {
                const userIconHtml = `<div class="custom-icon-content user-position-icon">P</div>`;
                const userIcon = L.divIcon({
                    className: 'leaflet-div-icon',
                    html: userIconHtml,
                    iconSize: [30, 30],
                    iconAnchor: [15, 30] // Anclar en la base del punto
                });
                userMarker = L.marker(userLatlng, { icon: userIcon, zIndexOffset: 1000 }).addTo(map);
            } else {
                userMarker.setLatLng(userLatlng);
            }
            map.panTo(userLatlng, {animate: true});

            currentSpeedSpan.textContent = speed ? (speed * 3.6).toFixed(1) : '0.0'; // m/s a km/h

            calculateTimeDeviation(userLatlng);
            if (!chkManualAdvance.checked) {
                checkAutomaticStopAdvance(userLatlng);
            }
        }

        function onPositionError(error) {
            console.error("Error de Geolocalización:", error);
            alert(`Error de geolocalización: ${error.message}`);
            if (error.code === error.PERMISSION_DENIED) {
                stopTracking(); // Detener si se niegan permisos
            }
        }
        
        function calculateTimeDeviation(currentUserLatlng) {
            if (!currentRoute || currentRoute.stops.length < 2 || currentStopIndex >= currentRoute.stops.length) {
                timeDeviationSpan.textContent = 'N/A';
                timeDeviationSpan.className = 'atiempo';
                return;
            }

            // Determinar el segmento actual: prevStop -> nextStop
            // Si currentStopIndex es 0, el segmento es desde la posición actual (asumida como inicio) hasta la primera parada.
            // O mejor, el segmento es desde la parada de inicio real hasta la primera parada objetivo (currentStopIndex).
            
            let prevStop, nextStop;
            
            if (currentStopIndex === 0) { // Antes de la primera parada
                prevStop = currentRoute.stops.find(s => s.type === 'start');
                nextStop = currentRoute.stops[0]; // La primera parada de la lista, sea cual sea su tipo
                if (!prevStop) { // Si no hay parada 'start', usar la primera parada como 'inicio' conceptual
                    prevStop = currentRoute.stops[0];
                    nextStop = currentRoute.stops.length > 1 ? currentRoute.stops[1] : currentRoute.stops[0];
                }
            } else {
                prevStop = currentRoute.stops[currentStopIndex - 1];
                nextStop = currentRoute.stops[currentStopIndex];
            }

            if (!prevStop || !nextStop || !prevStop.time || !nextStop.time) {
                timeDeviationSpan.textContent = 'Info Horaria Incompleta';
                timeDeviationSpan.className = 'atiempo';
                return;
            }

            const prevStopLatlng = L.latLng(prevStop.latlng.lat, prevStop.latlng.lng);
            const nextStopLatlng = L.latLng(nextStop.latlng.lat, nextStop.latlng.lng);

            const segmentTotalDistance = prevStopLatlng.distanceTo(nextStopLatlng);
            const distanceTravelledInSegment = prevStopLatlng.distanceTo(currentUserLatlng);

            // Proyección del punto actual sobre el segmento para una mejor estimación del progreso
            // Esto es más complejo, por ahora usamos distancia directa.
            // Una forma simple es tomar la distancia al punto de inicio del segmento.

            let progressRatio = 0;
            if (segmentTotalDistance > 0) {
                progressRatio = distanceTravelledInSegment / segmentTotalDistance;
                progressRatio = Math.max(0, Math.min(1, progressRatio)); // Limitar a 0-1
            } else if (distanceTravelledInSegment === 0) { // Estás en el punto de inicio y el segmento es de longitud 0
                 progressRatio = 0; // O 1, dependiendo de la lógica
            } else { // Estás en un punto diferente, pero el segmento es de longitud 0
                progressRatio = 1; // Asumir que ya pasaste el segmento
            }


            const prevStopTimeMinutes = timeToMinutes(prevStop.time);
            const nextStopTimeMinutes = timeToMinutes(nextStop.time);
            const segmentTotalDurationMinutes = nextStopTimeMinutes - prevStopTimeMinutes;

            if (segmentTotalDurationMinutes < 0) { // Hora de siguiente parada es anterior a la previa
                timeDeviationSpan.textContent = 'Error Horario';
                timeDeviationSpan.className = 'atrasado';
                return;
            }

            const expectedTimeAtCurrentPositionMinutes = prevStopTimeMinutes + (segmentTotalDurationMinutes * progressRatio);
            const currentTimeMinutes = timeToMinutes(new Date().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }));
            
            const deviationMinutes = expectedTimeAtCurrentPositionMinutes - currentTimeMinutes; // Positivo = adelantado, Negativo = atrasado
            
            const absDeviationMinutes = Math.abs(deviationMinutes);
            const sign = deviationMinutes >= 0 ? '+' : '-';
            const devMins = Math.floor(absDeviationMinutes);
            const devSecs = Math.floor((absDeviationMinutes - devMins) * 60);

            timeDeviationSpan.textContent = `${sign}${String(devMins).padStart(2, '0')}:${String(devSecs).padStart(2, '0')}`;
            
            if (deviationMinutes > 0.25) { // Más de 15 segundos adelantado
                timeDeviationSpan.className = 'adelantado';
            } else if (deviationMinutes < -0.25) { // Más de 15 segundos atrasado
                timeDeviationSpan.className = 'atrasado';
            } else {
                timeDeviationSpan.className = 'atiempo';
            }
        }
        
        function checkAutomaticStopAdvance(userLatlng) {
            if (!currentRoute || currentStopIndex >= currentRoute.stops.length) return;

            const nextScheduledStop = currentRoute.stops[currentStopIndex];
            const distanceToNextStop = userLatlng.distanceTo(L.latLng(nextScheduledStop.latlng));

            const detectionThreshold = 50; // metros

            if (distanceToNextStop < detectionThreshold) {
                advanceToNextStop();
            } else {
                // Lógica para saltar paradas si se pasó de largo
                // Si está mucho más allá de la parada actual Y más cerca de la siguiente-siguiente parada
                if (currentStopIndex < currentRoute.stops.length - 1) {
                    const nextNextScheduledStop = currentRoute.stops[currentStopIndex + 1];
                    const distanceToNextNextStop = userLatlng.distanceTo(L.latLng(nextNextScheduledStop.latlng));
                    
                    // Si estoy más cerca de la N+1 que de la N, y ya pasé un umbral de la N
                    if (distanceToNextNextStop < distanceToNextStop && distanceToNextStop > detectionThreshold * 2) {
                         console.log(`Saltando parada ${nextScheduledStop.name}, más cerca de ${nextNextScheduledStop.name}`);
                         advanceToNextStop(); // Avanza currentStopIndex, luego se re-evaluará
                    }
                }
            }
        }

        function advanceToNextStop() {
            currentStopIndex++;
            if (currentStopIndex >= currentRoute.stops.length) {
                // Ruta completada
                stopTracking(true);
            } else {
                updateNextStopDisplay();
                updateStopListUIDisplay(); // Re-renderizar lista para marcar nueva parada
                // Opcional: dar feedback de que se llegó a una parada
                // alert(`Llegaste a: ${currentRoute.stops[currentStopIndex -1].name}. Próxima: ${currentRoute.stops[currentStopIndex].name}`);
            }
        }

        function manualNextStop() {
            if (!isTracking || currentStopIndex >= currentRoute.stops.length -1) return;
            currentStopIndex++;
            updateNextStopDisplay();
            updateStopListUIDisplay();
        }

        function manualPrevStop() {
            if (!isTracking || currentStopIndex <= 0) return;
            currentStopIndex--;
            updateNextStopDisplay();
            updateStopListUIDisplay();
        }

        function updateNextStopDisplay() {
            if (currentRoute && currentStopIndex < currentRoute.stops.length) {
                nextStopNameSpan.textContent = currentRoute.stops[currentStopIndex].name;
            } else if (currentRoute && currentStopIndex >= currentRoute.stops.length) {
                nextStopNameSpan.textContent = "FIN DE RUTA";
            } else {
                nextStopNameSpan.textContent = "--";
            }
            btnPrevStop.disabled = !isTracking || !chkManualAdvance.checked || currentStopIndex === 0;
            btnNextStop.disabled = !isTracking || !chkManualAdvance.checked || currentStopIndex >= currentRoute.stops.length -1;
        }

        // --- COLA DE RUTAS ---
        function addSelectedRouteToQueue() {
            const routeName = savedRoutesDropdown.value;
            if (!routeName) {
                alert("Selecciona una ruta para añadir a la cola.");
                return;
            }
            if (routeQueue.includes(routeName)) {
                alert("Esta ruta ya está en la cola.");
                return;
            }
            routeQueue.push(routeName);
            updateRouteQueueDisplay();
        }

        function updateRouteQueueDisplay() {
            routeQueueListUl.innerHTML = '';
            routeQueue.forEach((routeName, index) => {
                const li = document.createElement('li');
                li.textContent = `${index + 1}. ${routeName}`;
                routeQueueListUl.appendChild(li);
            });
        }

        function clearRouteQueue() {
            routeQueue = [];
            updateRouteQueueDisplay();
        }

        async function processRouteQueue(previousRouteCompleted) {
            if (routeQueue.length === 0) {
                if (previousRouteCompleted) console.log("Cola de rutas vacía.");
                return;
            }

            if (!previousRouteCompleted && !chkAutoStartNextRoute.checked) {
                 console.log("Siguiente ruta en cola, pero no se iniciará automáticamente.");
                 return;
            }
             if (previousRouteCompleted && !chkAutoStartNextRoute.checked && isTracking) { // Si se completó una y el auto start está off, pero aún está el tracking activo
                console.log("La ruta se completó, pero el inicio automático de la siguiente está desactivado.");
                return;
            }


            const nextRouteName = routeQueue.shift(); // Saca la primera ruta de la cola
            updateRouteQueueDisplay();

            const route = await getRouteFromCache(nextRouteName);
            if (route) {
                alert(`Iniciando siguiente ruta de la cola: ${route.name}`);
                setCurrentRoute(route);
                // Solo iniciar tracking si la anterior fue completada O si el checkbox de auto-inicio está marcado (aunque la anterior no se haya completado)
                if (previousRouteCompleted || chkAutoStartNextRoute.checked) {
                    startTracking();
                }
            } else {
                alert(`No se pudo cargar la ruta "${nextRouteName}" de la cola.`);
                // Intentar con la siguiente si hay más
                if (routeQueue.length > 0) {
                    processRouteQueue(false); // No fue "completada"
                }
            }
        }


        // --- UTILIDADES DE TIEMPO ---
        function timeToMinutes(timeStr) { // "HH:MM"
            if (!timeStr) return 0;
            const [hours, minutes] = timeStr.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function minutesToTime(totalMinutes) {
            const hours = Math.floor(totalMinutes / 60) % 24; // %24 para manejar cruce de medianoche si es necesario
            const minutes = Math.round(totalMinutes % 60); // Redondear minutos
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

    </script>
</body>
</html>
