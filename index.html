<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            height: 100%;
            overflow: hidden; /* Evitar scroll en body */
            background-color: #f0f0f0;
        }
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100vh; /* Ocupar toda la altura de la ventana */
        }
        #map {
            width: 100%;
            height: 50vh; /* El mapa ocupa el 50% de la altura de la pantalla */
            min-height: 300px; /* Altura mínima para el mapa */
            border-bottom: 2px solid #ccc;
        }
        #controls-panel {
            flex-grow: 1; /* El panel de controles ocupa el espacio restante */
            overflow-y: auto; /* Scroll vertical si el contenido excede */
            padding: 10px;
            background-color: #fff;
        }
        .control-section {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .control-section h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        button, select, input[type="text"], input[type="time"], input[type="checkbox"] {
            padding: 8px 12px;
            margin: 5px 2px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9em;
        }
        button {
            background-color: #007bff;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.danger {
            background-color: #dc3545;
        }
        button.danger:hover {
            background-color: #c82333;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        input[type="text"], input[type="time"] {
            width: calc(100% - 28px); /* Ajustar para padding y borde */
        }
        select {
             width: calc(100% - 0px);
        }
        .stop-list-item {
            padding: 5px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .stop-list-item:last-child {
            border-bottom: none;
        }
        .stop-list-item button {
            padding: 3px 6px;
            font-size: 0.8em;
        }
        #tracking-info div {
            margin-bottom: 5px;
            font-size: 0.95em;
        }
        #time-difference {
            font-weight: bold;
            font-size: 1.2em;
        }
        .leaflet-marker-icon.start-icon, .leaflet-marker-icon.end-icon, .leaflet-marker-icon.intermediate-icon {
            text-align: center;
            font-weight: bold;
            color: white;
            border-radius: 50%;
            line-height: 20px; /* Ajustar según tamaño */
            width: 20px !important;
            height: 20px !important;
            border: 1px solid white;
        }
        .start-icon { background-color: green; }
        .end-icon { background-color: red; }
        .intermediate-icon { background-color: orange; }

        .user-marker {
            background-color: blue;
            border-radius: 50%;
            width: 16px !important;
            height: 16px !important;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="map"></div>
        <div id="controls-panel">
            <!-- Sección Creación/Edición de Rutas -->
            <div class="control-section">
                <h3>Definir Ruta Actual</h3>
                <input type="text" id="routeName" placeholder="Nombre de la Ruta (ej. Matutina Centro)">
                
                <div>
                    <label for="startPointName">Nombre Inicio:</label>
                    <input type="text" id="startPointName" placeholder="Ej: Terminal">
                    <label for="startPointTime">Hora Salida:</label>
                    <input type="time" id="startPointTime">
                    <button id="setStartPointBtn">Fijar Inicio en Mapa</button>
                </div>
                <div>
                    <label for="endPointName">Nombre Fin:</label>
                    <input type="text" id="endPointName" placeholder="Ej: Plaza Mayor">
                    <label for="endPointTime">Hora Llegada:</label>
                    <input type="time" id="endPointTime">
                    <button id="setEndPointBtn">Fijar Fin en Mapa</button>
                </div>
                <p><em>Toca el mapa para añadir paradas intermedias (después de fijar Inicio y Fin).</em></p>
                <div>
                    <input type="checkbox" id="autoCalcTimes">
                    <label for="autoCalcTimes">Calcular horarios intermedios automáticamente</label>
                </div>
                <h4>Paradas de la Ruta Actual:</h4>
                <div id="currentRouteStops">Vacío</div>
                <button id="clearRouteEditorBtn">Limpiar Editor</button>
            </div>

            <!-- Sección Gestión de Rutas -->
            <div class="control-section">
                <h3>Gestión de Rutas Guardadas</h3>
                <button id="saveRouteBtn">Guardar Ruta Actual</button>
                <hr>
                <select id="savedRoutesDropdown"></select>
                <button id="loadRouteBtn">Cargar Ruta Seleccionada</button>
                <button id="deleteRouteBtn" class="danger">Eliminar Ruta Seleccionada</button>
            </div>

            <!-- Sección Cola de Seguimiento -->
            <div class="control-section">
                <h3>Cola de Seguimiento</h3>
                <button id="addToQueueBtn">Añadir Ruta Seleccionada a Cola</button>
                <h4>Rutas en Cola:</h4>
                <div id="trackingQueueList">Vacía</div>
                <button id="clearQueueBtn" class="danger">Limpiar Cola</button>
            </div>

            <!-- Sección Seguimiento en Tiempo Real -->
            <div class="control-section">
                <h3>Seguimiento</h3>
                <button id="startTrackingBtn">Iniciar Seguimiento</button>
                <button id="stopTrackingBtn" disabled>Detener Seguimiento</button>
                <div id="tracking-info" class="hidden">
                    <p><strong>Ruta Activa:</strong> <span id="activeRouteName">---</span></p>
                    <p><strong>Próxima Parada:</strong> <span id="nextStopInfo">---</span></p>
                    <p><strong>Diferencia Horaria:</strong> <span id="timeDifference">---</span></p>
                    <div>
                        <input type="checkbox" id="manualControlCheckbox">
                        <label for="manualControlCheckbox">Control Manual Parada/Ruta</label>
                    </div>
                    <button id="prevStopBtn" disabled>Parada Anterior</button>
                    <button id="nextStopBtn" disabled>Parada Siguiente</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    
    <script id="sw-script" type="application/javascript">
    // Contenido del Service Worker (sw.js)
    const CACHE_NAME = 'smart-move-pro-cache-v1';
    const APP_SHELL_URLS = [
        // No podemos cachear el HTML principal si está generado dinámicamente o es el punto de entrada
        // '/smart_move_pro.html', // Asumiendo que este es el nombre del archivo
        // '/css/style.css', // Embebido
        // '/js/app.js', // Embebido
        'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
        'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js',
        'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
        'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',
        'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png'
        // Añadir aquí íconos si se especifican y usan externamente
    ];

    self.addEventListener('install', event => {
        console.log('[SW] Install event');
        event.waitUntil(
            caches.open(CACHE_NAME)
                .then(cache => {
                    console.log('[SW] Caching App Shell');
                    return cache.addAll(APP_SHELL_URLS);
                })
                .catch(error => {
                    console.error('[SW] Failed to cache App Shell:', error);
                })
        );
    });

    self.addEventListener('activate', event => {
        console.log('[SW] Activate event');
        event.waitUntil(
            caches.keys().then(cacheNames => {
                return Promise.all(
                    cacheNames.map(cacheName => {
                        if (cacheName !== CACHE_NAME) {
                            console.log('[SW] Deleting old cache:', cacheName);
                            return caches.delete(cacheName);
                        }
                    })
                );
            })
        );
        return self.clients.claim();
    });

    self.addEventListener('fetch', event => {
        // Solo aplicar estrategia de caché para peticiones GET
        if (event.request.method !== 'GET') {
            event.respondWith(fetch(event.request));
            return;
        }

        event.respondWith(
            caches.match(event.request)
                .then(response => {
                    if (response) {
                        // console.log('[SW] Found in cache:', event.request.url);
                        return response; // Cache hit
                    }
                    // console.log('[SW] Not in cache, fetching:', event.request.url);
                    return fetch(event.request).then(
                        fetchResponse => {
                            // No cachear todo por defecto, solo lo definido en APP_SHELL_URLS
                            // o si se implementa una estrategia más compleja.
                            // Para este caso, si no está en el App Shell, simplemente lo trae de la red.
                            return fetchResponse;
                        }
                    );
                })
                .catch(error => {
                    console.error('[SW] Fetch error:', error);
                    // Podrías devolver una página offline aquí si es necesario
                })
        );
    });
    </script>

    <script>
    // Constantes
    const LOCALSTORAGE_ROUTES_KEY = 'smartMoveProRoutes';
    const LOCALSTORAGE_TRACKING_KEY = 'smartMoveProTrackingStatus';
    const PROXIMITY_THRESHOLD_METERS = 50; // Metros para considerar llegada a parada intermedia
    const GEOFENCE_RADIUS_METERS = 100; // Metros para geofence de inicio/fin

    // Variables Globales
    let map;
    let currentRoute = {
        name: '',
        startPoint: null, // { lat, lng, name, departureTime (HH:MM string) }
        endPoint: null,   // { lat, lng, name, arrivalTime (HH:MM string) }
        intermediateStops: [], // [{ lat, lng, name (opcional), arrivalTime, departureTime }]
        autoCalcTimes: false
    };
    let tempStartMarker = null, tempEndMarker = null;
    let intermediateMarkers = [];
    let routePolyline = null;
    let savedRoutes = [];

    let trackingQueue = []; // Array de nombres de rutas
    let isTracking = false;
    let currentTrackingRoute = null; // La ruta completa (objeto) que se está siguiendo
    let currentTrackingRouteIndexInQueue = -1;
    let currentTrackingStopIndex = -1; // -1: antes de salir de inicio, 0: hacia parada 0 (primera intermedia o fin si no hay interm.), etc.
    let userMarker = null;
    let startGeofenceCircle = null, endGeofenceCircle = null;
    let geolocationWatchId = null;
    let lastKnownPosition = null;
    let timeDiffIntervalId = null;
    let currentBusDelayOrAheadMillis = 0;

    // Elementos del DOM
    const routeNameInput = document.getElementById('routeName');
    const startPointNameInput = document.getElementById('startPointName');
    const startPointTimeInput = document.getElementById('startPointTime');
    const endPointNameInput = document.getElementById('endPointName');
    const endPointTimeInput = document.getElementById('endPointTime');
    const autoCalcTimesCheckbox = document.getElementById('autoCalcTimes');
    const currentRouteStopsDiv = document.getElementById('currentRouteStops');
    const savedRoutesDropdown = document.getElementById('savedRoutesDropdown');
    const trackingQueueListDiv = document.getElementById('trackingQueueList');
    const startTrackingBtn = document.getElementById('startTrackingBtn');
    const stopTrackingBtn = document.getElementById('stopTrackingBtn');
    const trackingInfoDiv = document.getElementById('tracking-info');
    const activeRouteNameSpan = document.getElementById('activeRouteName');
    const nextStopInfoSpan = document.getElementById('nextStopInfo');
    const timeDifferenceSpan = document.getElementById('timeDifference');
    const manualControlCheckbox = document.getElementById('manualControlCheckbox');
    const prevStopBtn = document.getElementById('prevStopBtn');
    const nextStopBtn = document.getElementById('nextStopBtn');

    // --- INICIALIZACIÓN ---
    document.addEventListener('DOMContentLoaded', initApp);

    function initApp() {
        initMap();
        loadRoutesFromLocalStorage();
        updateRoutesDropdown();
        updateTrackingQueueDisplay();
        setupEventListeners();
        registerServiceWorker();
        clearRouteEditor(); // Para asegurar estado inicial limpio
    }

    function registerServiceWorker() {
        if ('serviceWorker' in navigator) {
            const swCode = document.getElementById('sw-script').textContent;
            const swBlob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(swBlob);
            navigator.serviceWorker.register(swUrl)
                .then(reg => console.log('Service Worker registered.', reg))
                .catch(err => console.error('Service Worker registration failed:', err));
        }
    }

    function initMap() {
        map = L.map('map');
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        map.on('click', onMapClick);

        // Centrar mapa en ubicación del usuario o por defecto
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(position => {
                map.setView([position.coords.latitude, position.coords.longitude], 13);
            }, () => {
                map.setView([ -34.6037, -58.3816 ], 12); // Buenos Aires por defecto
                console.warn("No se pudo obtener la ubicación. Usando ubicación por defecto.");
            });
        } else {
            map.setView([ -34.6037, -58.3816 ], 12); // Buenos Aires por defecto
            console.warn("Geolocalización no soportada. Usando ubicación por defecto.");
        }
    }

    function setupEventListeners() {
        document.getElementById('setStartPointBtn').addEventListener('click', () => prepareSetPointOnMap('start'));
        document.getElementById('setEndPointBtn').addEventListener('click', () => prepareSetPointOnMap('end'));
        autoCalcTimesCheckbox.addEventListener('change', () => {
            currentRoute.autoCalcTimes = autoCalcTimesCheckbox.checked;
            if (currentRoute.startPoint && currentRoute.endPoint && currentRoute.intermediateStops.length > 0) {
                recalculateIntermediateTimes();
                renderCurrentRouteStops();
            }
        });
        document.getElementById('clearRouteEditorBtn').addEventListener('click', clearRouteEditor);
        
        document.getElementById('saveRouteBtn').addEventListener('click', saveRoute);
        document.getElementById('loadRouteBtn').addEventListener('click', loadSelectedRoute);
        document.getElementById('deleteRouteBtn').addEventListener('click', deleteSelectedRoute);

        document.getElementById('addToQueueBtn').addEventListener('click', addSelectedRouteToQueue);
        document.getElementById('clearQueueBtn').addEventListener('click', clearTrackingQueue);

        startTrackingBtn.addEventListener('click', startTracking);
        stopTrackingBtn.addEventListener('click', stopTracking);
        manualControlCheckbox.addEventListener('change', toggleManualControl);
        prevStopBtn.addEventListener('click', manualPreviousStop);
        nextStopBtn.addEventListener('click', manualNextStop);
    }

    // --- LÓGICA DE DEFINICIÓN DE RUTA ---
    let settingPointType = null; // 'start' o 'end'

    function prepareSetPointOnMap(type) {
        settingPointType = type;
        alert(`Haz clic en el mapa para fijar el Punto de ${type === 'start' ? 'Inicio' : 'Fin'}.`);
    }

    function onMapClick(e) {
        const { lat, lng } = e.latlng;
        if (settingPointType) {
            if (settingPointType === 'start') {
                currentRoute.startPoint = { lat, lng, name: startPointNameInput.value || "Inicio", departureTime: startPointTimeInput.value };
                if (tempStartMarker) map.removeLayer(tempStartMarker);
                tempStartMarker = L.marker([lat, lng], { icon: createDivIcon('I', 'start-icon') }).addTo(map)
                    .bindPopup(`<b>Inicio:</b> ${currentRoute.startPoint.name}<br>${currentRoute.startPoint.departureTime || 'Sin hora'}`).openPopup();
            } else if (settingPointType === 'end') {
                currentRoute.endPoint = { lat, lng, name: endPointNameInput.value || "Fin", arrivalTime: endPointTimeInput.value };
                if (tempEndMarker) map.removeLayer(tempEndMarker);
                tempEndMarker = L.marker([lat, lng], { icon: createDivIcon('F', 'end-icon') }).addTo(map)
                    .bindPopup(`<b>Fin:</b> ${currentRoute.endPoint.name}<br>${currentRoute.endPoint.arrivalTime || 'Sin hora'}`).openPopup();
            }
            settingPointType = null; // Reset type after setting
            if (currentRoute.startPoint && currentRoute.endPoint) {
                recalculateIntermediateTimes(); // Recalculate if auto is on
            }
        } else if (currentRoute.startPoint && currentRoute.endPoint) {
            // Añadir parada intermedia
            const stopName = prompt("Nombre para esta parada (opcional):", `Parada ${currentRoute.intermediateStops.length + 1}`);
            const newStop = { lat, lng, name: stopName || `Parada ${currentRoute.intermediateStops.length + 1}` };
            
            if (currentRoute.autoCalcTimes) {
                currentRoute.intermediateStops.push(newStop);
                recalculateIntermediateTimes();
            } else {
                const arrivalTime = prompt("Hora de llegada/paso (HH:MM) para esta parada:", "12:00");
                if (isValidTimeFormat(arrivalTime)) {
                    newStop.arrivalTime = arrivalTime;
                    newStop.departureTime = arrivalTime; // Salida = Llegada para intermedias
                    currentRoute.intermediateStops.push(newStop);
                } else {
                    alert("Formato de hora inválido. Parada no añadida.");
                    return;
                }
            }
        } else {
            alert("Por favor, define primero el Punto de Inicio y el Punto de Fin.");
            return;
        }
        renderCurrentRouteStops();
        drawCurrentRouteOnMap();
    }
    
    function isValidTimeFormat(timeStr) {
        if (!timeStr) return false; // Permite tiempos vacíos si no son obligatorios en algún punto
        return /^([01]\d|2[0-3]):([0-5]\d)$/.test(timeStr);
    }

    function createDivIcon(text, className) {
        return L.divIcon({
            className: `leaflet-marker-icon ${className}`,
            html: `<span>${text}</span>`,
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
    }

    function renderCurrentRouteStops() {
        currentRouteStopsDiv.innerHTML = '';
        if (!currentRoute.startPoint) {
            currentRouteStopsDiv.textContent = 'Define un punto de inicio.';
            return;
        }

        const ul = document.createElement('ul');
        
        // Start Point
        let li = document.createElement('li');
        li.className = 'stop-list-item';
        li.textContent = `INICIO: ${currentRoute.startPoint.name || '(Sin nombre)'} - Sale: ${currentRoute.startPoint.departureTime || '(Sin hora)'}`;
        const renameStartBtn = document.createElement('button');
        renameStartBtn.textContent = 'Renombrar';
        renameStartBtn.onclick = () => renamePoint('start');
        li.appendChild(renameStartBtn);
        ul.appendChild(li);

        // Intermediate Stops
        currentRoute.intermediateStops.forEach((stop, index) => {
            li = document.createElement('li');
            li.className = 'stop-list-item';
            li.textContent = `${index + 1}. ${stop.name || '(Sin nombre)'} - Llega/Pasa: ${stop.arrivalTime || '(Sin hora)'}`;
            
            const actionsDiv = document.createElement('div');
            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Renombrar';
            renameBtn.onclick = () => renameIntermediateStop(index);
            actionsDiv.appendChild(renameBtn);

            if (!currentRoute.autoCalcTimes) {
                const editTimeBtn = document.createElement('button');
                editTimeBtn.textContent = 'Hora';
                editTimeBtn.onclick = () => editIntermediateStopTime(index);
                actionsDiv.appendChild(editTimeBtn);
            }

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'X';
            deleteBtn.className = 'danger';
            deleteBtn.onclick = () => deleteIntermediateStop(index);
            actionsDiv.appendChild(deleteBtn);
            
            li.appendChild(actionsDiv);
            ul.appendChild(li);
        });

        // End Point
        if (currentRoute.endPoint) {
            li = document.createElement('li');
            li.className = 'stop-list-item';
            li.textContent = `FIN: ${currentRoute.endPoint.name || '(Sin nombre)'} - Llega: ${currentRoute.endPoint.arrivalTime || '(Sin hora)'}`;
            const renameEndBtn = document.createElement('button');
            renameEndBtn.textContent = 'Renombrar';
            renameEndBtn.onclick = () => renamePoint('end');
            li.appendChild(renameEndBtn);
            ul.appendChild(li);
        } else {
            currentRouteStopsDiv.textContent += ' Define un punto de fin.';
        }
        currentRouteStopsDiv.appendChild(ul);
    }

    function renamePoint(type) {
        const point = type === 'start' ? currentRoute.startPoint : currentRoute.endPoint;
        if (!point) return;
        const newName = prompt(`Nuevo nombre para ${type === 'start' ? 'Inicio' : 'Fin'}:`, point.name);
        if (newName !== null) {
            point.name = newName;
            if (type === 'start') startPointNameInput.value = newName;
            if (type === 'end') endPointNameInput.value = newName;
            renderCurrentRouteStops();
            drawCurrentRouteOnMap(); // Actualizar popups de marcadores
        }
    }

    function renameIntermediateStop(index) {
        const stop = currentRoute.intermediateStops[index];
        const newName = prompt("Nuevo nombre para la parada:", stop.name);
        if (newName !== null) {
            stop.name = newName;
            renderCurrentRouteStops();
            drawCurrentRouteOnMap();
        }
    }
    
    function editIntermediateStopTime(index) {
        const stop = currentRoute.intermediateStops[index];
        const newTime = prompt(`Nueva hora de llegada/paso (HH:MM) para ${stop.name}:`, stop.arrivalTime);
        if (isValidTimeFormat(newTime)) {
            stop.arrivalTime = newTime;
            stop.departureTime = newTime;
            renderCurrentRouteStops();
        } else if (newTime !== null) {
            alert("Formato de hora inválido.");
        }
    }

    function deleteIntermediateStop(index) {
        if (confirm("¿Eliminar esta parada intermedia?")) {
            currentRoute.intermediateStops.splice(index, 1);
            if (currentRoute.autoCalcTimes) recalculateIntermediateTimes();
            renderCurrentRouteStops();
            drawCurrentRouteOnMap();
        }
    }

    function drawCurrentRouteOnMap() {
        // Limpiar marcadores y polilínea anteriores de edición
        if (tempStartMarker) map.removeLayer(tempStartMarker);
        if (tempEndMarker) map.removeLayer(tempEndMarker);
        intermediateMarkers.forEach(m => map.removeLayer(m));
        intermediateMarkers = [];
        if (routePolyline) map.removeLayer(routePolyline);

        const latLngs = [];

        if (currentRoute.startPoint) {
            tempStartMarker = L.marker([currentRoute.startPoint.lat, currentRoute.startPoint.lng], { icon: createDivIcon('I', 'start-icon') })
                .addTo(map).bindPopup(`<b>Inicio:</b> ${currentRoute.startPoint.name}<br>${currentRoute.startPoint.departureTime || 'Sin hora'}`);
            latLngs.push([currentRoute.startPoint.lat, currentRoute.startPoint.lng]);
        }
        currentRoute.intermediateStops.forEach((stop, index) => {
            const marker = L.marker([stop.lat, stop.lng], { icon: createDivIcon(index + 1, 'intermediate-icon') })
                .addTo(map).bindPopup(`<b>${index+1}. ${stop.name}</b><br>${stop.arrivalTime || 'Sin hora'}`);
            intermediateMarkers.push(marker);
            latLngs.push([stop.lat, stop.lng]);
        });
        if (currentRoute.endPoint) {
            tempEndMarker = L.marker([currentRoute.endPoint.lat, currentRoute.endPoint.lng], { icon: createDivIcon('F', 'end-icon') })
                .addTo(map).bindPopup(`<b>Fin:</b> ${currentRoute.endPoint.name}<br>${currentRoute.endPoint.arrivalTime || 'Sin hora'}`);
            latLngs.push([currentRoute.endPoint.lat, currentRoute.endPoint.lng]);
        }

        if (latLngs.length > 1) {
            routePolyline = L.polyline(latLngs, { color: 'blue' }).addTo(map);
        }
    }

    function clearRouteEditor() {
        currentRoute = {
            name: '',
            startPoint: null,
            endPoint: null,
            intermediateStops: [],
            autoCalcTimes: autoCalcTimesCheckbox.checked
        };
        routeNameInput.value = '';
        startPointNameInput.value = '';
        startPointTimeInput.value = '';
        endPointNameInput.value = '';
        endPointTimeInput.value = '';
        
        if (tempStartMarker) map.removeLayer(tempStartMarker);
        if (tempEndMarker) map.removeLayer(tempEndMarker);
        intermediateMarkers.forEach(m => map.removeLayer(m));
        if (routePolyline) map.removeLayer(routePolyline);
        tempStartMarker = null;
        tempEndMarker = null;
        intermediateMarkers = [];
        routePolyline = null;
        
        renderCurrentRouteStops();
    }

    function timeToMinutes(timeStr) { // HH:MM
        if (!timeStr || !isValidTimeFormat(timeStr)) return null;
        const [hours, minutes] = timeStr.split(':').map(Number);
        return hours * 60 + minutes;
    }

    function minutesToTime(totalMinutes) {
        if (totalMinutes === null || totalMinutes === undefined) return '';
        const hours = Math.floor(totalMinutes / 60) % 24; // Handle times past midnight if duration is long
        const minutes = Math.round(totalMinutes % 60); // Round minutes
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    }
    
    function calculateDistance(lat1, lon1, lat2, lon2) { // Haversine
        const R = 6371e3; // metres
        const φ1 = lat1 * Math.PI/180;
        const φ2 = lat2 * Math.PI/180;
        const Δφ = (lat2-lat1) * Math.PI/180;
        const Δλ = (lon2-lon1) * Math.PI/180;

        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c; // in metres
    }

    function recalculateIntermediateTimes() {
        if (!currentRoute.autoCalcTimes || !currentRoute.startPoint || !currentRoute.endPoint || 
            !currentRoute.startPoint.departureTime || !currentRoute.endPoint.arrivalTime ||
            currentRoute.intermediateStops.length === 0) {
            return; // No need or not possible to calculate
        }

        const startTotalMinutes = timeToMinutes(currentRoute.startPoint.departureTime);
        const endTotalMinutes = timeToMinutes(currentRoute.endPoint.arrivalTime);

        if (startTotalMinutes === null || endTotalMinutes === null) {
            console.warn("Tiempos de inicio o fin no válidos para cálculo automático.");
            currentRoute.intermediateStops.forEach(stop => {
                stop.arrivalTime = null;
                stop.departureTime = null;
            });
            return;
        }
        
        let totalRouteDurationMinutes = endTotalMinutes - startTotalMinutes;
        if (totalRouteDurationMinutes <=0) { // Handle overnight or invalid range
            console.warn("Duración total de la ruta es cero o negativa. No se pueden calcular tiempos intermedios.");
             currentRoute.intermediateStops.forEach(stop => {
                stop.arrivalTime = null;
                stop.departureTime = null;
            });
            return;
        }


        const allPoints = [currentRoute.startPoint, ...currentRoute.intermediateStops, currentRoute.endPoint];
        let totalRouteDistance = 0;
        const segmentDistances = [];

        for (let i = 0; i < allPoints.length - 1; i++) {
            const dist = calculateDistance(allPoints[i].lat, allPoints[i].lng, allPoints[i+1].lat, allPoints[i+1].lng);
            segmentDistances.push(dist);
            totalRouteDistance += dist;
        }

        if (totalRouteDistance === 0) {
            console.warn("Distancia total de la ruta es cero. No se pueden calcular tiempos intermedios proporcionales.");
            // Assign equal time slots or leave as is? For now, clear them.
            currentRoute.intermediateStops.forEach(stop => {
                stop.arrivalTime = null;
                stop.departureTime = null;
            });
            return;
        }
        
        let accumulatedTimeMinutes = startTotalMinutes;
        for (let i = 0; i < currentRoute.intermediateStops.length; i++) {
            const stop = currentRoute.intermediateStops[i];
            // Time for segment from previous point (start or prev intermediate) to this intermediate stop
            const segmentProportion = segmentDistances[i] / totalRouteDistance;
            const segmentDurationMinutes = totalRouteDurationMinutes * segmentProportion;
            
            accumulatedTimeMinutes += segmentDurationMinutes;
            stop.arrivalTime = minutesToTime(accumulatedTimeMinutes);
            stop.departureTime = stop.arrivalTime; // Salida = Llegada para intermedias
        }
        // console.log("Tiempos intermedios recalculados:", currentRoute.intermediateStops);
    }


    // --- GESTIÓN DE RUTAS (localStorage) ---
    function saveRoute() {
        if (!routeNameInput.value.trim()) {
            alert("Por favor, ingresa un nombre para la ruta.");
            return;
        }
        if (!currentRoute.startPoint || !currentRoute.endPoint) {
            alert("La ruta debe tener un punto de inicio y un punto de fin definidos.");
            return;
        }
        if (!currentRoute.startPoint.departureTime || !currentRoute.endPoint.arrivalTime) {
            alert("Define las horas de salida (inicio) y llegada (fin).");
            return;
        }
        // Validar tiempos de paradas intermedias si no son auto-calculados
        if (!currentRoute.autoCalcTimes) {
            for (const stop of currentRoute.intermediateStops) {
                if (!stop.arrivalTime) {
                    alert(`La parada intermedia "${stop.name}" no tiene hora de llegada definida.`);
                    return;
                }
            }
        }


        currentRoute.name = routeNameInput.value.trim();
        currentRoute.startPoint.name = startPointNameInput.value || "Inicio";
        currentRoute.startPoint.departureTime = startPointTimeInput.value;
        currentRoute.endPoint.name = endPointNameInput.value || "Fin";
        currentRoute.endPoint.arrivalTime = endPointTimeInput.value;
        currentRoute.autoCalcTimes = autoCalcTimesCheckbox.checked;

        const existingRouteIndex = savedRoutes.findIndex(r => r.name === currentRoute.name);
        if (existingRouteIndex !== -1) {
            if (confirm(`Ya existe una ruta llamada "${currentRoute.name}". ¿Deseas sobrescribirla?`)) {
                savedRoutes[existingRouteIndex] = JSON.parse(JSON.stringify(currentRoute)); // Deep copy
            } else {
                return;
            }
        } else {
            savedRoutes.push(JSON.parse(JSON.stringify(currentRoute))); // Deep copy
        }
        
        saveRoutesToLocalStorage();
        updateRoutesDropdown();
        alert(`Ruta "${currentRoute.name}" guardada.`);
    }

    function loadSelectedRoute() {
        const routeName = savedRoutesDropdown.value;
        if (!routeName) {
            alert("No hay ruta seleccionada para cargar.");
            return;
        }
        const routeToLoad = savedRoutes.find(r => r.name === routeName);
        if (routeToLoad) {
            currentRoute = JSON.parse(JSON.stringify(routeToLoad)); // Deep copy to editor

            routeNameInput.value = currentRoute.name;
            startPointNameInput.value = currentRoute.startPoint.name;
            startPointTimeInput.value = currentRoute.startPoint.departureTime;
            endPointNameInput.value = currentRoute.endPoint.name;
            endPointTimeInput.value = currentRoute.endPoint.arrivalTime;
            autoCalcTimesCheckbox.checked = currentRoute.autoCalcTimes;

            renderCurrentRouteStops();
            drawCurrentRouteOnMap();
            // Fit map to bounds of the loaded route
            if (currentRoute.startPoint && currentRoute.endPoint) {
                const bounds = L.latLngBounds([
                    [currentRoute.startPoint.lat, currentRoute.startPoint.lng],
                    [currentRoute.endPoint.lat, currentRoute.endPoint.lng]
                ]);
                currentRoute.intermediateStops.forEach(s => bounds.extend([s.lat, s.lng]));
                if (bounds.isValid()) {
                    map.fitBounds(bounds, {padding: [50,50]});
                }
            }
            alert(`Ruta "${routeName}" cargada en el editor.`);
        }
    }

    function deleteSelectedRoute() {
        const routeName = savedRoutesDropdown.value;
        if (!routeName) {
            alert("No hay ruta seleccionada para eliminar.");
            return;
        }
        if (confirm(`¿Estás seguro de que deseas eliminar la ruta "${routeName}"? Esta acción no se puede deshacer.`)) {
            savedRoutes = savedRoutes.filter(r => r.name !== routeName);
            saveRoutesToLocalStorage();
            updateRoutesDropdown();
            // Si la ruta eliminada estaba en la cola de seguimiento, quitarla
            trackingQueue = trackingQueue.filter(name => name !== routeName);
            updateTrackingQueueDisplay();
            alert(`Ruta "${routeName}" eliminada.`);
        }
    }

    function saveRoutesToLocalStorage() {
        localStorage.setItem(LOCALSTORAGE_ROUTES_KEY, JSON.stringify(savedRoutes));
    }

    function loadRoutesFromLocalStorage() {
        const data = localStorage.getItem(LOCALSTORAGE_ROUTES_KEY);
        if (data) {
            savedRoutes = JSON.parse(data);
        } else {
            savedRoutes = [];
        }
    }

    function updateRoutesDropdown() {
        savedRoutesDropdown.innerHTML = '';
        if (savedRoutes.length === 0) {
            const option = document.createElement('option');
            option.value = "";
            option.textContent = "No hay rutas guardadas";
            savedRoutesDropdown.appendChild(option);
            return;
        }
        savedRoutes.forEach(route => {
            const option = document.createElement('option');
            option.value = route.name;
            option.textContent = route.name;
            savedRoutesDropdown.appendChild(option);
        });
    }

    // --- COLA DE SEGUIMIENTO ---
    function addSelectedRouteToQueue() {
        const routeName = savedRoutesDropdown.value;
        if (!routeName) {
            alert("Selecciona una ruta guardada para añadir a la cola.");
            return;
        }
        if (trackingQueue.includes(routeName)) {
            alert(`La ruta "${routeName}" ya está en la cola.`);
            return;
        }
        trackingQueue.push(routeName);
        updateTrackingQueueDisplay();
    }

    function updateTrackingQueueDisplay() {
        trackingQueueListDiv.innerHTML = '';
        if (trackingQueue.length === 0) {
            trackingQueueListDiv.textContent = 'Vacía';
            return;
        }
        const ol = document.createElement('ol');
        trackingQueue.forEach(routeName => {
            const li = document.createElement('li');
            li.textContent = routeName;
            ol.appendChild(li);
        });
        trackingQueueListDiv.appendChild(ol);
    }

    function clearTrackingQueue() {
        if (isTracking) {
            alert("No se puede limpiar la cola mientras el seguimiento está activo.");
            return;
        }
        if (confirm("¿Limpiar toda la cola de seguimiento?")) {
            trackingQueue = [];
            updateTrackingQueueDisplay();
        }
    }

    // --- LÓGICA DE SEGUIMIENTO EN TIEMPO REAL ---
    function startTracking() {
        if (trackingQueue.length === 0) {
            alert("La cola de seguimiento está vacía. Añade rutas primero.");
            return;
        }
        if (!navigator.geolocation) {
            alert("La geolocalización no está disponible en este navegador.");
            return;
        }

        isTracking = true;
        currentTrackingRouteIndexInQueue = 0;
        loadRouteForTracking(trackingQueue[currentTrackingRouteIndexInQueue]);
        
        startTrackingBtn.disabled = true;
        stopTrackingBtn.disabled = false;
        trackingInfoDiv.classList.remove('hidden');
        manualControlCheckbox.checked = false;
        toggleManualControl(); // Para setear estado inicial de botones manuales

        geolocationWatchId = navigator.geolocation.watchPosition(
            onPositionUpdate,
            onPositionError,
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );

        timeDiffIntervalId = setInterval(updateLiveTrackingInfo, 1000);
        updateLiveTrackingInfo(); // Primera actualización inmediata
        updateTrackingStatusToLocalStorage();
        alert("Seguimiento iniciado.");
    }

    function stopTracking(notify = true) {
        isTracking = false;
        if (geolocationWatchId) navigator.geolocation.clearWatch(geolocationWatchId);
        if (timeDiffIntervalId) clearInterval(timeDiffIntervalId);
        geolocationWatchId = null;
        timeDiffIntervalId = null;
        
        startTrackingBtn.disabled = false;
        stopTrackingBtn.disabled = true;
        trackingInfoDiv.classList.add('hidden');
        prevStopBtn.disabled = true;
        nextStopBtn.disabled = true;

        clearTrackingMapVisuals();
        currentTrackingRoute = null;
        currentTrackingRouteIndexInQueue = -1;
        currentTrackingStopIndex = -1;
        lastKnownPosition = null;
        currentBusDelayOrAheadMillis = 0;

        updateTrackingStatusToLocalStorage(); // Guardar estado final (isTracking: false)
        if (notify) alert("Seguimiento detenido.");
    }

    function loadRouteForTracking(routeName) {
        const route = savedRoutes.find(r => r.name === routeName);
        if (!route) {
            console.error(`Error: Ruta "${routeName}" no encontrada para seguimiento.`);
            stopTracking();
            alert(`Error crítico: Ruta "${routeName}" no encontrada. Deteniendo seguimiento.`);
            return false;
        }
        currentTrackingRoute = JSON.parse(JSON.stringify(route)); // Copia profunda
        currentTrackingStopIndex = -1; // Antes de salir del punto de inicio
        
        // Crear la estructura plana de paradas para localStorage
        currentTrackingRoute.flatStops = [
            { ...currentTrackingRoute.startPoint, type: 'start', arrivalTime: null, departureTime: currentTrackingRoute.startPoint.departureTime },
            ...currentTrackingRoute.intermediateStops.map(s => ({ ...s, type: 'intermediate' })),
            { ...currentTrackingRoute.endPoint, type: 'end', arrivalTime: currentTrackingRoute.endPoint.arrivalTime, departureTime: null }
        ];

        clearTrackingMapVisuals();
        drawTrackingRouteOnMap();
        updateLiveTrackingInfo();
        return true;
    }

    function clearTrackingMapVisuals() {
        if (userMarker) map.removeLayer(userMarker);
        if (startGeofenceCircle) map.removeLayer(startGeofenceCircle);
        if (endGeofenceCircle) map.removeLayer(endGeofenceCircle);
        // Limpiar marcadores y polilínea de la ruta de seguimiento (si se dibujan de forma diferente a la edición)
        // Por ahora, la edición y el seguimiento usan los mismos (tempStartMarker, etc.), pero podrían separarse.
        // Si se usa drawCurrentRouteOnMap para edición y drawTrackingRouteOnMap para seguimiento,
        // asegurarse que drawTrackingRouteOnMap limpie sus propios elementos.
        // Para simplificar, asumimos que drawCurrentRouteOnMap limpia todo lo de edición.
        // Y drawTrackingRouteOnMap limpia lo suyo.
        if (tempStartMarker) map.removeLayer(tempStartMarker); // Reutilizando de edición, limpiar
        if (tempEndMarker) map.removeLayer(tempEndMarker);
        intermediateMarkers.forEach(m => map.removeLayer(m));
        intermediateMarkers = [];
        if (routePolyline) map.removeLayer(routePolyline);
        routePolyline = null;
    }

    function drawTrackingRouteOnMap() {
        clearTrackingMapVisuals(); // Limpia marcadores de usuario y geofences anteriores

        if (!currentTrackingRoute) return;

        const latLngs = [];
        const startPoint = currentTrackingRoute.startPoint;
        const endPoint = currentTrackingRoute.endPoint;

        // Marcador de Inicio
        tempStartMarker = L.marker([startPoint.lat, startPoint.lng], { icon: createDivIcon('I', 'start-icon') })
            .addTo(map).bindPopup(`<b>Inicio: ${startPoint.name}</b><br>Sale: ${startPoint.departureTime}`);
        latLngs.push([startPoint.lat, startPoint.lng]);

        // Geofence de Inicio
        startGeofenceCircle = L.circle([startPoint.lat, startPoint.lng], {
            radius: GEOFENCE_RADIUS_METERS,
            color: 'green',
            fillColor: 'lightgreen',
            fillOpacity: 0.3
        }).addTo(map);

        // Marcadores Intermedios
        currentTrackingRoute.intermediateStops.forEach((stop, index) => {
            const marker = L.marker([stop.lat, stop.lng], { icon: createDivIcon(index + 1, 'intermediate-icon') })
                .addTo(map).bindPopup(`<b>${index+1}. ${stop.name}</b><br>Pasa: ${stop.arrivalTime}`);
            intermediateMarkers.push(marker); // Guardar para poder limpiar
            latLngs.push([stop.lat, stop.lng]);
        });

        // Marcador de Fin
        tempEndMarker = L.marker([endPoint.lat, endPoint.lng], { icon: createDivIcon('F', 'end-icon') })
            .addTo(map).bindPopup(`<b>Fin: ${endPoint.name}</b><br>Llega: ${endPoint.arrivalTime}`);
        latLngs.push([endPoint.lat, endPoint.lng]);
        
        // Geofence de Fin
        endGeofenceCircle = L.circle([endPoint.lat, endPoint.lng], {
            radius: GEOFENCE_RADIUS_METERS,
            color: 'red',
            fillColor: 'pink',
            fillOpacity: 0.3
        }).addTo(map);

        // Polilínea de la ruta
        if (latLngs.length > 1) {
            routePolyline = L.polyline(latLngs, { color: 'green', weight: 5, opacity: 0.7 }).addTo(map);
        }
        
        // Centrar mapa en la ruta activa
        if (latLngs.length > 0) {
            const routeBounds = L.latLngBounds(latLngs);
            if (routeBounds.isValid()) {
                 map.fitBounds(routeBounds, {padding: [30,30]});
            }
        }
    }


    function onPositionUpdate(position) {
        lastKnownPosition = {
            lat: position.coords.latitude,
            lng: position.coords.longitude
        };

        if (!userMarker) {
            userMarker = L.marker([lastKnownPosition.lat, lastKnownPosition.lng], {
                icon: L.divIcon({ className: 'user-marker', iconSize: [16,16], iconAnchor: [8,8] })
            }).addTo(map).bindPopup("Mi Ubicación");
        } else {
            userMarker.setLatLng([lastKnownPosition.lat, lastKnownPosition.lng]);
        }
        // map.panTo([lastKnownPosition.lat, lastKnownPosition.lng]); // Opcional: centrar siempre en el usuario

        if (!manualControlCheckbox.checked) {
            handleAutomaticAdvancement();
        }
        updateLiveTrackingInfo(); // Actualizar diferencia horaria, etc.
        updateTrackingStatusToLocalStorage();
    }

    function onPositionError(error) {
        console.error("Error de Geolocalización:", error);
        alert(`Error de GPS: ${error.message}. El seguimiento puede no funcionar correctamente.`);
        // Actualizar estado en localStorage para reflejar el error
        updateTrackingStatusToLocalStorage(true, error.message);
    }

    function handleAutomaticAdvancement() {
        if (!currentTrackingRoute || !lastKnownPosition) return;

        const flatStops = currentTrackingRoute.flatStops;
        
        if (currentTrackingStopIndex === -1) { // Antes de salir del inicio
            const distToStart = calculateDistance(lastKnownPosition.lat, lastKnownPosition.lng, currentTrackingRoute.startPoint.lat, currentTrackingRoute.startPoint.lng);
            if (distToStart > GEOFENCE_RADIUS_METERS) {
                console.log("Salió del geofence de inicio. Avanzando a la primera parada.");
                currentTrackingStopIndex = 0; // Hacia la primera parada (índice 0 de flatStops es inicio, 1 es primera real)
                                              // El índice de parada objetivo es currentTrackingStopIndex + 1
                updateLiveTrackingInfo();
            }
        } else { // En ruta hacia una parada (intermedia o fin)
            const targetStopIndexInFlat = currentTrackingStopIndex + 1;
            if (targetStopIndexInFlat >= flatStops.length) return; // Ya llegó al fin o error

            const nextStopTarget = flatStops[targetStopIndexInFlat];
            const distToNextStop = calculateDistance(lastKnownPosition.lat, lastKnownPosition.lng, nextStopTarget.lat, nextStopTarget.lng);

            if (nextStopTarget.type === 'end') { // Próxima parada es el FIN de la ruta
                if (distToNextStop <= GEOFENCE_RADIUS_METERS) {
                    console.log("Entró al geofence de fin de ruta.");
                    advanceToNextRoute();
                }
            } else { // Próxima parada es INTERMEDIA
                if (distToNextStop <= PROXIMITY_THRESHOLD_METERS) {
                    console.log(`Llegó a la parada intermedia: ${nextStopTarget.name}. Avanzando.`);
                    currentTrackingStopIndex++; // Avanza el índice de la parada DESDE la que se parte
                    updateLiveTrackingInfo();
                }
            }
        }
    }
    
    function advanceToNextRoute() {
        currentTrackingRouteIndexInQueue++;
        if (currentTrackingRouteIndexInQueue < trackingQueue.length) {
            const nextRouteName = trackingQueue[currentTrackingRouteIndexInQueue];
            alert(`Ruta completada. Cargando siguiente ruta en cola: ${nextRouteName}`);
            if (!loadRouteForTracking(nextRouteName)) {
                // Error al cargar, detener todo
                stopTracking(false); // No notificar con alert, ya se mostró error en loadRouteForTracking
                alert("Error al cargar la siguiente ruta. Seguimiento detenido.");
            }
        } else {
            alert("Todas las rutas de la cola completadas. Deteniendo seguimiento.");
            stopTracking(false); // No notificar con alert, ya se mostró el de arriba
        }
    }

    function updateLiveTrackingInfo() {
        if (!isTracking || !currentTrackingRoute) {
            activeRouteNameSpan.textContent = "---";
            nextStopInfoSpan.textContent = "---";
            timeDifferenceSpan.textContent = "---";
            return;
        }

        activeRouteNameSpan.textContent = currentTrackingRoute.name;
        
        const flatStops = currentTrackingRoute.flatStops;
        let nextStopDisplay = "---";
        
        if (currentTrackingStopIndex === -1) { // En el punto de inicio, antes de salir
            nextStopDisplay = `Salida de ${currentTrackingRoute.startPoint.name} a las ${currentTrackingRoute.startPoint.departureTime}`;
            
            const scheduledDepartureTime = timeToMinutes(currentTrackingRoute.startPoint.departureTime);
            if (scheduledDepartureTime !== null) {
                const now = new Date();
                const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
                // Diferencia = Actual - Programado. Negativo = Atrasado, Positivo = Adelantado (para salir)
                // Pero para el chofer, un valor positivo significa que tiene tiempo de sobra.
                // Un valor negativo significa que ya debería haber salido.
                // currentBusDelayOrAheadMillis: positivo si está adelantado (sale después), negativo si está atrasado (sale antes o ya debió salir)
                currentBusDelayOrAheadMillis = (scheduledDepartureTime - currentTimeMinutes) * 60 * 1000 - (now.getSeconds() * 1000);
            } else {
                currentBusDelayOrAheadMillis = 0;
            }

        } else { // En ruta
            const nextStopObjectiveIndex = currentTrackingStopIndex + 1;
            if (nextStopObjectiveIndex < flatStops.length) {
                const nextStopData = flatStops[nextStopObjectiveIndex];
                const scheduledTime = nextStopData.type === 'end' ? nextStopData.arrivalTime : nextStopData.departureTime; // o arrivalTime para todas las paradas
                nextStopDisplay = `Hacia ${nextStopData.name} (Prog: ${scheduledTime || 'N/A'})`;

                // Cálculo de adelanto/atraso en ruta (proporcional)
                const departedFromStop = flatStops[currentTrackingStopIndex];
                const headingTowardsStop = flatStops[nextStopObjectiveIndex];

                const scheduledDepartureTimeFromPrev = timeToMinutes(departedFromStop.departureTime);
                const scheduledArrivalTimeAtNext = timeToMinutes(headingTowardsStop.arrivalTime);

                if (scheduledDepartureTimeFromPrev !== null && scheduledArrivalTimeAtNext !== null && lastKnownPosition) {
                    const legScheduledDurationMillis = (scheduledArrivalTimeAtNext - scheduledDepartureTimeFromPrev) * 60 * 1000;
                    
                    const distTotalLeg = calculateDistance(departedFromStop.lat, departedFromStop.lng, headingTowardsStop.lat, headingTowardsStop.lng);
                    const distCoveredInLeg = calculateDistance(departedFromStop.lat, departedFromStop.lng, lastKnownPosition.lat, lastKnownPosition.lng);
                    // const distRemainingInLeg = calculateDistance(lastKnownPosition.lat, lastKnownPosition.lng, headingTowardsStop.lat, headingTowardsStop.lng);

                    let progressInLeg = 0;
                    if (distTotalLeg > 0) {
                         // Cap progress at 1 to avoid overshooting if GPS is slightly past the stop but not yet triggered next leg
                        progressInLeg = Math.min(1, distCoveredInLeg / distTotalLeg);
                    } else if (distCoveredInLeg > 0) { // At the same point, but moved
                        progressInLeg = 1; // Consider leg completed if total is 0 but covered is >0 (unlikely)
                    }


                    const scheduledTimeAtCurrentPositionMillis = (scheduledDepartureTimeFromPrev * 60 * 1000) + (legScheduledDurationMillis * progressInLeg);
                    
                    const now = new Date();
                    const currentTimeMillisFromMidnight = (now.getHours() * 60 * 60 + now.getMinutes() * 60 + now.getSeconds()) * 1000;
                    
                    // Delay/Ahead: Positivo = Adelantado, Negativo = Atrasado
                    // currentBusDelayOrAheadMillis = Programado en este punto - Actual
                    currentBusDelayOrAheadMillis = scheduledTimeAtCurrentPositionMillis - currentTimeMillisFromMidnight;

                } else {
                    currentBusDelayOrAheadMillis = 0; // No se puede calcular
                }

            } else { // Ya llegó al fin (o debería haber llegado)
                nextStopDisplay = "Ruta completada (esperando transición o fin de cola)";
                // Aquí el cálculo de delay/ahead podría ser contra la hora de llegada final
                const finalArrivalTime = timeToMinutes(currentTrackingRoute.endPoint.arrivalTime);
                if (finalArrivalTime !== null) {
                    const now = new Date();
                    const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
                    currentBusDelayOrAheadMillis = (finalArrivalTime - currentTimeMinutes) * 60 * 1000 - (now.getSeconds() * 1000);
                } else {
                    currentBusDelayOrAheadMillis = 0;
                }
            }
        }
        nextStopInfoSpan.textContent = nextStopDisplay;
        timeDifferenceSpan.textContent = formatDelay(currentBusDelayOrAheadMillis);
    }

    function formatDelay(ms) {
        if (ms === null || ms === undefined) return "---";
        const totalSeconds = Math.round(ms / 1000);
        const sign = totalSeconds >= 0 ? "+" : "-";
        const absSeconds = Math.abs(totalSeconds);
        const minutes = Math.floor(absSeconds / 60);
        const seconds = absSeconds % 60;
        return `${sign}${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    function toggleManualControl() {
        const isManual = manualControlCheckbox.checked;
        prevStopBtn.disabled = !isManual || !isTracking;
        nextStopBtn.disabled = !isManual || !isTracking;

        if (!isManual && isTracking) { // Volviendo a Automático
            findAndSetCurrentLeg();
        }
    }

    function manualPreviousStop() {
        if (!isTracking || !currentTrackingRoute) return;
        if (currentTrackingStopIndex > -1) {
            currentTrackingStopIndex--;
            updateLiveTrackingInfo();
            updateTrackingStatusToLocalStorage();
        } else {
            alert("Ya estás en el inicio de la ruta.");
        }
    }

    function manualNextStop() {
        if (!isTracking || !currentTrackingRoute) return;
        const flatStops = currentTrackingRoute.flatStops;
        // currentTrackingStopIndex es el índice de la parada DESDE la que se parte.
        // Si currentTrackingStopIndex es flatStops.length - 2, significa que partió de la penúltima parada,
        // y la siguiente parada es la última (el fin). Al presionar "Siguiente" aquí, debería pasar a la siguiente ruta.
        if (currentTrackingStopIndex < flatStops.length - 2) { // -2 porque el último es el fin, y el índice es "desde donde partió"
            currentTrackingStopIndex++;
            updateLiveTrackingInfo();
            updateTrackingStatusToLocalStorage();
        } else if (currentTrackingStopIndex === flatStops.length - 2) { // Está en la última parada (o partió de la penúltima hacia la última)
            alert("Estás en la última parada. Presionar 'Siguiente' de nuevo avanzará a la próxima ruta si existe.");
            // Forzar avance a la siguiente ruta
            advanceToNextRoute();
        } else { // currentTrackingStopIndex === -1 (en inicio)
             currentTrackingStopIndex = 0; // Sale del inicio hacia la primera parada
             updateLiveTrackingInfo();
             updateTrackingStatusToLocalStorage();
        }
    }

    function findAndSetCurrentLeg() {
        if (!isTracking || !currentTrackingRoute || !lastKnownPosition) return;

        const flatStops = currentTrackingRoute.flatStops;
        if (flatStops.length < 2) return; // Ruta no válida

        let bestMatchIndex = -1; // Por defecto, antes de salir del inicio
        let minDistanceToLine = Infinity;

        // Chequear si está cerca del inicio
        const distToStart = calculateDistance(lastKnownPosition.lat, lastKnownPosition.lng, flatStops[0].lat, flatStops[0].lng);
        if (distToStart < PROXIMITY_THRESHOLD_METERS * 2) { // Un poco más de margen para el inicio
            bestMatchIndex = -1;
        } else {
            // Iterar por los tramos de la ruta (parada A -> parada B)
            for (let i = 0; i < flatStops.length - 1; i++) {
                const pA = flatStops[i];
                const pB = flatStops[i+1];
                
                // Simplificación: encontrar la parada *siguiente* más cercana que aún no se ha pasado (según orden)
                // Esto es una heurística simple. Una solución más robusta implicaría proyección a segmentos de línea.
                const distToPb = calculateDistance(lastKnownPosition.lat, lastKnownPosition.lng, pB.lat, pB.lng);

                // Si estamos más cerca de pB que de cualquier otra parada *siguiente* analizada hasta ahora
                // Y pB está "adelante" en la ruta (no hemos pasado pA conceptualmente)
                if (distToPb < minDistanceToLine) {
                    // Aquí se podría añadir lógica para verificar si el usuario está razonablemente entre pA y pB
                    // Por ahora, simplemente tomamos la parada siguiente más cercana.
                    minDistanceToLine = distToPb;
                    bestMatchIndex = i; // El índice de la parada DESDE la que se parte (pA)
                }
            }
        }
        
        if (currentTrackingStopIndex !== bestMatchIndex) {
            console.log(`Re-sincronización: Cambiando de tramo ${currentTrackingStopIndex} a ${bestMatchIndex}`);
            currentTrackingStopIndex = bestMatchIndex;
            updateLiveTrackingInfo();
            updateTrackingStatusToLocalStorage();
        }
    }

    // --- COMUNICACIÓN (localStorage) ---
    function updateTrackingStatusToLocalStorage(hasError = false, errorReason = '') {
        if (!isTracking && !hasError) { // Si se detuvo el tracking normalmente
            localStorage.setItem(LOCALSTORAGE_TRACKING_KEY, JSON.stringify({ isTracking: false, lastUpdateTime: Date.now() }));
            return;
        }
        
        // Si no hay ruta activa (ej. error antes de cargar la primera)
        if (!currentTrackingRoute && isTracking) {
             localStorage.setItem(LOCALSTORAGE_TRACKING_KEY, JSON.stringify({
                isTracking: true,
                hasError: true,
                errorReason: errorReason || "No hay ruta activa cargada.",
                routeName: null,
                currentRouteIndexInQueue: currentTrackingRouteIndexInQueue,
                trackingQueueNames: trackingQueue,
                currentStopIndexFromWhichDeparted: -1,
                nextStopIndexTowardsWhichHeading: -1,
                currentBusDelayOrAheadMillis: 0,
                lastKnownPosition: lastKnownPosition,
                lastUpdateTime: Date.now(),
                routeStops: []
            }));
            return;
        }

        // Si hay ruta activa
        const status = {
            isTracking: isTracking,
            hasError: hasError,
            errorReason: errorReason,
            routeName: currentTrackingRoute ? currentTrackingRoute.name : null,
            currentRouteIndexInQueue: currentTrackingRouteIndexInQueue,
            trackingQueueNames: trackingQueue, // Nombres de las rutas en cola
            currentStopIndexFromWhichDeparted: currentTrackingStopIndex, // Índice en flatStops
            nextStopIndexTowardsWhichHeading: currentTrackingRoute ? (currentTrackingStopIndex + 1) : -1, // Índice en flatStops
            currentBusDelayOrAheadMillis: currentBusDelayOrAheadMillis,
            lastKnownPosition: lastKnownPosition,
            lastUpdateTime: Date.now(),
            routeStops: currentTrackingRoute ? currentTrackingRoute.flatStops : []
        };
        localStorage.setItem(LOCALSTORAGE_TRACKING_KEY, JSON.stringify(status));
    }

    // --- Funciones de utilidad adicionales ---
    // (Si se necesitan más, se añaden aquí)

    </script>
</body>
</html>
