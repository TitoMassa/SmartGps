<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            overflow: hidden; /* Prevent body scroll */
            display: flex;
            flex-direction: column;
        }

        #map {
            height: 50vh; /* 50% of viewport height */
            width: 100%;
            background-color: #333; /* Placeholder color */
        }

        #controls {
            height: 50vh; /* 50% of viewport height */
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .control-section:last-child {
            border-bottom: none;
        }

        h2, h3 {
            color: #FFFFFF;
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="text"], input[type="datetime-local"], select {
            width: calc(100% - 12px);
            padding: 8px;
            margin-bottom: 10px;
            background-color: #222;
            color: #FFF;
            border: 1px solid #555;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        button:hover {
            background-color: #45a049;
        }
        button.danger {
            background-color: #f44336;
        }
        button.danger:hover {
            background-color: #da190b;
        }
        button.secondary {
            background-color: #007bff;
        }
        button.secondary:hover {
            background-color: #0056b3;
        }


        #statusDisplay {
            text-align: center;
            padding: 10px;
        }
        #timeDeviation {
            font-size: 3em; /* Larger font for time deviation */
            font-weight: bold;
            margin: 10px 0;
        }
        #speedDisplay, #nextStopDisplay {
            font-size: 1.2em;
            margin: 5px 0;
        }

        .stop-item {
            background-color: #1e1e1e;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .stop-item.next-stop-highlight {
            background-color: #007bff;
            font-weight: bold;
        }

        .leaflet-div-icon {
            background: transparent;
            border: none;
            text-align: center;
            font-weight: bold;
            color: white;
        }

        .custom-marker-content { /* Not directly used, but good to have if needed */
            padding: 5px 8px;
            border-radius: 50%;
            color: white;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid white;
        }
        
        .user-location-icon {
            background-color: #007bff !important; /* Blue dot */
            border-radius: 50%;
            width: 16px !important;
            height: 16px !important;
            border: 2px solid white;
            box-shadow: 0 0 0 2px #007bff;
        }
    </style>
</head>
<body>

    <div id="map"></div>
    <div id="controls">
        <div id="statusDisplay" style="display: none;">
            <div id="timeDeviation">00:00</div>
            <div id="speedDisplay">Velocidad: 0 KM/H</div>
            <div id="nextStopDisplay">Próxima Parada: N/A</div>
        </div>

        <div class="control-section" id="routeCreationSection">
            <h3>Crear/Modificar Ruta</h3>
            <p style="font-size: 0.8em;">Toca el mapa para agregar paradas. Toca una parada existente para editarla.</p>
            <label for="pointName">Nombre Parada:</label>
            <input type="text" id="pointName" placeholder="Ej: Estación Central">
            
            <label for="pointTime">Horario Programado (DD/MM/AAAA HH:MM):</label>
            <input type="datetime-local" id="pointTime">

            <div id="editPointControls" style="display:none; margin-top:10px;">
                <button onclick="updateSelectedPoint()" class="secondary">Actualizar Parada</button>
                <button onclick="deleteSelectedPoint()" class="danger">Borrar Parada Seleccionada</button>
                <button onclick="cancelEdit()">Cancelar Edición</button>
            </div>
            <hr style="margin: 15px 0;">
            <input type="checkbox" id="autoCalcTimes" checked>
            <label for="autoCalcTimes" style="display:inline;">Calcular horarios intermedios automáticamente</label>
            <br><br>
            <button onclick="clearCurrentRoute()">Limpiar Ruta Actual</button>
        </div>

        <div class="control-section">
            <h3>Lista de Paradas</h3>
            <div id="stopsList">No hay paradas.</div>
        </div>
        
        <div class="control-section">
            <h3>Guardar/Cargar Rutas</h3>
            <label for="routeName">Nombre para Guardar Ruta:</label>
            <input type="text" id="routeName" placeholder="Ej: Ruta Mañana Lunes">
            <button onclick="saveRoute()">Guardar Ruta</button>
            <br><br>
            <label for="savedRoutes">Cargar Ruta:</label>
            <select id="savedRoutes"></select>
            <button onclick="loadRoute()">Cargar</button>
            <button onclick="deleteRoute()" class="danger">Borrar Seleccionada</button>
        </div>

        <div class="control-section">
            <h3>Seguimiento</h3>
            <button id="startTrackingBtn" onclick="startTracking()">Iniciar Seguimiento</button>
            <button id="stopTrackingBtn" onclick="stopTracking()" class="danger" style="display:none;">Detener Seguimiento</button>
            <br>
            <input type="checkbox" id="manualStopNav">
            <label for="manualStopNav" style="display:inline;">Navegación Manual de Paradas</label>
            <button id="prevStopBtn" onclick="goToPreviousStop()" style="display:none;">Anterior</button>
            <button id="nextStopBtn" onclick="goToNextStop()" style="display:none;">Siguiente</button>
        </div>
        
        <div class="control-section">
            <h3>Cola de Rutas</h3>
            <label for="routeToQueue">Añadir ruta guardada a la cola:</label>
            <select id="routeToQueue"></select>
            <button onclick="addRouteToQueue()">Añadir a Cola</button>
            <h4>En Cola:</h4>
            <div id="routeQueueDisplay">Vacía.</div>
            <button onclick="clearRouteQueue()">Limpiar Cola</button>
        </div>

    </div>

    <script>
        'use strict';
        let map;
        let routePoints = []; // {lat, lng, name, type, scheduledTime, marker, originalIndex}
        let routeLine;
        let userMarker;
        let trackingIntervalId;
        let isTracking = false;
        let currentSegmentStartIndex = 0; 
        let lastKnownPosition = null;
        let currentlyEditingPoint = null; 

        const CACHE_PREFIX = 'smartMovePro_route_';
        const ROUTE_QUEUE_CACHE_KEY = 'smartMovePro_routeQueue';

        // --- Leaflet Icon Helpers ---
        function createDivIcon(text, bgColor = null, type = '') {
            let iconColor = bgColor;
            if (!iconColor) {
                if (type === 'start') iconColor = '#4CAF50'; 
                else if (type === 'end') iconColor = '#f44336';   
                else if (type === 'intermediate') iconColor = '#2196F3'; 
                else iconColor = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;
            }

            return L.divIcon({
                className: 'leaflet-div-icon',
                html: `<div style="background-color:${iconColor}; padding: 5px 8px; border-radius: 50%; color: white; font-size:14px; font-weight:bold; border: 1px solid white;">${text}</div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });
        }

        function createUserLocationIcon() {
            return L.divIcon({
                className: 'user-location-icon',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        // --- Map Initialization ---
        function initMap() {
            map = L.map('map').setView([-34.6037, -58.3816], 13); 
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            map.on('click', onMapClick);

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    map.setView([position.coords.latitude, position.coords.longitude], 13);
                }, () => {
                    console.warn("Error getting current location. Using default.");
                });
            }
        }
        
        // --- Funciones de Edición ---
        function formatDateTimeForInput(date) {
            if (!date || isNaN(new Date(date).getTime())) return "";
            const d = new Date(date);
            d.setMinutes(d.getMinutes() - d.getTimezoneOffset()); // Adjust for local time display in input
            return d.toISOString().slice(0, 16);
        }

        function activateEditModeForPoint(point) {
            if (isTracking) {
                alert("Detén el seguimiento para editar la ruta.");
                return;
            }
            currentlyEditingPoint = point;
            document.getElementById('pointName').value = point.name;
            document.getElementById('pointTime').value = point.scheduledTime ? formatDateTimeForInput(point.scheduledTime) : "";
            document.getElementById('editPointControls').style.display = 'block';
            document.getElementById('pointName').focus();
        }

        function cancelEdit() {
            currentlyEditingPoint = null;
            document.getElementById('pointName').value = "";
            document.getElementById('pointTime').value = "";
            document.getElementById('editPointControls').style.display = 'none';
        }

        function updateSelectedPoint() {
            if (!currentlyEditingPoint) return;

            const newName = document.getElementById('pointName').value.trim();
            const newTimeValue = document.getElementById('pointTime').value;
            
            if (!newName) {
                alert("El nombre de la parada no puede estar vacío.");
                return;
            }

            let newScheduledTime = null;
            if (newTimeValue) {
                newScheduledTime = new Date(newTimeValue); // Interprets as local time
                if (isNaN(newScheduledTime.getTime())) {
                    alert("Formato de fecha/hora inválido.");
                    return;
                }
            }

            if ((currentlyEditingPoint.type === 'start' || currentlyEditingPoint.type === 'end') && !newScheduledTime) {
                alert(`El horario es obligatorio para el punto de ${currentlyEditingPoint.type === 'start' ? 'Inicio' : 'Fin'}.`);
                return;
            }

            currentlyEditingPoint.name = newName;
            currentlyEditingPoint.scheduledTime = newScheduledTime;

            if (document.getElementById('autoCalcTimes').checked) {
                calculateAndApplyIntermediateTimes();
            }
            redrawRouteLine();
            updateStopsList();
            alert(`Parada "${newName}" actualizada.`);
            cancelEdit();
        }

        function deleteSelectedPoint() {
            if (!currentlyEditingPoint) return;
        
            const numPoints = routePoints.length;
            const isStartPoint = currentlyEditingPoint.type === 'start';
            const isEndPoint = currentlyEditingPoint.type === 'end';
            const startPointsCount = routePoints.filter(p => p.type === 'start').length;
            const endPointsCount = routePoints.filter(p => p.type === 'end').length;
        
            if (numPoints > 2) { // Only apply restrictions if more than 2 points exist
                if (isStartPoint && startPointsCount <= 1) {
                    alert("No puedes borrar el único punto de Inicio si hay otras paradas. Define un nuevo Inicio primero o borra las paradas intermedias/fin.");
                    return;
                }
                if (isEndPoint && endPointsCount <= 1) {
                    alert("No puedes borrar el único punto de Fin si hay otras paradas. Define un nuevo Fin primero o borra las paradas intermedias/inicio.");
                    return;
                }
            }
        
            if (confirm(`¿Seguro que quieres borrar la parada "${currentlyEditingPoint.name}"?`)) {
                map.removeLayer(currentlyEditingPoint.marker);
                const index = routePoints.indexOf(currentlyEditingPoint);
                if (index > -1) {
                    routePoints.splice(index, 1);
                }
        
                // Update types if necessary (e.g., an intermediate becomes start/end)
                if (routePoints.length > 0) {
                    if (!routePoints.some(p => p.type === 'start') && routePoints.length > 0) {
                        routePoints[0].type = 'start';
                        routePoints[0].marker.setIcon(createDivIcon('I', null, 'start'));
                    }
                    if (!routePoints.some(p => p.type === 'end') && routePoints.length > 1) {
                        routePoints[routePoints.length - 1].type = 'end';
                        routePoints[routePoints.length - 1].marker.setIcon(createDivIcon('F', null, 'end'));
                    } else if (routePoints.length === 1 && routePoints[0].type !== 'start') {
                        // If only one point remains, it must be 'start' conceptually
                         routePoints[0].type = 'start';
                         routePoints[0].marker.setIcon(createDivIcon('I', null, 'start'));
                    }
                }

                renumberIntermediateMarkers();
        
                if (document.getElementById('autoCalcTimes').checked) {
                    calculateAndApplyIntermediateTimes();
                }
                redrawRouteLine();
                updateStopsList();
                alert(`Parada "${currentlyEditingPoint.name}" borrada.`);
            }
            cancelEdit();
        }

        function renumberIntermediateMarkers() {
            let intermediateCounter = 1;
            routePoints.forEach(p => {
                if (p.type === 'intermediate') {
                    p.marker.setIcon(createDivIcon(intermediateCounter++, null, 'intermediate'));
                }
            });
        }

        // --- Route Creation Logic ---
        function onMapClick(e) {
            if (isTracking) {
                alert("Detén el seguimiento para modificar la ruta.");
                return;
            }
            
            let targetIsMarkerIcon = false;
            if (e.originalEvent && e.originalEvent.target) {
                 try {
                    if (e.originalEvent.target.closest('.leaflet-marker-icon')) {
                        targetIsMarkerIcon = true;
                    }
                 } catch(err) {/*ignore*/}
            }

            if (currentlyEditingPoint && !targetIsMarkerIcon) { 
                cancelEdit();
            }
            
            if (targetIsMarkerIcon) { 
                return;
            }

            const nameInput = document.getElementById('pointName');
            const timeInput = document.getElementById('pointTime');
            const latlng = e.latlng;

            let type;
            let requiredTime = true;
            let pointText;
            let pointNameValue = nameInput.value.trim();

            if (routePoints.length === 0) {
                type = 'start';
                pointText = 'I';
            } else {
                const hasStart = routePoints.some(p => p.type === 'start');
                const hasEnd = routePoints.some(p => p.type === 'end');

                if (!hasStart) {
                    type = 'start';
                    pointText = 'I';
                } else if (!hasEnd) { 
                    type = 'end';
                    pointText = 'F';
                } else { 
                    type = 'intermediate';
                    const intermediateCount = routePoints.filter(p => p.type === 'intermediate').length;
                    pointText = intermediateCount + 1;
                    requiredTime = false; 
                }
            }
            
            if (!pointNameValue) { // If input is empty, suggest default name
                if (type === 'start') pointNameValue = "Inicio";
                else if (type === 'end') pointNameValue = "Final";
                else pointNameValue = `Parada ${pointText}`;
            }


            if (requiredTime && !timeInput.value) {
                alert(`El horario es obligatorio para el punto de ${type === 'start' ? 'Inicio' : 'Fin'}.`);
                return;
            }

            const scheduledTime = timeInput.value ? new Date(timeInput.value) : null;
            if (requiredTime && scheduledTime && isNaN(scheduledTime.getTime())) {
                alert("Formato de fecha/hora inválido.");
                return;
            }
            
            let insertionIndex = routePoints.length;
            if (type === 'intermediate') {
                const endIdx = routePoints.findIndex(p => p.type === 'end');
                if (endIdx !== -1) insertionIndex = endIdx; 
            }


            const newPoint = {
                lat: latlng.lat,
                lng: latlng.lng,
                name: pointNameValue,
                type: type,
                scheduledTime: scheduledTime,
                marker: L.marker(latlng, { 
                    icon: createDivIcon(pointText, null, type), 
                    draggable: true 
                }).addTo(map),
                originalIndex: routePoints.length // This gives a unique creation order index
            };

            newPoint.marker.on('dragend', function(event) {
                if (isTracking) {
                    event.target.setLatLng(L.latLng(newPoint.lat, newPoint.lng)); // Revert drag
                    alert("Detén el seguimiento para modificar la ruta.");
                    return;
                }
                const marker = event.target;
                const position = marker.getLatLng();
                const point = routePoints.find(p => p.marker === marker);
                if (point) {
                    point.lat = position.lat;
                    point.lng = position.lng;
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) {
                        calculateAndApplyIntermediateTimes();
                    }
                    updateStopsList();
                }
            });
            
            newPoint.marker.on('click', function() {
                if (isTracking) return;
                activateEditModeForPoint(newPoint);
            });
            
            if (type === 'intermediate') {
                routePoints.splice(insertionIndex, 0, newPoint);
                renumberIntermediateMarkers(); 
            } else {
                 routePoints.push(newPoint);
            }

            nameInput.value = ""; // Clear for next point
            // timeInput.value = ""; // Optional: Keep for sequential times or clear

            if (document.getElementById('autoCalcTimes').checked) {
                calculateAndApplyIntermediateTimes();
            }
            redrawRouteLine();
            updateStopsList();
        }

        function calculateAndApplyIntermediateTimes() {
            const startPoint = routePoints.find(p => p.type === 'start');
            const endPoint = routePoints.find(p => p.type === 'end');

            if (!startPoint || !endPoint || !startPoint.scheduledTime || !endPoint.scheduledTime) {
                // Clear times for intermediates if start/end times are missing
                routePoints.filter(p => p.type === 'intermediate').forEach(p => p.scheduledTime = null);
                updateStopsList();
                return;
            }

            // Sort intermediates by their creation order for calculation path
            const intermediatePoints = routePoints.filter(p => p.type === 'intermediate')
                                            .sort((a,b) => a.originalIndex - b.originalIndex);
            
            if (intermediatePoints.length === 0 && routePoints.filter(p => p.type === 'intermediate').length > 0) {
                // This case implies originalIndex might be missing or inconsistent if this path is taken.
                // However, originalIndex is assigned on creation.
                // If intermediates exist but the sorted list is empty, it's an issue.
                // For now, assume originalIndex is reliable.
            }


            const totalDurationMillis = endPoint.scheduledTime.getTime() - startPoint.scheduledTime.getTime();
            if (totalDurationMillis <= 0) {
                console.warn("Duración total no positiva. No se calcularán tiempos intermedios.");
                routePoints.filter(p => p.type === 'intermediate').forEach(p => p.scheduledTime = null);
                updateStopsList();
                return;
            }
            
            let pathForCalc = [startPoint, ...intermediatePoints, endPoint];
            let totalRouteDistance = 0;
            for (let i = 0; i < pathForCalc.length - 1; i++) {
                totalRouteDistance += L.latLng(pathForCalc[i].lat, pathForCalc[i].lng)
                                    .distanceTo(L.latLng(pathForCalc[i+1].lat, pathForCalc[i+1].lng));
            }

            if (totalRouteDistance === 0) { // Avoid division by zero
                // Distribute time equally if no distance
                const numSegments = intermediatePoints.length + 1;
                const timePerSegment = totalDurationMillis / numSegments;
                 intermediatePoints.forEach((point, index) => {
                    point.scheduledTime = new Date(startPoint.scheduledTime.getTime() + (timePerSegment * (index + 1)));
                });
                updateStopsList();
                return;
            }

            // Calculate times for intermediate points based on their position in the sorted list (pathForCalc)
            for (let i = 0; i < intermediatePoints.length; i++) {
                const point = intermediatePoints[i];
                
                let distFromStartToCurrentInter = 0;
                // Calculate distance from startPoint, along the pathForCalc, up to the current intermediatePoint
                for(let k=0; k < pathForCalc.indexOf(point); k++){ // pathForCalc.indexOf(point) will be i+1
                    distFromStartToCurrentInter += L.latLng(pathForCalc[k].lat, pathForCalc[k].lng)
                                                .distanceTo(L.latLng(pathForCalc[k+1].lat, pathForCalc[k+1].lng));
                }
                
                const proportionOfRoute = distFromStartToCurrentInter / totalRouteDistance;
                const timeOffsetMillis = totalDurationMillis * proportionOfRoute;
                
                point.scheduledTime = new Date(startPoint.scheduledTime.getTime() + timeOffsetMillis);
            }
            updateStopsList();
        }
        
        function clearCurrentRoute() {
            cancelEdit(); 
            routePoints.forEach(p => map.removeLayer(p.marker));
            routePoints = [];
            if (routeLine) map.removeLayer(routeLine);
            routeLine = null;
            document.getElementById('pointName').value = "";
            document.getElementById('pointTime').value = "";
            updateStopsList();
            console.log("Ruta actual limpiada.");
        }

        function redrawRouteLine() {
            if (routeLine) {
                map.removeLayer(routeLine);
                routeLine = null;
            }
            
            const displayPoints = getSortedRoutePointsForDisplay(); 
            if (displayPoints.length > 1) {
                const latlngs = displayPoints.map(p => [p.lat, p.lng]);
                routeLine = L.polyline(latlngs, {color: 'blue'}).addTo(map);
            }
        }
        
        function getSortedRoutePointsForDisplay() {
            const sortedPoints = [];
            const start = routePoints.find(p => p.type === 'start');
            const end = routePoints.find(p => p.type === 'end');
            const intermediates = routePoints.filter(p => p.type === 'intermediate')
                                    .sort((a,b) => {
                                        if (!document.getElementById('autoCalcTimes').checked && a.scheduledTime && b.scheduledTime) {
                                            return new Date(a.scheduledTime).getTime() - new Date(b.scheduledTime).getTime();
                                        }
                                        return a.originalIndex - b.originalIndex; 
                                    });

            if (start) sortedPoints.push(start);
            sortedPoints.push(...intermediates);
            if (end) sortedPoints.push(end);
            return sortedPoints;
        }


        function formatTime(dateObj) { // Expects a Date object
            if (!dateObj || isNaN(dateObj.getTime())) return "N/A";
            return dateObj.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }) + 
                   ` (${dateObj.toLocaleDateString('es-ES')})`;
        }
        
        function updateStopsList() {
            const listDiv = document.getElementById('stopsList');
            const displayPoints = getSortedRoutePointsForDisplay();

            if (displayPoints.length === 0) {
                listDiv.innerHTML = "No hay paradas.";
                return;
            }

            let html = "<ul>";
            let intermediateVisualCounter = 1;
            displayPoints.forEach((p) => { // p is from displayPoints
                let typeText = "";
                switch(p.type) {
                    case 'start': typeText = "Inicio"; break;
                    case 'intermediate': 
                        typeText = `Intermedia ${intermediateVisualCounter++}`; 
                        break;
                    case 'end': typeText = "Fin"; break;
                }
                const timeStr = p.scheduledTime ? formatTime(new Date(p.scheduledTime)) : "Sin horario";
                
                let itemClass = "stop-item";
                if (isTracking && routePoints.length > 1 && currentSegmentStartIndex < routePoints.length - 1) {
                    // routePoints is in tracking order during isTracking
                    const nextTrackingStop = routePoints[currentSegmentStartIndex + 1];
                    if (p === nextTrackingStop) { // Compare object references
                        itemClass += " next-stop-highlight";
                    }
                }
                html += `<li class="${itemClass}"><b>${p.name}</b> (${typeText}) - ${timeStr}</li>`;
            });
            html += "</ul>";
            listDiv.innerHTML = html;
        }

        // --- Persistence (localStorage) ---
        function saveRoute() {
            const routeNameInput = document.getElementById('routeName');
            if (!routeNameInput.value) {
                alert("Por favor, ingresa un nombre para la ruta.");
                return;
            }
            if (!routePoints.some(p=>p.type==='start') || !routePoints.some(p=>p.type==='end')) {
                 alert("Una ruta debe tener al menos un punto de inicio y fin definidos.");
                 return;
            }
            if (routePoints.length < 2) {
                alert("Una ruta debe tener al menos dos puntos.");
                return;
            }

            const savablePoints = routePoints.map(p => ({
                lat: p.lat, lng: p.lng, name: p.name, type: p.type, 
                scheduledTime: p.scheduledTime ? new Date(p.scheduledTime).toISOString() : null,
                originalIndex: p.originalIndex 
            }));

            localStorage.setItem(CACHE_PREFIX + routeNameInput.value, JSON.stringify(savablePoints));
            alert(`Ruta "${routeNameInput.value}" guardada.`);
            loadSavedRoutesLists();
        }

        function loadRoute() {
            cancelEdit();
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) {
                alert("Selecciona una ruta para cargar.");
                return;
            }
            const savedData = localStorage.getItem(CACHE_PREFIX + selectedRouteName);
            if (!savedData) {
                alert("Error al cargar la ruta.");
                return;
            }

            clearCurrentRoute(); 
            const loadedPointsData = JSON.parse(savedData);
            
            // Temporary array to build routePoints before renumbering markers
            const tempLoadedPoints = [];

            loadedPointsData.forEach((p_data) => {
                const newPoint = {
                    ...p_data,
                    scheduledTime: p_data.scheduledTime ? new Date(p_data.scheduledTime) : null,
                    // Marker icon text will be set by renumberIntermediateMarkers or type
                    marker: L.marker([p_data.lat, p_data.lng], { 
                        icon: createDivIcon('', null, p_data.type), // Placeholder icon initially
                        draggable: true 
                    }).addTo(map)
                };
                
                newPoint.marker.on('dragend', function(event){
                    if (isTracking) {
                        event.target.setLatLng(L.latLng(newPoint.lat, newPoint.lng)); // Revert
                        alert("Detén el seguimiento para modificar la ruta.");
                        return;
                    }
                    const marker = event.target;
                    const position = marker.getLatLng();
                    const point = routePoints.find(p => p.marker === marker);
                    if (point) {
                        point.lat = position.lat;
                        point.lng = position.lng;
                        redrawRouteLine();
                         if (document.getElementById('autoCalcTimes').checked) {
                            calculateAndApplyIntermediateTimes();
                        }
                        updateStopsList();
                    }
                });

                newPoint.marker.on('click', function() {
                    if (isTracking) return;
                    activateEditModeForPoint(newPoint);
                });
                tempLoadedPoints.push(newPoint);
            });
            
            routePoints = tempLoadedPoints; // Assign to global routePoints

            // Set correct icons after all points are loaded and in routePoints
            routePoints.forEach(p => {
                let pointText;
                if (p.type === 'start') pointText = 'I';
                else if (p.type === 'end') pointText = 'F';
                else pointText = '*'; // Placeholder, will be renumbered
                p.marker.setIcon(createDivIcon(pointText, null, p.type));
            });

            renumberIntermediateMarkers(); 
            redrawRouteLine();
            updateStopsList();

            if (routePoints.length > 0) {
                if (routeLine && routeLine.getBounds().isValid()) {
                     map.fitBounds(routeLine.getBounds());
                } else {
                    map.setView([routePoints[0].lat, routePoints[0].lng], 13);
                }
            }
            document.getElementById('routeName').value = selectedRouteName;
            alert(`Ruta "${selectedRouteName}" cargada.`);
        }

        function deleteRoute() {
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) {
                alert("Selecciona una ruta para borrar.");
                return;
            }
            if (confirm(`¿Estás seguro de que quieres borrar la ruta "${selectedRouteName}"?`)) {
                localStorage.removeItem(CACHE_PREFIX + selectedRouteName);
                let queue = getRouteQueue();
                queue = queue.filter(name => name !== selectedRouteName);
                saveRouteQueue(queue);
                loadSavedRoutesLists(); // This will also update routeToQueueSelect
                alert(`Ruta "${selectedRouteName}" borrada.`);
            }
        }

        function loadSavedRoutesLists() { 
            const savedRoutesSelect = document.getElementById('savedRoutes');
            const routeToQueueSelect = document.getElementById('routeToQueue');
            const currentSavedRouteValue = savedRoutesSelect.value;
            const currentQueueRouteValue = routeToQueueSelect.value;

            savedRoutesSelect.innerHTML = ""; 
            routeToQueueSelect.innerHTML = "";

            let hasRoutes = false;
            const routeNames = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(CACHE_PREFIX)) {
                    routeNames.push(key.substring(CACHE_PREFIX.length));
                }
            }
            routeNames.sort(); 

            routeNames.forEach(routeName => {
                const option = document.createElement('option');
                option.value = routeName;
                option.textContent = routeName;
                savedRoutesSelect.appendChild(option.cloneNode(true));
                routeToQueueSelect.appendChild(option.cloneNode(true));
                hasRoutes = true;
            });
            
            if (!hasRoutes) {
                 const option = document.createElement('option');
                 option.textContent = "No hay rutas guardadas";
                 option.disabled = true;
                 savedRoutesSelect.appendChild(option.cloneNode(true));
                 routeToQueueSelect.appendChild(option);
            } else {
                if (routeNames.includes(currentSavedRouteValue)) savedRoutesSelect.value = currentSavedRouteValue;
                if (routeNames.includes(currentQueueRouteValue)) routeToQueueSelect.value = currentQueueRouteValue;
            }
            updateRouteQueueDisplay();
        }
        
        function getSortedRoutePointsForTracking() {
            const startPt = routePoints.find(p => p.type === 'start');
            const endPt = routePoints.find(p => p.type === 'end');
            const intermediatePts = routePoints.filter(p => p.type === 'intermediate')
                                        .sort((a, b) => {
                                            if (a.scheduledTime && b.scheduledTime) {
                                                return new Date(a.scheduledTime).getTime() - new Date(b.scheduledTime).getTime();
                                            }
                                            // Fallback to originalIndex if times are not set for some reason
                                            return a.originalIndex - b.originalIndex;
                                        });
            
            let trackingOrder = [];
            if (startPt) trackingOrder.push(startPt);
            trackingOrder.push(...intermediatePts);
            if (endPt) trackingOrder.push(endPt);
            return trackingOrder.filter(p => p); 
        }


        // --- Real-Time Tracking ---
        function startTracking() {
            const trackingPointsOrdered = getSortedRoutePointsForTracking();
            if (trackingPointsOrdered.length < 2) {
                alert("Crea o carga una ruta con al menos inicio y fin para comenzar el seguimiento.");
                return;
            }
            const startPoint = trackingPointsOrdered[0];
            const endPoint = trackingPointsOrdered[trackingPointsOrdered.length - 1];

            if (startPoint.type !== 'start' || endPoint.type !== 'end' || !startPoint.scheduledTime || !endPoint.scheduledTime) {
                 alert("La ruta debe tener un Inicio y Fin con horarios definidos para el seguimiento.");
                 return;
            }

            isTracking = true;
            currentSegmentStartIndex = 0; 
            routePoints = trackingPointsOrdered; // Global routePoints is now in tracking order

            document.getElementById('startTrackingBtn').style.display = 'none';
            document.getElementById('stopTrackingBtn').style.display = 'inline-block';
            document.getElementById('statusDisplay').style.display = 'block';
            document.getElementById('routeCreationSection').style.display = 'none'; 

            if (navigator.geolocation) {
                trackingIntervalId = navigator.geolocation.watchPosition(
                    handlePositionUpdate,
                    handleGeolocationError,
                    { enableHighAccuracy: true, maximumAge: 3000, timeout: 7000 } // Slightly adjusted values
                );
                if (routePoints.length > 0 && routePoints[0].lat && routePoints[0].lng) {
                    map.setView([routePoints[0].lat, routePoints[0].lng], 16); 
                }
                highlightNextStopInList(); // Initial highlight
            } else {
                alert("La geolocalización no está disponible en tu navegador.");
                stopTracking(false); // Pass false as it's not a natural completion
            }
             updateManualNavButtons();
        }

        function stopTracking(completedNaturally = false) {
            if (trackingIntervalId) {
                navigator.geolocation.clearWatch(trackingIntervalId);
                trackingIntervalId = null;
            }
            isTracking = false;
            lastKnownPosition = null;
            document.getElementById('startTrackingBtn').style.display = 'inline-block';
            document.getElementById('stopTrackingBtn').style.display = 'none';
            document.getElementById('statusDisplay').style.display = 'none';
            document.getElementById('routeCreationSection').style.display = 'block'; 
            
            if (userMarker) {
                map.removeLayer(userMarker);
                userMarker = null;
            }
            document.getElementById('timeDeviation').textContent = "00:00";
            document.getElementById('timeDeviation').style.color = "#FFFFFF";
            document.getElementById('speedDisplay').textContent = "Velocidad: 0 KM/H";
            
            const currentRouteName = document.getElementById('routeName').value;
            if (currentRouteName && localStorage.getItem(CACHE_PREFIX + currentRouteName)) {
                 loadRoute(); // Reloads the saved route to restore original order and data
            } else {
                 // If it was a new route not yet saved, restore to "display/edit" order
                const start = routePoints.find(p => p.type === 'start');
                const end = routePoints.find(p => p.type === 'end');
                const intermediates = routePoints.filter(p => p.type === 'intermediate')
                                        .sort((a,b) => a.originalIndex - b.originalIndex);
                let restoredRoutePoints = [];
                if (start) restoredRoutePoints.push(start);
                restoredRoutePoints.push(...intermediates);
                if (end) restoredRoutePoints.push(end);
                routePoints = restoredRoutePoints; // routePoints is now in edit order
                updateStopsList(); 
            }
            // currentSegmentStartIndex is reset by loadRoute or should be reset manually if not loading
            currentSegmentStartIndex = 0; 
            highlightNextStopInList(); 
            updateManualNavButtons();

            if (completedNaturally) {
                alert("Ruta completada!");
                checkRouteQueue();
            } else {
                console.log("Seguimiento detenido.");
            }
        }
        
        function updateManualNavButtons() {
            const manualNav = document.getElementById('manualStopNav').checked;
            const prevBtn = document.getElementById('prevStopBtn');
            const nextBtn = document.getElementById('nextStopBtn');

            if (isTracking && manualNav) {
                prevBtn.style.display = 'inline-block';
                nextBtn.style.display = 'inline-block';
                prevBtn.disabled = currentSegmentStartIndex === 0;
                nextBtn.disabled = currentSegmentStartIndex >= routePoints.length - 2; // Disabled if on the segment leading to the last stop
            } else {
                prevBtn.style.display = 'none';
                nextBtn.style.display = 'none';
            }
        }

        document.getElementById('manualStopNav').addEventListener('change', updateManualNavButtons);

        function handlePositionUpdate(position) {
            lastKnownPosition = position;
            const { latitude, longitude, speed } = position.coords;
            const userLatLng = L.latLng(latitude, longitude);

            if (!userMarker) {
                userMarker = L.marker(userLatLng, { icon: createUserLocationIcon() }).addTo(map);
            } else {
                userMarker.setLatLng(userLatLng);
            }
             map.panTo(userLatLng, {animate: true, duration: 0.5}); // Smooth pan

            const speedKmh = speed ? (speed * 3.6).toFixed(1) : 0;
            document.getElementById('speedDisplay').textContent = `Velocidad: ${speedKmh} KM/H`;

            if (currentSegmentStartIndex < routePoints.length - 1) { // Ensure there's a next segment/stop
                const manualNav = document.getElementById('manualStopNav').checked;

                if (!manualNav) {
                    const currentTargetStop = routePoints[currentSegmentStartIndex + 1];
                    const distanceToCurrentTarget = userLatLng.distanceTo(L.latLng(currentTargetStop.lat, currentTargetStop.lng));
                    const detectionRadius = 75; 
                    const lookAheadLimit = Math.min(routePoints.length -1, currentSegmentStartIndex + 4);

                    let advanced = false;

                    if (distanceToCurrentTarget < detectionRadius) {
                        console.log(`Avance por proximidad directa a ${currentTargetStop.name}`);
                        advanceToNextStop();
                        advanced = true;
                    } else {
                        let closestFutureStop = null;
                        let minDistanceToFutureStop = Infinity;
                        let bestFutureStopIndex = -1;

                        for (let i = currentSegmentStartIndex + 1; i < lookAheadLimit; i++) {
                             if (i >= routePoints.length) break; // Boundary check

                            const futureStop = routePoints[i]; // This is the stop itself, not the segment leading to it
                            const distToThisFutureStop = userLatLng.distanceTo(L.latLng(futureStop.lat, futureStop.lng));

                            if (distToThisFutureStop < minDistanceToFutureStop) {
                                minDistanceToFutureStop = distToThisFutureStop;
                                closestFutureStop = futureStop;
                                bestFutureStopIndex = i; // Index of the stop itself
                            }
                        }
                        
                        // If a future stop (beyond the current target) is closer and within a reasonable detection range
                        if (closestFutureStop && bestFutureStopIndex > (currentSegmentStartIndex + 1)) { 
                            if (minDistanceToFutureStop < distanceToCurrentTarget && minDistanceToFutureStop < detectionRadius * 2.5) {
                                console.log(`Saltando a ${closestFutureStop.name} (segmento ${bestFutureStopIndex -1}). Estaba apuntando a ${currentTargetStop.name}.`);
                                currentSegmentStartIndex = bestFutureStopIndex - 1; // Set to segment *before* the jumped-to stop
                                advanceToNextStop(); // This will increment currentSegmentStartIndex to bestFutureStopIndex
                                advanced = true;
                            }
                        }
                        
                        if (!advanced && routePoints[currentSegmentStartIndex] && routePoints[currentSegmentStartIndex+1]) {
                            const pointA = routePoints[currentSegmentStartIndex];
                            const pointB = routePoints[currentSegmentStartIndex + 1];
                            const latLngA = L.latLng(pointA.lat, pointA.lng);
                            const latLngB = L.latLng(pointB.lat, pointB.lng);
                            const totalSegmentDist = latLngA.distanceTo(latLngB);
                            if (totalSegmentDist > 0) { // Avoid division by zero
                                const distUserToA = userLatLng.distanceTo(latLngA);
                                const distUserToB = userLatLng.distanceTo(latLngB);
                                const progressAlongSegmentLine = distUserToA / totalSegmentDist;

                                if (progressAlongSegmentLine > 0.90 && distUserToB < distUserToA && distUserToB < totalSegmentDist * 0.5) {
                                    console.log(`Avance por pasar el 90% del segmento hacia ${pointB.name}`);
                                    advanceToNextStop();
                                    advanced = true;
                                }
                            }
                        }
                    }
                }
                calculateTimeDeviation(position);
            } else { // currentSegmentStartIndex is at the last segment, meaning user is heading to the last stop or has arrived
                document.getElementById('nextStopDisplay').textContent = "Ruta Completada";
                document.getElementById('timeDeviation').textContent = "00:00"; 
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                if(isTracking) { // Double check if still tracking
                    stopTracking(true); // Stop, route completed naturally
                }
            }
        }


        function advanceToNextStop() {
            currentSegmentStartIndex++;
            if (currentSegmentStartIndex >= routePoints.length - 1) { // Reached the last point (or segment leading to it)
                 if (isTracking) stopTracking(true); // Completed naturally
            } else {
                highlightNextStopInList();
                updateManualNavButtons();
                if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition);
            }
        }
        
        function goToPreviousStop() {
            if (currentSegmentStartIndex > 0) {
                currentSegmentStartIndex--;
                highlightNextStopInList();
                updateManualNavButtons();
                if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition);
            }
        }
        function goToNextStop() { 
             if (currentSegmentStartIndex < routePoints.length - 2) { // If not on the segment leading to the last stop
                advanceToNextStop(); 
            } else if (currentSegmentStartIndex === routePoints.length - 2) { // If on the segment leading to the last stop
                advanceToNextStop(); // This will complete the route
            }
        }


        function highlightNextStopInList() {
            const listItems = document.querySelectorAll('#stopsList .stop-item');
            listItems.forEach(item => item.classList.remove('next-stop-highlight'));
            
            // The visual list is generated by getSortedRoutePointsForDisplay()
            const pointsForVisualList = getSortedRoutePointsForDisplay(); 

            if (isTracking && routePoints.length > 0 && currentSegmentStartIndex < routePoints.length - 1) {
                // routePoints is in tracking order here
                const nextActualStopObject = routePoints[currentSegmentStartIndex + 1]; 
                document.getElementById('nextStopDisplay').textContent = `Próxima: ${nextActualStopObject.name}`;
                
                const displayIndex = pointsForVisualList.findIndex(dp => dp === nextActualStopObject);
                if (displayIndex !== -1 && listItems[displayIndex]) {
                    listItems[displayIndex].classList.add('next-stop-highlight');
                }
            } else if (!isTracking && pointsForVisualList.length > 0) {
                 document.getElementById('nextStopDisplay').textContent = `Próxima: ${pointsForVisualList[0].name}`;
                 // Highlight first item in the visual list if not tracking
                 if(listItems[0]) listItems[0].classList.add('next-stop-highlight');
            } else {
                document.getElementById('nextStopDisplay').textContent = "Próxima Parada: N/A";
            }
        }


        function calculateTimeDeviation(currentUserGeoPosition) { 
            if (!isTracking || currentSegmentStartIndex >= routePoints.length - 1) return; 

            // routePoints is in tracking order
            const pointA = routePoints[currentSegmentStartIndex]; 
            const pointB = routePoints[currentSegmentStartIndex + 1];

            if (!pointA || !pointB || !pointA.scheduledTime || !pointB.scheduledTime) {
                document.getElementById('timeDeviation').textContent = "N/A_T";
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                return;
            }

            const scheduledTimeA = new Date(pointA.scheduledTime);
            const scheduledTimeB = new Date(pointB.scheduledTime);
            const segmentTotalScheduledMillis = scheduledTimeB.getTime() - scheduledTimeA.getTime();

            if (segmentTotalScheduledMillis <= 0) {
                 document.getElementById('timeDeviation').textContent = "ERR_DUR"; 
                 document.getElementById('timeDeviation').style.color = "#FFA500"; 
                return;
            }

            const latLngA = L.latLng(pointA.lat, pointA.lng);
            const latLngB = L.latLng(pointB.lat, pointB.lng);
            const currentUserLatLng = L.latLng(currentUserGeoPosition.coords.latitude, currentUserGeoPosition.coords.longitude);

            const distanceTotalSegment = latLngA.distanceTo(latLngB); 
            
            if (distanceTotalSegment < 1) { // Segment is negligible in distance
                const now = new Date();
                let deviationMillis;
                // Heuristic: if very short segment, compare current time to start/end time of segment
                if (now.getTime() < scheduledTimeA.getTime()) { 
                    deviationMillis = scheduledTimeA.getTime() - now.getTime(); // Early for A
                } else if (now.getTime() > scheduledTimeB.getTime()) { 
                     deviationMillis = scheduledTimeB.getTime() - now.getTime(); // Late for B
                } else { // Between A and B's scheduled time, assume progress is relative to A
                    deviationMillis = scheduledTimeA.getTime() - now.getTime(); 
                }
                displayDeviation(deviationMillis);
                return;
            }
            
            const distToA = currentUserLatLng.distanceTo(latLngA);
            const distToB = currentUserLatLng.distanceTo(latLngB);
            let progressPercentage;

            if (distToB < 10) { 
                progressPercentage = 1.0;
            } else if (distToA < 10) { 
                progressPercentage = 0.0;
            }
            else if (distToA > distanceTotalSegment && distToB < distToA && (distToA > distToB + distanceTotalSegment - 20) ) { 
                 progressPercentage = 1.0; // Effectively past B
            }
            else if (distToB > distanceTotalSegment && distToA < distToB && (distToB > distToA + distanceTotalSegment - 20) ) {
                 progressPercentage = 0.0; // Effectively before A
            }
            else {
                const sumDistances = distToA + distToB;
                if (Math.abs(sumDistances - distanceTotalSegment) < Math.max(20, distanceTotalSegment * 0.25) ) { 
                    progressPercentage = distToA / distanceTotalSegment;
                } else {
                    // User significantly off-line, use projection or simpler ratio
                    progressPercentage = distToA / distanceTotalSegment; 
                }
            }

            progressPercentage = Math.max(0, Math.min(1, progressPercentage)); // Clamp

            const expectedTimeElapsedMillis = segmentTotalScheduledMillis * progressPercentage;
            const expectedTimeAtCurrentPosition = new Date(scheduledTimeA.getTime() + expectedTimeElapsedMillis);
            const currentTime = new Date();
            const deviationMillis = expectedTimeAtCurrentPosition.getTime() - currentTime.getTime(); 
            displayDeviation(deviationMillis);
        }

        function displayDeviation(deviationMillis) {
            const absMillis = Math.abs(deviationMillis);
            const totalSecondsValue = Math.floor(absMillis / 1000);
            const displaySeconds = totalSecondsValue % 60;
            const totalMinutesValue = Math.floor(totalSecondsValue / 60);
            const sign = deviationMillis >= 0 ? "+" : "-";
            
            const formattedDeviation = `${sign}${String(totalMinutesValue).padStart(2, '0')}:${String(displaySeconds).padStart(2, '0')}`;
            const deviationDiv = document.getElementById('timeDeviation');
            deviationDiv.textContent = formattedDeviation;

            if (deviationMillis >= -59999 && deviationMillis <= 59999) { // Within +/- 1 minute
                 deviationDiv.style.color = "#FFFFFF"; 
            } else if (deviationMillis > 59999) { 
                deviationDiv.style.color = "#00FF00"; 
            } else { 
                deviationDiv.style.color = "#FF0000"; 
            }
        }

        function handleGeolocationError(error) {
            console.error("Error de geolocalización: ", error);
            alert(`Error de geolocalización: ${error.message}. El seguimiento puede no funcionar correctamente.`);
            if (isTracking) stopTracking(false); // Stop tracking if a geo error occurs
        }

        // --- Route Queue Logic ---
        function getRouteQueue() {
            const storedQueue = localStorage.getItem(ROUTE_QUEUE_CACHE_KEY);
            return storedQueue ? JSON.parse(storedQueue) : [];
        }

        function saveRouteQueue(queue) {
            localStorage.setItem(ROUTE_QUEUE_CACHE_KEY, JSON.stringify(queue));
            updateRouteQueueDisplay();
        }

        function addRouteToQueue() {
            const selectedRouteName = document.getElementById('routeToQueue').value;
            if (!selectedRouteName || document.getElementById('routeToQueue').options[0]?.disabled) { // Check if "No hay rutas" is selected
                alert("Selecciona una ruta válida para añadir a la cola.");
                return;
            }
            const queue = getRouteQueue();
            if (queue.includes(selectedRouteName)) {
                alert(`La ruta "${selectedRouteName}" ya está en la cola.`);
                return;
            }
            queue.push(selectedRouteName);
            saveRouteQueue(queue);
            alert(`Ruta "${selectedRouteName}" añadida a la cola.`);
        }

        function updateRouteQueueDisplay() {
            const queueDiv = document.getElementById('routeQueueDisplay');
            const queue = getRouteQueue();
            if (queue.length === 0) {
                queueDiv.innerHTML = "Vacía.";
            } else {
                let html = "<ol>";
                queue.forEach(routeName => {
                    html += `<li>${routeName}</li>`;
                });
                html += "</ol>";
                queueDiv.innerHTML = html;
            }
        }
        
        function clearRouteQueue() {
            if (confirm("¿Limpiar toda la cola de rutas?")) {
                 saveRouteQueue([]);
            }
        }

        function checkRouteQueue() {
            let queue = getRouteQueue();
            if (queue.length > 0) {
                const nextRouteName = queue.shift(); 
                saveRouteQueue(queue); 

                if (confirm(`La ruta actual ha finalizado. ¿Iniciar la siguiente ruta en cola: "${nextRouteName}"?`)) {
                    // Ensure UI allows loading by selecting it in the dropdown
                    const savedRoutesSelect = document.getElementById('savedRoutes');
                    if (Array.from(savedRoutesSelect.options).some(opt => opt.value === nextRouteName)) {
                        savedRoutesSelect.value = nextRouteName; 
                        loadRoute(); 
                        setTimeout(() => {
                            // Verify routePoints is valid after loadRoute finishes (it's somewhat async with map updates)
                            const currentLoadedPoints = getSortedRoutePointsForTracking(); // Get current state of routePoints
                            if (currentLoadedPoints.length >= 2 && 
                                currentLoadedPoints.some(p=>p.type==='start') && 
                                currentLoadedPoints.some(p=>p.type==='end')) {
                                startTracking();
                            } else {
                                 alert("Error al cargar la siguiente ruta de la cola ('" + nextRouteName + "') o la ruta es inválida para seguimiento.")
                            }
                        }, 500); // Delay to allow loadRoute to fully process
                    } else {
                        alert(`La ruta "${nextRouteName}" no se encontró en las rutas guardadas. No se pudo cargar.`);
                    }
                } else {
                    alert("Siguiente ruta de la cola no iniciada. Puedes iniciarla manualmente.");
                }
            } else {
                console.log("Cola de rutas vacía.");
            }
        }

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadSavedRoutesLists(); 
            updateStopsList();
            updateManualNavButtons();

            // No need for duplicate getCurrentPosition if initMap already handles it
        });

    </script>
</body>
</html>
