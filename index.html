<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro (Unidireccional)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            overflow: hidden; /* Prevent body scroll */
            display: flex;
            flex-direction: column;
        }

        #map {
            height: 50vh; /* 50% of viewport height */
            width: 100%;
            background-color: #333; /* Placeholder color */
        }

        #controls {
            height: 50vh; /* 50% of viewport height */
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .control-section:last-child {
            border-bottom: none;
        }

        h2, h3, h4 {
            color: #FFFFFF;
            margin-top: 0;
            margin-bottom: 8px;
        }
        h3 { font-size: 1.1em; }
        h4 { font-size: 1em; margin-top: 10px;}


        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="text"], input[type="datetime-local"], input[type="number"], select {
            width: calc(100% - 12px);
            padding: 8px;
            margin-bottom: 10px;
            background-color: #222;
            color: #FFF;
            border: 1px solid #555;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        button:hover {
            background-color: #45a049;
        }
        button.danger {
            background-color: #f44336;
        }
        button.danger:hover {
            background-color: #da190b;
        }
        button.secondary {
            background-color: #007bff;
        }
        button.secondary:hover {
            background-color: #0056b3;
        }
        button.info {
            background-color: #17a2b8;
        }
        button.info:hover {
            background-color: #117a8b;
        }
        button.active-mode-button {
            background-color: #ff9800; /* Orange to show it's active */
            color: black;
            font-weight: bold;
        }
        button.active-mode-button:hover {
            background-color: #e68a00;
        }


        #statusDisplay {
            text-align: center;
            padding: 10px;
        }
        #timeDeviation {
            font-size: 3em; /* Larger font for time deviation */
            font-weight: bold;
            margin: 10px 0;
        }
        #trackingInfoDisplay, #speedDisplay, #nextStopDisplay {
            font-size: 1.2em;
            margin: 5px 0;
        }

        .stop-item {
            background-color: #1e1e1e;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
            cursor: pointer;
        }
        .stop-item:hover {
            background-color: #2f2f2f;
        }
        .stop-item.next-stop-highlight {
            background-color: #007bff;
            font-weight: bold;
        }
        .stop-item.line-endpoint-highlight {
            border-left: 3px solid #ffc107; /* Yellow border for line endpoints */
        }


        .leaflet-div-icon {
            background: transparent;
            border: none;
            text-align: center;
            font-weight: bold;
            color: white;
        }
        .waypoint-marker-icon {
            background-color:#888888 !important;
            width: 10px !important;
            height: 10px !important;
            border-radius: 50% !important;
            border: 1px solid #FFFFFF !important;
            box-sizing: border-box !important;
        }
        .intermediate-stop-icon {
            background-color:#2196F3 !important; /* Blue for intermediate stops */
            padding: 5px 8px !important;
            border-radius: 5px !important;
            color: white !important;
            font-size:12px !important;
            font-weight:bold !important;
            border: 1px solid white !important;
            min-width: 15px !important;
            text-align: center !important;
        }

        .user-location-icon {
            background-color: #007bff !important; /* Blue dot */
            border-radius: 50%;
            width: 16px !important;
            height: 16px !important;
            border: 2px solid white;
            box-shadow: 0 0 0 2px #007bff;
        }
        #lineEndpointTurnSchedulesContainer .turn-schedule-group {
            border-bottom: 1px dashed #444;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        #lineEndpointTurnSchedulesContainer .turn-schedule-group:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>

    <div id="map"></div>
    <div id="controls">
        <div id="statusDisplay" style="display: none;">
            <div id="trackingInfoDisplay">Vuelta: 1/1</div>
            <div id="timeDeviation">00:00</div>
            <div id="speedDisplay">Velocidad: 0 KM/H</div>
            <div id="nextStopDisplay">Próxima Parada: N/A</div>
        </div>

        <div class="control-section" id="routeCreationSection">
            <h3>Crear/Modificar Ruta (Unidireccional)</h3>
            <p style="font-size: 0.8em;">
                Toca el mapa para añadir Puntos de Paso, Paradas Intermedias o Puntos de Inicio/Final (máx. 1 de cada).
                Toca un punto existente para editarlo.
            </p>
            <div id="editModeSelection" style="margin-bottom:10px; display: flex; flex-wrap: wrap;">
                <button onclick="setActiveMode('waypoint')" id="modeWaypointBtn" class="info" style="margin-right:5px; margin-bottom:5px;">+Pto. Paso</button>
                <button onclick="setActiveMode('intermediateStop')" id="modeIntermediateStopBtn" class="info" style="margin-right:5px; margin-bottom:5px;">+Parada Inter.</button>
                <button onclick="setActiveMode('lineEndpoint')" id="modeLineEndpointBtn" class="info" style="margin-right:5px; margin-bottom:5px;">+Pto. Inicio/Final</button>
                <button onclick="setActiveMode('schedule')" id="modeScheduleBtn" class="secondary" style="margin-right:5px; margin-bottom:5px;">Editar Horarios</button>
                <button onclick="setActiveMode(null)" id="modeCancelBtn" class="danger" style="display:none; margin-bottom:5px;">X Cancelar Modo</button>
            </div>
            <p id="activeModeStatus" style="font-size: 0.8em; color: #17a2b8; margin-top:0; min-height: 1.2em;"></p>

            <label for="pointName">Nombre Punto:</label>
            <input type="text" id="pointName" placeholder="Ej: Terminal Central">

            <div id="lineEndpointTurnSchedulesContainer" style="display:none; max-height: 200px; overflow-y: auto; border: 1px solid #555; padding: 10px; margin-bottom:10px; background-color: #1a1a1a;">
                <!-- Horarios por vuelta para Puntos de Inicio/Final se generan aquí por JS -->
            </div>
             <small id="lineEndpointScheduleHelperText" style="font-size: 0.7em; display: none; margin-bottom: 10px; color: #ccc;">
                <b>Punto de Inicio (PI):</b> Para cada vuelta, definir la "Salida Programada".<br>
                <b>Punto Final (PF):</b> Para cada vuelta, definir la "Llegada Programada".
            </small>

            <div id="intermediateStopTimeContainer" style="display:none;">
                <label for="pointScheduledTimeIntermediate" id="intermediateTimeLabel">Horario Programado:</label>
                <input type="datetime-local" id="pointScheduledTimeIntermediate">
                <small style="font-size: 0.7em; display: block; margin-bottom: 5px; color: #ccc;">
                    Este horario es para la parada. Se puede calcular automáticamente usando la opción "Calcular horarios intermedios".
                </small>
            </div>

            <div id="editPointControls" style="display:none; margin-top:10px;">
                <button onclick="updateSelectedPoint()" class="secondary">Actualizar Punto</button>
                <button onclick="deleteSelectedPoint()" class="danger">Borrar Punto Seleccionado</button>
                <button onclick="cancelEdit()">Cancelar Edición</button>
            </div>
            <hr style="margin: 15px 0;">
            <input type="checkbox" id="autoCalcTimes" checked onchange="calculateAndApplyAllIntermediateTimes()">
            <label for="autoCalcTimes" style="display:inline;">Calcular horarios intermedios automáticamente (basado en horarios de Vuelta 1 de Pto. Inicio/Final)</label>
            <br><br>
            <button onclick="clearCurrentRoute()">Limpiar Ruta Actual</button>
        </div>

        <div class="control-section" id="routeSettingsSection">
            <h3>Configuración de Vueltas</h3>
            <label for="totalTurnsInput">Cantidad de Vueltas (ciclos completos Inicio-Final):</label>
            <input type="number" id="totalTurnsInput" value="1" min="1" onchange="updateRouteSettings()">
        </div>

        <div class="control-section">
            <h3>Configuración de Visualización</h3>
            <label for="stopRadiusInput">Radio de Paradas/Puntos (metros):</label>
            <input type="number" id="stopRadiusInput" value="50" min="10" max="500" onchange="updateGlobalStopRadiusSettings()">
        </div>

        <div class="control-section">
            <h3>Lista de Puntos (Paradas y Puntos de Inicio/Final)</h3>
            <div id="stopsList">No hay puntos definidos.</div>
        </div>

        <div class="control-section">
            <h3>Guardar/Cargar Rutas</h3>
            <label for="routeName">Nombre para Guardar Ruta:</label>
            <input type="text" id="routeName" placeholder="Ej: Ruta Centro">
            <button onclick="saveRoute()">Guardar Ruta</button>
            <br><br>
            <label for="savedRoutes">Cargar Ruta:</label>
            <select id="savedRoutes"></select>
            <button onclick="loadRoute()">Cargar</button>
            <button onclick="deleteRoute()" class="danger">Borrar Seleccionada</button>
        </div>

        <div class="control-section">
            <h3>Seguimiento</h3>
            <button id="startTrackingBtn" onclick="startTracking()">Iniciar Seguimiento</button>
            <button id="stopTrackingBtn" onclick="stopTracking()" class="danger" style="display:none;">Detener Seguimiento</button>
            <br>
            <input type="checkbox" id="manualStopNav" onchange="updateManualNavButtons()">
            <label for="manualStopNav" style="display:inline;">Navegación Manual de Puntos</label>
            <button id="prevStopBtn" onclick="goToPreviousActivePoint()" style="display:none;">Anterior</button>
            <button id="nextStopBtn" onclick="goToNextActivePoint()" style="display:none;">Siguiente</button>
        </div>

        <div class="control-section">
            <h3>Cola de Rutas</h3>
            <label for="routeToQueue">Añadir ruta guardada a la cola:</label>
            <select id="routeToQueue"></select>
            <button onclick="addRouteToQueue()">Añadir a Cola</button>
            <h4>En Cola:</h4>
            <div id="routeQueueDisplay">Vacía.</div>
            <button onclick="clearRouteQueue()">Limpiar Cola</button>
        </div>

    </div>

    <script>
        'use strict';
        let map;
        let routePoints = [];
        let routeLineEdit; // For editing view (single line)
        let trackingRouteLine; // For tracking view
        let userMarker;
        let trackingIntervalId;
        let isTracking = false;
        let currentSegmentStartIndex = 0;
        let lastKnownPosition = null;
        let currentlyEditingPoint = null;
        let currentStopRadius = 50;

        let activePointCreationMode = null; // null | 'waypoint' | 'intermediateStop' | 'lineEndpoint'
        let timeEditingPriority = false; // true if 'schedule' mode is active

        const CACHE_PREFIX = 'smartMovePro_unidir_route_'; // Changed prefix for new structure
        const ROUTE_QUEUE_CACHE_KEY = 'smartMovePro_unidir_routeQueue';

        let routeSettings = {
            totalTurns: 1
        };

        let trackingState = {
            currentTurn: 1,
            activeLegPoints: [],
        };

        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }

        function createDivIcon(text, pointCategory = '', isStartPoint = false) {
            let htmlContent = '';
            let iconSize = [30,30];
            let iconAnchor = [15,15];
            let className = 'leaflet-div-icon';

            if (pointCategory === 'waypoint') {
                className += ' waypoint-marker-icon';
                iconSize = [12,12];
                iconAnchor = [6,6];
            } else if (pointCategory === 'lineEndpoint') {
                const bgColor = isStartPoint ? '#FF8C00' : '#DA70D6'; // Orange for Start, Orchid for End
                const P_char = text ? text.substring(0,2).toUpperCase() : (isStartPoint ? 'PI' : 'PF');
                htmlContent = `<div style="background-color:${bgColor}; width: 28px; height:28px; display:flex; justify-content:center; align-items:center; border-radius: 50%; color: white; font-size:14px; font-weight:bold; border: 2px solid white;">${P_char}</div>`;
                iconSize = [32,32];
                iconAnchor = [16,16];
            } else { // intermediateStop
                className += ' intermediate-stop-icon'; // Specific class for consistent styling
                const displayText = text || '?';
                htmlContent = displayText; // Leaflet will wrap this in a div with the class
                // iconSize will be auto by Leaflet based on content, or can be set if fixed size needed
                // For dynamic width based on text:
                const tempSpan = document.createElement('span');
                tempSpan.style.fontSize = '12px';
                tempSpan.style.fontWeight = 'bold';
                tempSpan.style.visibility = 'hidden';
                tempSpan.style.position = 'absolute';
                tempSpan.textContent = displayText;
                document.body.appendChild(tempSpan);
                const textWidth = tempSpan.offsetWidth;
                document.body.removeChild(tempSpan);
                iconSize = [Math.max(15, textWidth) + 16, 20 + 10]; // width, height (padding included in style)
                iconAnchor = [iconSize[0]/2, iconSize[1]/2];
            }

            return L.divIcon({
                className: className,
                html: htmlContent,
                iconSize: iconSize,
                iconAnchor: iconAnchor
            });
        }

        function createUserLocationIcon() {
            return L.divIcon({
                className: 'user-location-icon',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        function initMap() {
            map = L.map('map').setView([-34.6037, -58.3816], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            map.on('click', onMapClick);
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    map.setView([position.coords.latitude, position.coords.longitude], 13);
                });
            }
            document.getElementById('stopRadiusInput').value = currentStopRadius;
            updateRouteSettings();
        }

        function setActiveMode(modeName) {
            const modeButtons = {
                waypoint: document.getElementById('modeWaypointBtn'),
                intermediateStop: document.getElementById('modeIntermediateStopBtn'),
                lineEndpoint: document.getElementById('modeLineEndpointBtn'),
                schedule: document.getElementById('modeScheduleBtn')
            };
            const statusP = document.getElementById('activeModeStatus');
            const cancelBtn = document.getElementById('modeCancelBtn');

            activePointCreationMode = null;
            timeEditingPriority = false;
            Object.values(modeButtons).forEach(btn => {
                if(btn) btn.classList.remove('active-mode-button');
            });
            cancelEdit();

            if (modeName === null) {
                statusP.textContent = "Selecciona un modo o toca un punto existente para editar.";
                statusP.style.color = '#FFFFFF';
                cancelBtn.style.display = 'none';
                updateWaypointMarkersVisibility(false);
                return;
            }

            if(modeButtons[modeName]) modeButtons[modeName].classList.add('active-mode-button');
            cancelBtn.style.display = 'inline-block';
            statusP.style.color = '#17a2b8';

            switch (modeName) {
                case 'waypoint':
                    activePointCreationMode = 'waypoint';
                    statusP.textContent = "Modo 'Añadir Punto de Paso' ACTIVO. Toca el mapa para añadir. Toca un punto de paso existente para borrarlo.";
                    updateWaypointMarkersVisibility(true);
                    break;
                case 'intermediateStop':
                    activePointCreationMode = 'intermediateStop';
                    statusP.textContent = `Modo 'Añadir Parada Intermedia' ACTIVO. Toca el mapa para añadir.`;
                    updateWaypointMarkersVisibility(false);
                    break;
                case 'lineEndpoint':
                    activePointCreationMode = 'lineEndpoint';
                    statusP.textContent = "Modo 'Añadir Punto de Inicio/Final' ACTIVO. Toca el mapa para añadir (máx. 1 de cada).";
                    updateWaypointMarkersVisibility(false);
                    break;
                case 'schedule':
                    timeEditingPriority = true;
                    statusP.textContent = "Modo 'Editar Horarios' ACTIVO. Toca una parada o punto de inicio/final para editar sus horarios.";
                    updateWaypointMarkersVisibility(false);
                    break;
            }
        }

        function updateWaypointMarkersVisibility(showWaypointsOverride = null) {
            const show = showWaypointsOverride !== null ? showWaypointsOverride : (activePointCreationMode === 'waypoint');
            routePoints.forEach(p => {
                if (p.pointCategory === 'waypoint' && p.marker) {
                    if (show) {
                        if (!map.hasLayer(p.marker)) map.addLayer(p.marker);
                    } else {
                        if (map.hasLayer(p.marker)) map.removeLayer(p.marker);
                    }
                }
            });
        }

        function updateRouteSettings() {
            const oldTotalTurns = routeSettings.totalTurns;
            routeSettings.totalTurns = parseInt(document.getElementById('totalTurnsInput').value) || 1;

            if (oldTotalTurns !== routeSettings.totalTurns) {
                routePoints.forEach(p => {
                    if (p.pointCategory === 'lineEndpoint') {
                        if (!p.turnSchedules) p.turnSchedules = [];
                        const newSchedules = new Array(routeSettings.totalTurns);
                        for (let i = 0; i < routeSettings.totalTurns; i++) {
                            const existing = p.turnSchedules[i] || {};
                            newSchedules[i] = { // Simplified for single time property
                                scheduledTime: existing.scheduledTime || null
                            };
                        }
                        p.turnSchedules = newSchedules;
                    }
                });
                if (currentlyEditingPoint && currentlyEditingPoint.pointCategory === 'lineEndpoint') {
                    activateEditModeForPoint(currentlyEditingPoint);
                }
            }
            redrawRouteLine();
            updateTrackingStatusDisplay();
            updateAllMarkerIconsAndLabels();
            updateStopsList();
        }

        function formatDateTimeForInput(date) {
            if (!date || isNaN(new Date(date).getTime())) return "";
            const d = new Date(date);
            d.setMinutes(d.getMinutes() - d.getTimezoneOffset());
            return d.toISOString().slice(0, 16);
        }

        function activateEditModeForPoint(point) {
            if (isTracking) { return; }
            if (point.pointCategory === 'waypoint') {
                 if (activePointCreationMode === 'waypoint') {
                 } else {
                    alert("Para interactuar con Puntos de Paso, active el modo '+Pto. Paso'.");
                 }
                return;
            }

            if (activePointCreationMode !== null && activePointCreationMode !== 'schedule') {
                setActiveMode(null);
            } else if (activePointCreationMode !== 'schedule') {
                 cancelEdit();
            }

            currentlyEditingPoint = point;
            document.getElementById('pointName').value = point.name;
            document.getElementById('pointName').readOnly = timeEditingPriority;

            document.getElementById('lineEndpointTurnSchedulesContainer').style.display = 'none';
            document.getElementById('lineEndpointScheduleHelperText').style.display = 'none';
            document.getElementById('intermediateStopTimeContainer').style.display = 'none';

            if (point.pointCategory === 'lineEndpoint') {
                const container = document.getElementById('lineEndpointTurnSchedulesContainer');
                container.innerHTML = '';
                container.style.display = 'block';
                document.getElementById('lineEndpointScheduleHelperText').style.display = 'block';

                const totalTurns = routeSettings.totalTurns;
                if (!point.turnSchedules || point.turnSchedules.length !== totalTurns) {
                    const newSchedules = new Array(totalTurns);
                    for (let i = 0; i < totalTurns; i++) {
                        const existing = (point.turnSchedules && point.turnSchedules[i]) ? point.turnSchedules[i] : {};
                        newSchedules[i] = { scheduledTime: existing.scheduledTime || null };
                    }
                    point.turnSchedules = newSchedules;
                }

                for (let i = 0; i < totalTurns; i++) {
                    const turnNum = i + 1;
                    const turnSchedule = point.turnSchedules[i];
                    const turnDiv = document.createElement('div');
                    turnDiv.className = 'turn-schedule-group';
                    turnDiv.innerHTML = `<h4>Vuelta ${turnNum}</h4>`;
                    let labelText, inputId, value;

                    if (point.isStartPoint) { // Punto de Inicio
                        labelText = "Salida Programada:"; inputId = `endpoint_turn_${turnNum}_time`; value = turnSchedule.scheduledTime;
                    } else { // Punto Final
                        labelText = "Llegada Programada:"; inputId = `endpoint_turn_${turnNum}_time`; value = turnSchedule.scheduledTime;
                    }
                    turnDiv.innerHTML += `
                        <label for="${inputId}">${labelText}</label>
                        <input type="datetime-local" id="${inputId}" value="${formatDateTimeForInput(value)}">
                    `;
                    container.appendChild(turnDiv);
                }
                if(timeEditingPriority && document.getElementById(`endpoint_turn_1_time`)) {
                    document.getElementById(`endpoint_turn_1_time`).focus();
                }

            } else if (point.pointCategory === 'intermediateStop') {
                document.getElementById('intermediateStopTimeContainer').style.display = 'block';
                document.getElementById('intermediateTimeLabel').textContent = `Horario Programado (Parada):`;
                document.getElementById('pointScheduledTimeIntermediate').value = formatDateTimeForInput(point.scheduledTime);
                 if(timeEditingPriority) document.getElementById('pointScheduledTimeIntermediate').focus();
            }

            document.getElementById('editPointControls').style.display = 'block';
            if (!timeEditingPriority) document.getElementById('pointName').focus();
        }

        function cancelEdit() {
            currentlyEditingPoint = null;
            document.getElementById('pointName').value = "";
            document.getElementById('pointName').readOnly = false;
            document.getElementById('lineEndpointTurnSchedulesContainer').style.display = 'none';
            document.getElementById('lineEndpointTurnSchedulesContainer').innerHTML = '';
            document.getElementById('lineEndpointScheduleHelperText').style.display = 'none';
            document.getElementById('pointScheduledTimeIntermediate').value = "";
            document.getElementById('intermediateStopTimeContainer').style.display = 'none';
            document.getElementById('editPointControls').style.display = 'none';
        }

        function updateSelectedPoint() {
            if (!currentlyEditingPoint || currentlyEditingPoint.pointCategory === 'waypoint') return;

            if (!timeEditingPriority) {
                const newName = document.getElementById('pointName').value.trim();
                if (!newName) { alert("El nombre del punto no puede estar vacío."); return; }
                currentlyEditingPoint.name = newName;
            }

            if (currentlyEditingPoint.pointCategory === 'lineEndpoint') {
                const totalTurns = routeSettings.totalTurns;
                currentlyEditingPoint.turnSchedules = [];
                for (let i = 0; i < totalTurns; i++) {
                    const turnNum = i + 1;
                    const timeValue = document.getElementById(`endpoint_turn_${turnNum}_time`).value;
                    let dateVal = timeValue ? new Date(timeValue) : null;
                    if (timeValue && isNaN(dateVal.getTime())) {
                        alert(`Formato de fecha/hora inválido para ${currentlyEditingPoint.isStartPoint ? 'Punto de Inicio' : 'Punto Final'}, Vuelta ${turnNum}.`); return;
                    }
                    currentlyEditingPoint.turnSchedules.push({ scheduledTime: dateVal });
                }
            } else if (currentlyEditingPoint.pointCategory === 'intermediateStop') {
                const timeValue = document.getElementById('pointScheduledTimeIntermediate').value;
                currentlyEditingPoint.scheduledTime = timeValue ? new Date(timeValue) : null;
                if (timeValue && isNaN(currentlyEditingPoint.scheduledTime?.getTime())) {
                     alert("Formato de fecha/hora inválido para Parada Intermedia.");
                     currentlyEditingPoint.scheduledTime = null;
                }
            }

            if (document.getElementById('autoCalcTimes').checked) {
                calculateAndApplyAllIntermediateTimes();
            }
            updateAllMarkerIconsAndLabels();
            redrawRouteLine();
            updateStopsList();
            alert(`Punto "${currentlyEditingPoint.name}" actualizado.`);
            cancelEdit();
        }

        function deleteSelectedPoint() {
            if (!currentlyEditingPoint || currentlyEditingPoint.pointCategory === 'waypoint') return;
            if (confirm(`¿Seguro que quieres borrar el punto "${currentlyEditingPoint.name}"?`)) {
                map.removeLayer(currentlyEditingPoint.marker);
                if (currentlyEditingPoint.radiusCircle) map.removeLayer(currentlyEditingPoint.radiusCircle);
                const pointNameToDelete = currentlyEditingPoint.name;
                routePoints = routePoints.filter(p => p.id !== currentlyEditingPoint.id);

                // If a line endpoint was deleted, ensure the remaining one (if any) is correctly identified
                // or allow creation of a new one.
                const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
                if (lineEndpoints.length === 1) {
                    // If one remains, it could be either start or end. This logic might need to be smarter
                    // or simply let the user define the next one. For now, if one PI exists, the next will be PF and vice-versa.
                }


                if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                updateAllMarkerIconsAndLabels(); redrawRouteLine(); updateStopsList();
                alert(`Punto "${pointNameToDelete}" borrado.`);
            }
            cancelEdit();
        }

        function updateAllMarkerIconsAndLabels() {
            const displayOrderedPoints = getSortedRoutePointsForDisplay();
            routePoints.forEach(p => {
                if (p.marker) {
                    let text = '';
                    if (p.pointCategory === 'lineEndpoint') {
                        text = p.name;
                    } else if (p.pointCategory === 'intermediateStop') {
                        const displayIdx = displayOrderedPoints.filter(dp => dp.pointCategory === 'intermediateStop').findIndex(dp => dp.id === p.id);
                        text = (displayIdx !== -1) ? String(displayIdx + 1) : '?';
                    }
                    p.marker.setIcon(createDivIcon(text, p.pointCategory, p.isStartPoint));
                }
            });
        }

        function onMapClick(e) {
            if (isTracking) { alert("Detén el seguimiento para modificar la ruta."); return; }
            let targetIsMarkerIcon = e.originalEvent.target.closest && e.originalEvent.target.closest('.leaflet-marker-icon');
            if (currentlyEditingPoint && !targetIsMarkerIcon) cancelEdit();
            if (targetIsMarkerIcon) return;

            const latlng = e.latlng; const pointId = generateUniqueId();

            if (activePointCreationMode) {
                document.getElementById('pointName').value = "";
                let newPointData = { id: pointId, lat: latlng.lat, lng: latlng.lng, originalIndex: routePoints.length };

                switch (activePointCreationMode) {
                    case 'waypoint':
                        const waypoint = {
                            id: pointId, lat: latlng.lat, lng: latlng.lng,
                            name: `Paso ${routePoints.filter(p => p.pointCategory === 'waypoint').length + 1}`,
                            pointCategory: 'waypoint',
                            marker: L.marker(latlng, { icon: createDivIcon(null, 'waypoint'), draggable: true }),
                            radiusCircle: null, originalIndex: routePoints.length
                        };
                        if (map.hasLayer(waypoint.marker)) map.removeLayer(waypoint.marker);
                        map.addLayer(waypoint.marker);
                        waypoint.marker.on('dragend', function(event) {
                            if (isTracking) { event.target.setLatLng(L.latLng(waypoint.lat, waypoint.lng)); return; }
                            const pos = event.target.getLatLng(); waypoint.lat = pos.lat; waypoint.lng = pos.lng;
                            redrawRouteLine();
                            if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                        });
                        waypoint.marker.on('click', function(ev) {
                            L.DomEvent.stopPropagation(ev); if (isTracking) return;
                            if (activePointCreationMode === 'waypoint') {
                                if (confirm(`¿Borrar este punto de paso "${waypoint.name}"?`)) {
                                    map.removeLayer(waypoint.marker);
                                    routePoints = routePoints.filter(p => p.id !== waypoint.id);
                                    redrawRouteLine();
                                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                                }
                            } else alert("Para borrar Puntos de Paso, active el modo '+Pto. Paso'.");
                        });
                        routePoints.push(waypoint);
                        routePoints.sort((a,b) => a.originalIndex - b.originalIndex);
                        routePoints.forEach((p, idx) => p.originalIndex = idx);
                        if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                        redrawRouteLine(); return;

                    case 'intermediateStop':
                        const intermediateCount = routePoints.filter(p => p.pointCategory === 'intermediateStop').length + 1;
                        newPointData.name = `Parada ${intermediateCount}`;
                        newPointData.pointCategory = 'intermediateStop';
                        newPointData.scheduledTime = null;
                        break;

                    case 'lineEndpoint':
                        const currentLineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
                        if (currentLineEndpoints.length >= 2) { alert("Ya existen un Punto de Inicio y un Punto Final."); return; }
                        
                        const hasStartPoint = currentLineEndpoints.some(p => p.isStartPoint);
                        // If no start point exists, this new point is the start point. Otherwise, it's the end point.
                        newPointData.isStartPoint = !hasStartPoint;
                        newPointData.name = newPointData.isStartPoint ? "Punto de Inicio" : "Punto Final";
                        newPointData.pointCategory = 'lineEndpoint';
                        newPointData.turnSchedules = new Array(routeSettings.totalTurns).fill(null).map(() => ({
                            scheduledTime: null
                        }));
                        break;
                    default: return;
                }

                const newPoint = { ...newPointData }; routePoints.push(newPoint);
                routePoints.sort((a,b) => a.originalIndex - b.originalIndex);
                routePoints.forEach((p, idx) => p.originalIndex = idx);

                newPoint.marker = L.marker(latlng, {
                    icon: createDivIcon(newPoint.name, newPoint.pointCategory, newPoint.isStartPoint), draggable: true
                }).addTo(map);
                newPoint.radiusCircle = L.circle(latlng, {
                    radius: currentStopRadius,
                    color: (newPoint.pointCategory === 'lineEndpoint' ? (newPoint.isStartPoint ? '#FF8C00':'#DA70D6') : '#2196F3'),
                    weight: 1, opacity: 0.5,
                    fillColor: (newPoint.pointCategory === 'lineEndpoint' ? (newPoint.isStartPoint ? '#FF8C00':'#DA70D6') : '#2196F3'), fillOpacity: 0.2
                }).addTo(map);

                newPoint.marker.on('dragend', function(event) {
                    if (isTracking) {event.target.setLatLng(L.latLng(newPoint.lat, newPoint.lng)); return; }
                    const pos = event.target.getLatLng(); newPoint.lat = pos.lat; newPoint.lng = pos.lng;
                    if (newPoint.radiusCircle) newPoint.radiusCircle.setLatLng(pos);
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                    updateStopsList();
                });
                newPoint.marker.on('click', function(ev) { L.DomEvent.stopPropagation(ev); if (isTracking) return; activateEditModeForPoint(newPoint); });

                updateAllMarkerIconsAndLabels();
                if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                redrawRouteLine(); updateStopsList();
            }
        }
        
        // Simplified: Gets all points relevant for drawing the single-direction polyline
        function getPathPointsForPolyline() {
            const allPointsSorted = [...routePoints].sort((a, b) => a.originalIndex - b.originalIndex);
            if (allPointsSorted.length < 1) return [];

            const startPoint = allPointsSorted.find(p => p.pointCategory === 'lineEndpoint' && p.isStartPoint);
            const endPoint = allPointsSorted.find(p => p.pointCategory === 'lineEndpoint' && !p.isStartPoint);

            if (!startPoint || !endPoint) { // If either start or end is missing, return all non-intermediate for basic drawing
                 return allPointsSorted.filter(p => p.pointCategory !== 'intermediateStop').map(p => ({...p}));
            }
            
            const startIndexInSorted = allPointsSorted.findIndex(p => p.id === startPoint.id);
            const endIndexInSorted = allPointsSorted.findIndex(p => p.id === endPoint.id);

            let segmentPoints;
            if (startIndexInSorted <= endIndexInSorted) {
                segmentPoints = allPointsSorted.slice(startIndexInSorted, endIndexInSorted + 1);
            } else { // Route "wraps around" in the originalIndex order
                segmentPoints = [
                    ...allPointsSorted.slice(startIndexInSorted),
                    ...allPointsSorted.slice(0, endIndexInSorted + 1)
                ];
            }
            // Filter to ensure only points logically part of this segment are included
            // (e.g. waypoints, and intermediate stops specifically for this path)
            return segmentPoints.filter(p =>
                p.pointCategory === 'lineEndpoint' ||
                p.pointCategory === 'waypoint' ||
                p.pointCategory === 'intermediateStop' // All intermediate stops are now part of the single path
            ).map(p => ({...p})); // Return copies
        }


        function calculateAndApplyAllIntermediateTimes() {
            const autoCalc = document.getElementById('autoCalcTimes').checked;
            if (!autoCalc) {
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => {
                    stop.scheduledTime = null;
                });
                updateStopsList(); return;
            }

            const startPoint = routePoints.find(p => p.pointCategory === 'lineEndpoint' && p.isStartPoint);
            const endPoint = routePoints.find(p => p.pointCategory === 'lineEndpoint' && !p.isStartPoint);

            if (!startPoint || !endPoint) { updateStopsList(); return; }

            if (!startPoint.turnSchedules || startPoint.turnSchedules.length === 0 || !startPoint.turnSchedules[0].scheduledTime ||
                !endPoint.turnSchedules || endPoint.turnSchedules.length === 0 || !endPoint.turnSchedules[0].scheduledTime) {
                // console.warn("Turn 1 schedules for Start/End points are not initialized for auto-calculation.");
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => stop.scheduledTime = null);
                updateStopsList(); return;
            }
            const legStartTime = new Date(startPoint.turnSchedules[0].scheduledTime);
            const legEndTime = new Date(endPoint.turnSchedules[0].scheduledTime);

            const pathForCalc = getPathPointsForPolyline(); // This path already respects start/end order
            distributeTimesProportionally(pathForCalc, legStartTime, legEndTime);
            updateStopsList();
        }

        function distributeTimesProportionally(legPathPoints, legStartTimeDate, legEndTimeDate) {
            if (!legStartTimeDate || !legEndTimeDate || legPathPoints.length < 2) return;

            const legStartMillis = legStartTimeDate.getTime();
            const legEndMillis = legEndTimeDate.getTime();
            const totalDurationMillis = legEndMillis - legStartMillis;

            const intermediateStopsInLeg = legPathPoints.slice(1, -1) // Exclude start and end points of the legPath
                .filter(p => p.pointCategory === 'intermediateStop');

            if (totalDurationMillis <= 0) {
                intermediateStopsInLeg.forEach(p_leg => {
                    const pointInMainRoute = routePoints.find(rp => rp.id === p_leg.id);
                    if(pointInMainRoute) pointInMainRoute.scheduledTime = new Date(legStartMillis);
                });
                return;
            }

            let totalDistance = 0; const segmentDistances = [];
            for (let i = 0; i < legPathPoints.length - 1; i++) {
                const dist = L.latLng(legPathPoints[i].lat, legPathPoints[i].lng)
                               .distanceTo(L.latLng(legPathPoints[i+1].lat, legPathPoints[i+1].lng));
                segmentDistances.push(dist); totalDistance += dist;
            }

            if (totalDistance < 1.0) { // Negligible distance
                const numTimeSegments = intermediateStopsInLeg.length + 1;
                if (numTimeSegments <= 0) return;
                const timePerSegment = totalDurationMillis / numTimeSegments;
                let currentTime = legStartMillis;

                for (let i = 0; i < intermediateStopsInLeg.length; i++) {
                    currentTime += timePerSegment;
                    const pointInMainRoute = routePoints.find(rp => rp.id === intermediateStopsInLeg[i].id);
                    if (pointInMainRoute) pointInMainRoute.scheduledTime = new Date(currentTime);
                }
            } else { // Distribute by distance
                let accumulatedDistance = 0;
                for (let i = 0; i < legPathPoints.length - 1; i++) {
                    accumulatedDistance += segmentDistances[i];
                    const nextPointInPath = legPathPoints[i+1];
                    if (nextPointInPath.pointCategory === 'intermediateStop') {
                        const proportionOfRoute = accumulatedDistance / totalDistance;
                        const timeOffsetMillis = totalDurationMillis * proportionOfRoute;
                        const pointInMainRoute = routePoints.find(rp => rp.id === nextPointInPath.id);
                        if(pointInMainRoute) pointInMainRoute.scheduledTime = new Date(legStartMillis + timeOffsetMillis);
                    }
                }
            }
        }

        function clearCurrentRoute() {
            setActiveMode(null);
            routePoints.forEach(p => {
                if (p.marker) map.removeLayer(p.marker);
                if (p.radiusCircle) map.removeLayer(p.radiusCircle);
            });
            routePoints = [];
            if (routeLineEdit) map.removeLayer(routeLineEdit); routeLineEdit = null;
            if (trackingRouteLine) map.removeLayer(trackingRouteLine); trackingRouteLine = null;

            document.getElementById('pointName').value = "";
            updateStopsList(); updateAllMarkerIconsAndLabels(); redrawRouteLine();
        }

        function redrawRouteLine() {
            if (routeLineEdit) map.removeLayer(routeLineEdit); routeLineEdit = null;
            if (trackingRouteLine) map.removeLayer(trackingRouteLine); trackingRouteLine = null;

            const polylinePathPoints = getPathPointsForPolyline();
            if (polylinePathPoints.length > 1) {
                const latlngs = polylinePathPoints.map(p => [p.lat, p.lng]);
                if (isTracking) {
                    trackingRouteLine = L.polyline(latlngs, {color: 'green', weight: 7, opacity: 0.8}).addTo(map);
                } else {
                    routeLineEdit = L.polyline(latlngs, {color: 'purple', weight: 5, dashArray: '5, 5'}).addTo(map);
                }
            }
        }

        function getSortedRoutePointsForDisplay() {
            return [...routePoints].sort((a, b) => a.originalIndex - b.originalIndex)
                                  .filter(p => p.pointCategory !== 'waypoint');
        }

        function formatTime(dateObj, includeDate = true) {
            if (!dateObj || isNaN(new Date(dateObj).getTime())) return "N/A";
            let timeStr = new Date(dateObj).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            if (includeDate) {
                 timeStr += ` (${new Date(dateObj).toLocaleDateString('es-ES', {day:'2-digit', month:'2-digit'})})`;
            }
            return timeStr;
        }

        function updateStopsList() {
            const listDiv = document.getElementById('stopsList');
            const displayPoints = getSortedRoutePointsForDisplay();

            if (displayPoints.length === 0) { listDiv.innerHTML = "No hay puntos definidos."; return; }

            let html = "<ul style='padding-left: 10px; list-style: none;'>";
            let intermediateVisualCounter = 1;
            let overallCounter = 1;

            displayPoints.forEach((p) => {
                let typeText = "", timeStr = "N/A";
                let itemClass = "stop-item";
                let prefix = `${overallCounter++}. `;

                if (p.pointCategory === 'lineEndpoint') {
                    itemClass += " line-endpoint-highlight";
                    typeText = p.isStartPoint ? "P. Inicio" : "P. Final";
                    if (p.turnSchedules && p.turnSchedules.length > 0 && p.turnSchedules[0].scheduledTime) {
                        timeStr = `${p.isStartPoint ? 'Salida' : 'Llegada'} (V1): ${formatTime(p.turnSchedules[0].scheduledTime, true)}`;
                    } else timeStr = "Horario (V1) no definido";
                } else if (p.pointCategory === 'intermediateStop') {
                    typeText = `Inter. ${intermediateVisualCounter++}`;
                    timeStr = `Prog: ${formatTime(p.scheduledTime, true)}`;
                }
                html += `<li class="${itemClass}" onclick="focusPointOnMap('${p.id}')">${prefix}<b>${p.name}</b> (${typeText}) - ${timeStr}</li>`;
            });
            html += "</ul>";
            listDiv.innerHTML = html;
            highlightNextStopInList();
        }

        function focusPointOnMap(pointId) {
            const point = routePoints.find(p => p.id === pointId);
            if (point && map) {
                map.setView([point.lat, point.lng], Math.max(map.getZoom(), 16));
            }
        }

        function saveRoute() {
            setActiveMode(null);
            const routeNameInput = document.getElementById('routeName');
            if (!routeNameInput.value) { alert("Por favor, ingresa un nombre para la ruta."); return; }

            const startPoint = routePoints.find(p => p.pointCategory === 'lineEndpoint' && p.isStartPoint);
            const endPoint = routePoints.find(p => p.pointCategory === 'lineEndpoint' && !p.isStartPoint);
            if (!startPoint || !endPoint) { alert("Una ruta debe tener un Punto de Inicio y un Punto Final."); return; }

            let allEndpointTimesSet = true;
            for (let i = 0; i < routeSettings.totalTurns; i++) {
                if (!startPoint.turnSchedules || !startPoint.turnSchedules[i] || !startPoint.turnSchedules[i].scheduledTime) { allEndpointTimesSet = false; break; }
                if (!endPoint.turnSchedules || !endPoint.turnSchedules[i] || !endPoint.turnSchedules[i].scheduledTime) { allEndpointTimesSet = false; break; }
            }
            if (!allEndpointTimesSet) { alert("Punto de Inicio y Punto Final deben tener horarios definidos para CADA VUELTA."); return; }

            const savablePoints = routePoints.map(p => {
                const pointData = {
                    id: p.id, lat: p.lat, lng: p.lng, name: p.name,
                    pointCategory: p.pointCategory, originalIndex: p.originalIndex,
                };
                if (p.pointCategory === 'lineEndpoint') {
                    pointData.isStartPoint = p.isStartPoint;
                    pointData.turnSchedules = (p.turnSchedules || []).map(ts => ({
                        scheduledTime: ts.scheduledTime ? new Date(ts.scheduledTime).toISOString() : null
                    }));
                } else if (p.pointCategory === 'intermediateStop') {
                    pointData.scheduledTime = p.scheduledTime ? new Date(p.scheduledTime).toISOString() : null;
                }
                return pointData;
            });

            const routeDataToSave = { points: savablePoints, settings: routeSettings };
            localStorage.setItem(CACHE_PREFIX + routeNameInput.value, JSON.stringify(routeDataToSave));
            alert(`Ruta "${routeNameInput.value}" guardada.`);
            loadSavedRoutesLists();
        }

        function loadRoute() {
            setActiveMode(null);
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) { alert("Selecciona una ruta para cargar."); return; }
            const savedDataRaw = localStorage.getItem(CACHE_PREFIX + selectedRouteName);
            if (!savedDataRaw) { alert("Error al cargar la ruta."); return; }

            clearCurrentRoute();
            const loadedRouteData = JSON.parse(savedDataRaw);
            const loadedPointsData = loadedRouteData.points;
            routeSettings = loadedRouteData.settings || { totalTurns: 1 };

            document.getElementById('totalTurnsInput').value = routeSettings.totalTurns;

            loadedPointsData.forEach((p_data) => {
                const newPointBase = { ...p_data };
                if (p_data.pointCategory === 'lineEndpoint') {
                    newPointBase.turnSchedules = (p_data.turnSchedules || []).map(ts_data => ({
                         scheduledTime: ts_data.scheduledTime ? new Date(ts_data.scheduledTime) : null
                    }));
                    if (newPointBase.turnSchedules.length !== routeSettings.totalTurns) {
                        const adjustedSchedules = new Array(routeSettings.totalTurns);
                        for(let i=0; i < routeSettings.totalTurns; i++) {
                            adjustedSchedules[i] = newPointBase.turnSchedules[i] || { scheduledTime: null };
                        }
                        newPointBase.turnSchedules = adjustedSchedules;
                    }
                } else if (p_data.pointCategory === 'intermediateStop') {
                     newPointBase.scheduledTime = p_data.scheduledTime ? new Date(p_data.scheduledTime) : null;
                }
                routePoints.push({ ...newPointBase });
            });
            routePoints.sort((a,b) => a.originalIndex - b.originalIndex);

            routePoints.forEach(p => {
                 p.marker = L.marker([p.lat, p.lng], {
                    icon: createDivIcon(p.name, p.pointCategory, p.isStartPoint),
                    draggable: true
                }).addTo(map);
                 if (p.pointCategory !== 'waypoint') {
                    const circleColor = (p.pointCategory === 'lineEndpoint')
                        ? (p.isStartPoint ? '#FF8C00':'#DA70D6')
                        : '#2196F3';
                    p.radiusCircle = L.circle([p.lat, p.lng], {
                        radius: currentStopRadius, color: circleColor, weight: 1, opacity: 0.5,
                        fillColor: circleColor, fillOpacity: 0.2
                    }).addTo(map);
                    p.marker.on('click', function(ev) {L.DomEvent.stopPropagation(ev); if(isTracking)return; activateEditModeForPoint(p); });
                 } else {
                    p.marker.on('click', function(ev) {
                        L.DomEvent.stopPropagation(ev); if (isTracking) return;
                        if (activePointCreationMode === 'waypoint') {
                            if (confirm(`¿Borrar este punto de paso "${p.name}"?`)) {
                                map.removeLayer(p.marker);
                                routePoints = routePoints.filter(rp => rp.id !== p.id);
                                routePoints.forEach((rp, idx) => rp.originalIndex = idx);
                                redrawRouteLine();
                                if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                            }
                        } else alert("Para borrar Puntos de Paso, active el modo '+Pto. Paso'.");
                    });
                 }
                 p.marker.on('dragend', function(event){
                    if (isTracking) { event.target.setLatLng(L.latLng(p.lat, p.lng)); return; }
                    const pos = event.target.getLatLng(); p.lat = pos.lat; p.lng = pos.lng;
                    if (p.radiusCircle) p.radiusCircle.setLatLng(pos);
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                    updateStopsList();
                });
            });

            updateAllMarkerIconsAndLabels();
            updateWaypointMarkersVisibility(false);
            redrawRouteLine(); updateStopsList();
            const boundsPoints = routePoints.filter(p => p.pointCategory !== 'waypoint');
            if (boundsPoints.length > 0) {
                const bounds = L.latLngBounds(boundsPoints.map(p => [p.lat, p.lng]));
                if (bounds.isValid()) map.fitBounds(bounds);
            }
            document.getElementById('routeName').value = selectedRouteName;
            alert(`Ruta "${selectedRouteName}" cargada.`);
        }

        function deleteRoute() {
            setActiveMode(null);
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) { alert("Selecciona una ruta para borrar."); return; }
            if (confirm(`¿Estás seguro de que quieres borrar la ruta "${selectedRouteName}"?`)) {
                localStorage.removeItem(CACHE_PREFIX + selectedRouteName);
                let queue = getRouteQueue(); queue = queue.filter(name => name !== selectedRouteName);
                saveRouteQueue(queue); loadSavedRoutesLists();
                alert(`Ruta "${selectedRouteName}" borrada.`);
            }
        }

        function loadSavedRoutesLists() {
            const savedRoutesSelect = document.getElementById('savedRoutes');
            const routeToQueueSelect = document.getElementById('routeToQueue');
            const currentSavedRouteValue = savedRoutesSelect.value;
            const currentQueueRouteValue = routeToQueueSelect.value;
            savedRoutesSelect.innerHTML = ""; routeToQueueSelect.innerHTML = "";
            let hasRoutes = false; const routeNames = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(CACHE_PREFIX)) routeNames.push(key.substring(CACHE_PREFIX.length));
            }
            routeNames.sort();
            routeNames.forEach(routeName => {
                const option = document.createElement('option');
                option.value = routeName; option.textContent = routeName;
                savedRoutesSelect.appendChild(option.cloneNode(true));
                routeToQueueSelect.appendChild(option.cloneNode(true));
                hasRoutes = true;
            });
            if (!hasRoutes) {
                 const option = document.createElement('option');
                 option.textContent = "No hay rutas guardadas"; option.disabled = true;
                 savedRoutesSelect.appendChild(option.cloneNode(true)); routeToQueueSelect.appendChild(option);
            } else {
                if (routeNames.includes(currentSavedRouteValue)) savedRoutesSelect.value = currentSavedRouteValue;
                if (routeNames.includes(currentQueueRouteValue)) routeToQueueSelect.value = currentQueueRouteValue;
            }
            updateRouteQueueDisplay();
        }

        function getEndpointTimeForTurn(point, turnNumber) {
            if (!point || point.pointCategory !== 'lineEndpoint' || !point.turnSchedules ||
                turnNumber < 1 || turnNumber > point.turnSchedules.length || !point.turnSchedules[turnNumber - 1]) {
                return null;
            }
            const turnSchedule = point.turnSchedules[turnNumber - 1];
            return turnSchedule.scheduledTime ? new Date(turnSchedule.scheduledTime) : null;
        }


        function setupCurrentLegForTracking() {
            trackingState.activeLegPoints = [];
            const legPathPointsSource = getPathPointsForPolyline();
            if(legPathPointsSource.length === 0) { console.error("No points found for current leg in tracking."); return false; }

            const startPoint = routePoints.find(p => p.pointCategory === 'lineEndpoint' && p.isStartPoint);
            const endPoint = routePoints.find(p => p.pointCategory === 'lineEndpoint' && !p.isStartPoint);

            if (!startPoint || !endPoint) {
                alert("Punto de Inicio o Final no encontrado para la ruta.");
                return false;
            }

            const startTimeForCurrentTurn = getEndpointTimeForTurn(startPoint, trackingState.currentTurn);
            const endTimeForCurrentTurn = getEndpointTimeForTurn(endPoint, trackingState.currentTurn);

            if (!startTimeForCurrentTurn || !endTimeForCurrentTurn) {
                alert(`Horarios de Punto Inicio/Final incompletos para la vuelta ${trackingState.currentTurn}.`); return false;
            }

            trackingState.activeLegPoints = legPathPointsSource.map(legPoint => {
                const originalPoint = routePoints.find(rp => rp.id === legPoint.id);
                if (!originalPoint) return { ...legPoint, effectiveScheduledTime: null };

                let effTime = null;
                if (originalPoint.pointCategory === 'lineEndpoint') {
                    if (originalPoint.isStartPoint) effTime = startTimeForCurrentTurn;
                    else effTime = endTimeForCurrentTurn;
                } else if (originalPoint.pointCategory === 'intermediateStop') {
                    // For intermediate stops, we can use their base scheduled time (often from Turn 1 calc)
                    // or implement a more complex per-turn intermediate time calculation if needed.
                    // For now, use the globally set scheduledTime.
                    effTime = originalPoint.scheduledTime ? new Date(originalPoint.scheduledTime) : null;

                    // If a more dynamic intermediate time is needed based on current turn's start/end:
                    if (effTime && originalPoint.scheduledTime) { // If auto-calc was based on turn 1
                        const turn1StartTime = getEndpointTimeForTurn(startPoint, 1);
                        const turn1EndTime = getEndpointTimeForTurn(endPoint, 1);
                        if (turn1StartTime && turn1EndTime) {
                            const proportion = (originalPoint.scheduledTime.getTime() - turn1StartTime.getTime()) / (turn1EndTime.getTime() - turn1StartTime.getTime() || 1);
                            if (proportion >=0 && proportion <=1) {
                                effTime = new Date(startTimeForCurrentTurn.getTime() + proportion * (endTimeForCurrentTurn.getTime() - startTimeForCurrentTurn.getTime()));
                            }
                        }
                    }
                }
                return {
                    ...originalPoint,
                    effectiveScheduledTime: effTime
                };
            });

            // Check if the critical first and last points of the active leg have times
             if (trackingState.activeLegPoints.length > 0 &&
                (!trackingState.activeLegPoints[0].effectiveScheduledTime ||
                 !trackingState.activeLegPoints[trackingState.activeLegPoints.length -1].effectiveScheduledTime) ) {
                 alert(`Horarios incompletos para los extremos de la ruta (Vuelta ${trackingState.currentTurn}).`);
                 return false;
            }
            return true;
        }


        function startTracking() {
            setActiveMode(null);
            const startPoint = routePoints.find(p => p.pointCategory === 'lineEndpoint' && p.isStartPoint);
            const endPoint = routePoints.find(p => p.pointCategory === 'lineEndpoint' && !p.isStartPoint);
            if (!startPoint || !endPoint) { alert("La ruta debe tener un Punto de Inicio y un Punto Final."); return; }

            for (let i = 0; i < routeSettings.totalTurns; i++) {
                const turnNum = i + 1;
                const turnStartTime = getEndpointTimeForTurn(startPoint, turnNum);
                const turnEndTime = getEndpointTimeForTurn(endPoint, turnNum);
                if (!turnStartTime || !turnEndTime) {
                    alert(`Horarios incompletos para Punto Inicio/Final en Vuelta ${turnNum}. No se puede iniciar seguimiento.`); return;
                }
            }

            isTracking = true;
            trackingState.currentTurn = 1;

            if (!setupCurrentLegForTracking()) {
                stopTracking(false, "Error configurando ruta inicial.");
                return;
            }

            document.getElementById('startTrackingBtn').style.display = 'none';
            document.getElementById('stopTrackingBtn').style.display = 'inline-block';
            document.getElementById('routeCreationSection').style.display = 'none';
            updateTrackingStatusDisplay();
            redrawRouteLine();
            updateWaypointMarkersVisibility(false);

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    initialPosition => {
                        lastKnownPosition = initialPosition;
                        const { latitude, longitude } = initialPosition.coords;

                        if (userMarker) userMarker.setLatLng([latitude, longitude]);
                        else userMarker = L.marker([latitude, longitude], { icon: createUserLocationIcon() }).addTo(map);
                        map.setView([latitude, longitude], 16);

                        if (trackingState.activeLegPoints && trackingState.activeLegPoints.length > 0) {
                            let closestPointIndex = 0; let minDistance = Infinity;
                            trackingState.activeLegPoints.forEach((point, index) => {
                                const distance = L.latLng(latitude, longitude).distanceTo(L.latLng(point.lat, point.lng));
                                if (distance < minDistance) { minDistance = distance; closestPointIndex = index; }
                            });
                            currentSegmentStartIndex = closestPointIndex;
                        } else currentSegmentStartIndex = 0;

                        trackingIntervalId = navigator.geolocation.watchPosition(
                            handlePositionUpdate, handleGeolocationError,
                            { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 }
                        );
                        finalizeTrackingStart();
                    },
                    initialPositionError => {
                        console.warn("No se pudo obtener la posición inicial:", initialPositionError.message);
                        currentSegmentStartIndex = 0;
                        if (trackingState.activeLegPoints.length > 0 && trackingState.activeLegPoints[0]) {
                            map.setView([trackingState.activeLegPoints[0].lat, trackingState.activeLegPoints[0].lng], 16);
                        }
                        trackingIntervalId = navigator.geolocation.watchPosition(
                            handlePositionUpdate, handleGeolocationError,
                            { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 }
                        );
                        finalizeTrackingStart();
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
                );
            } else {
                alert("Geolocalización no disponible.");
                stopTracking(false, "Geolocalización no disponible");
            }
        }

        function finalizeTrackingStart() {
            if (!isTracking) return;
            if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition);
            else {
                 document.getElementById('timeDeviation').textContent = "Calculando...";
                 document.getElementById('timeDeviation').style.color = "#FFFFFF";
            }
            highlightNextStopInList();
            updateManualNavButtons();
        }

        function stopTracking(completedNaturally = false, reason = "") {
            if (trackingIntervalId) navigator.geolocation.clearWatch(trackingIntervalId);
            trackingIntervalId = null; isTracking = false; lastKnownPosition = null;
            document.getElementById('startTrackingBtn').style.display = 'inline-block';
            document.getElementById('stopTrackingBtn').style.display = 'none';
            document.getElementById('routeCreationSection').style.display = 'block';
            if (userMarker) { map.removeLayer(userMarker); userMarker = null; }

            redrawRouteLine();
            updateStopsList(); currentSegmentStartIndex = 0;
            updateManualNavButtons(); setActiveMode(null); updateWaypointMarkersVisibility(false);

            if (completedNaturally) {
                document.getElementById('trackingInfoDisplay').textContent = "RUTA COMPLETADA";
                alert("Ruta completada!"); checkRouteQueue();
            } else {
                const msg = "Seguimiento detenido." + (reason ? " Razón: " + reason : "");
                console.log(msg); if (reason && reason.startsWith("Error")) alert(msg);
                document.getElementById('trackingInfoDisplay').textContent = "SEGUIMIENTO DETENIDO";
            }
             document.getElementById('timeDeviation').textContent = "00:00";
             document.getElementById('timeDeviation').style.color = "#FFFFFF";
             document.getElementById('nextStopDisplay').textContent = "Próxima Parada: N/A";
        }

        function updateTrackingStatusDisplay() {
            if (!isTracking) { document.getElementById('statusDisplay').style.display = 'none'; return; }
            document.getElementById('statusDisplay').style.display = 'block';
            document.getElementById('trackingInfoDisplay').textContent =
                `Vuelta: ${trackingState.currentTurn}/${routeSettings.totalTurns}`;
        }

        function updateManualNavButtons() {
            const manualNav = document.getElementById('manualStopNav').checked;
            const prevBtn = document.getElementById('prevStopBtn'); const nextBtn = document.getElementById('nextStopBtn');
            if (isTracking && manualNav && trackingState.activeLegPoints && trackingState.activeLegPoints.length > 0) {
                prevBtn.style.display = 'inline-block'; nextBtn.style.display = 'inline-block';
                prevBtn.disabled = currentSegmentStartIndex === 0;
                nextBtn.disabled = currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1;
            } else { prevBtn.style.display = 'none'; nextBtn.style.display = 'none'; }
        }

        function handlePositionUpdate(position) {
            lastKnownPosition = position;
            const { latitude, longitude, speed } = position.coords;
            if (!userMarker) userMarker = L.marker([latitude, longitude], { icon: createUserLocationIcon() }).addTo(map);
            else userMarker.setLatLng([latitude, longitude]);
            document.getElementById('speedDisplay').textContent = `Velocidad: ${(speed ? (speed * 3.6) : 0).toFixed(1)} KM/H`;

            if (!isTracking || !trackingState.activeLegPoints || trackingState.activeLegPoints.length === 0) return;

            const manualNav = document.getElementById('manualStopNav').checked;

            if (!manualNav) {
                if (currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) {
                    handleEndOfLeg();
                    if (!isTracking) return;
                } else {
                    let nextRelevantTargetPoint = null;
                    let nextRelevantTargetIndex = -1;
                    for (let i = currentSegmentStartIndex + 1; i < trackingState.activeLegPoints.length; i++) {
                        if (trackingState.activeLegPoints[i].pointCategory !== 'waypoint') {
                            nextRelevantTargetPoint = trackingState.activeLegPoints[i];
                            nextRelevantTargetIndex = i;
                            break;
                        }
                    }
                    if (!nextRelevantTargetPoint) {
                        if (currentSegmentStartIndex < trackingState.activeLegPoints.length - 1) {
                           nextRelevantTargetPoint = trackingState.activeLegPoints[trackingState.activeLegPoints.length - 1];
                           nextRelevantTargetIndex = trackingState.activeLegPoints.length - 1;
                        }
                    }

                    if (nextRelevantTargetPoint) {
                        const distanceToTarget = L.latLng(latitude, longitude).distanceTo(L.latLng(nextRelevantTargetPoint.lat, nextRelevantTargetPoint.lng));
                        if (distanceToTarget < currentStopRadius) {
                            currentSegmentStartIndex = nextRelevantTargetIndex;
                            if (currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) {
                                handleEndOfLeg();
                                if (!isTracking) return;
                            }
                        }
                    }
                }
            }

            if (isTracking) {
                calculateTimeDeviation(position);
                highlightNextStopInList();
                updateManualNavButtons();
            }
        }

        function advanceToNextActivePoint() {
            if (currentSegmentStartIndex < trackingState.activeLegPoints.length - 1) {
                currentSegmentStartIndex++;
            }
            if (currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1 ) {
                handleEndOfLeg();
            }
        }

        function handleEndOfLeg() {
            if (!isTracking) return;
            trackingState.currentTurn++;
            if (trackingState.currentTurn > routeSettings.totalTurns) {
                stopTracking(true); // All turns completed
                return;
            }
            currentSegmentStartIndex = 0;
            if (!setupCurrentLegForTracking()) {
                stopTracking(false, `Error configurando Vuelta ${trackingState.currentTurn}.`);
                return;
            }
            updateTrackingStatusDisplay();
            redrawRouteLine();
            if (lastKnownPosition && trackingState.activeLegPoints && trackingState.activeLegPoints.length > 0) {
                 calculateTimeDeviation(lastKnownPosition);
            }
            highlightNextStopInList();
            updateManualNavButtons();
            if (trackingState.activeLegPoints.length > 0 && trackingState.activeLegPoints[0]) {
                map.setView([trackingState.activeLegPoints[0].lat, trackingState.activeLegPoints[0].lng], map.getZoom());
            }
        }

        function goToPreviousActivePoint() {
            if (!isTracking || currentSegmentStartIndex === 0) return;
            currentSegmentStartIndex--;
            if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition);
            highlightNextStopInList();
            updateManualNavButtons();
        }

        function goToNextActivePoint() {
            if (!isTracking || !trackingState.activeLegPoints || currentSegmentStartIndex >= trackingState.activeLegPoints.length -1 ) return;
            advanceToNextActivePoint();
            if (isTracking) {
                 if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition);
                 highlightNextStopInList();
                 updateManualNavButtons();
            }
        }

        function highlightNextStopInList() {
            document.querySelectorAll('#stopsList .stop-item').forEach(item => item.classList.remove('next-stop-highlight'));
            let nextStopName = "N/A";

            if (isTracking && trackingState.activeLegPoints && trackingState.activeLegPoints.length > 0) {
                let displayableNextTarget = null;
                for (let i = currentSegmentStartIndex + 1; i < trackingState.activeLegPoints.length; i++) {
                    if (trackingState.activeLegPoints[i].pointCategory !== 'waypoint') {
                        displayableNextTarget = trackingState.activeLegPoints[i];
                        break;
                    }
                }
                 if (!displayableNextTarget && currentSegmentStartIndex < trackingState.activeLegPoints.length -1 ) {
                    displayableNextTarget = trackingState.activeLegPoints[trackingState.activeLegPoints.length -1];
                }

                if (displayableNextTarget) {
                    nextStopName = displayableNextTarget.name;
                    const listPoints = getSortedRoutePointsForDisplay();
                    const displayIndexInList = listPoints.findIndex(dp => dp.id === displayableNextTarget.id);
                    if (displayIndexInList !== -1 && document.querySelectorAll('#stopsList .stop-item')[displayIndexInList]) {
                        document.querySelectorAll('#stopsList .stop-item')[displayIndexInList].classList.add('next-stop-highlight');
                    }
                } else if (currentSegmentStartIndex >= trackingState.activeLegPoints.length -1 ) {
                     nextStopName = "Fin de Ruta";
                } else {
                     nextStopName = "Fin de Ruta";
                }
            } else if (!isTracking) {
                const displayPoints = getSortedRoutePointsForDisplay();
                if (displayPoints.length > 0 && displayPoints[0].pointCategory !== 'waypoint') {
                     nextStopName = displayPoints[0].name;
                } else if (displayPoints.length > 0) {
                     nextStopName = displayPoints[0].name + " (Paso)";
                }
            }
            document.getElementById('nextStopDisplay').textContent = `Próxima: ${nextStopName}`;
        }

        function calculateTimeDeviation(currentUserGeoPosition) {
            if (!isTracking || !trackingState.activeLegPoints || trackingState.activeLegPoints.length === 0 || !currentUserGeoPosition) {
                document.getElementById('timeDeviation').textContent = "---";
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                return;
            }

            const currentTime = new Date().getTime();
            const legPoints = trackingState.activeLegPoints;
            let pointA = null, pointALegIndex = -1, pointB = null;

            for (let i = currentSegmentStartIndex; i >= 0; i--) {
                if (legPoints[i].pointCategory !== 'waypoint' && legPoints[i].effectiveScheduledTime) {
                    pointA = legPoints[i]; pointALegIndex = i; break;
                }
            }
            if (!pointA && legPoints[0].effectiveScheduledTime) { pointA = legPoints[0]; pointALegIndex = 0; }

            for (let i = currentSegmentStartIndex + 1; i < legPoints.length; i++) {
                if (legPoints[i].pointCategory !== 'waypoint' && legPoints[i].effectiveScheduledTime) {
                    pointB = legPoints[i]; break;
                }
            }
            if (!pointB && legPoints[legPoints.length - 1].effectiveScheduledTime) {
                if (!pointA || pointA.id !== legPoints[legPoints.length - 1].id) {
                     pointB = legPoints[legPoints.length - 1];
                }
            }

            if (pointALegIndex === 0 && currentSegmentStartIndex === 0 && pointA && pointA.effectiveScheduledTime) {
                const legStartTime = new Date(pointA.effectiveScheduledTime).getTime();
                if (currentTime < legStartTime) { displayDeviation(legStartTime - currentTime); return; }
            }

            if (!pointA || !pointB) {
                if (pointA && pointA.effectiveScheduledTime) {
                    displayDeviation(new Date(pointA.effectiveScheduledTime).getTime() - currentTime);
                } else {
                    document.getElementById('timeDeviation').textContent = "---";
                    document.getElementById('timeDeviation').style.color = "#FFFFFF";
                }
                return;
            }

            if (pointA.id === pointB.id) {
                displayDeviation(new Date(pointA.effectiveScheduledTime).getTime() - currentTime); return;
            }

            const timeA = new Date(pointA.effectiveScheduledTime).getTime();
            const timeB = new Date(pointB.effectiveScheduledTime).getTime();
            const segmentTotalScheduledMillis = timeB - timeA;

            if (segmentTotalScheduledMillis < 0) { displayDeviation(timeB - currentTime); return; }
            if (segmentTotalScheduledMillis === 0) { displayDeviation(timeA - currentTime); return; }

            const latLngA = L.latLng(pointA.lat, pointA.lng);
            const latLngB = L.latLng(pointB.lat, pointB.lng);
            const currentUserLatLng = L.latLng(currentUserGeoPosition.coords.latitude, currentUserGeoPosition.coords.longitude);
            const distanceTotalSegment = latLngA.distanceTo(latLngB);
            let progressPercentage;

            if (distanceTotalSegment < 1.0) { progressPercentage = 0.0; }
            else {
                const distUserToA = currentUserLatLng.distanceTo(latLngA);
                const distUserToB = currentUserLatLng.distanceTo(latLngB);
                let distanceAlongSegmentUser = (Math.pow(distanceTotalSegment, 2) + Math.pow(distUserToA, 2) - Math.pow(distUserToB, 2)) / (2 * distanceTotalSegment);
                distanceAlongSegmentUser = Math.max(0, Math.min(distanceAlongSegmentUser, distanceTotalSegment));
                progressPercentage = distanceAlongSegmentUser / distanceTotalSegment;
            }

            const expectedTimeAtCurrentPosition = timeA + (segmentTotalScheduledMillis * progressPercentage);
            displayDeviation(expectedTimeAtCurrentPosition - currentTime);
        }


        function displayDeviation(deviationMillis) {
            const absMillis = Math.abs(deviationMillis);
            const totalSecondsValue = Math.floor(absMillis / 1000);
            const displaySeconds = totalSecondsValue % 60;
            const totalMinutesValue = Math.floor(totalSecondsValue / 60);
            const sign = deviationMillis >= 0 ? "+" : "-";
            const formattedDeviation = `${sign}${String(totalMinutesValue).padStart(2, '0')}:${String(displaySeconds).padStart(2, '0')}`;
            const deviationDiv = document.getElementById('timeDeviation');
            deviationDiv.textContent = formattedDeviation;

            if (deviationMillis > 59999) deviationDiv.style.color = "#00FF00";
            else if (deviationMillis < -59999) deviationDiv.style.color = "#FF0000";
            else deviationDiv.style.color = "#FFFFFF";
        }
        function handleGeolocationError(error) {
            console.error("Error de geolocalización: ", error);
            alert(`Error de geolocalización: ${error.message}.`);
            if (isTracking) stopTracking(false, "Error de geolocalización");
        }

        function getRouteQueue() { const q = localStorage.getItem(ROUTE_QUEUE_CACHE_KEY); return q ? JSON.parse(q) : [];}
        function saveRouteQueue(queue) { localStorage.setItem(ROUTE_QUEUE_CACHE_KEY, JSON.stringify(queue)); updateRouteQueueDisplay();}
        function addRouteToQueue() {
            const selectedRouteName = document.getElementById('routeToQueue').value;
            if (!selectedRouteName || document.getElementById('routeToQueue').options[0]?.disabled) {
                alert("Selecciona una ruta válida para añadir."); return;
            }
            const queue = getRouteQueue(); if (queue.includes(selectedRouteName)) { alert("Ruta ya en cola."); return; }
            queue.push(selectedRouteName); saveRouteQueue(queue); alert(`Ruta "${selectedRouteName}" añadida.`);
        }
        function updateRouteQueueDisplay() {
            const queueDiv = document.getElementById('routeQueueDisplay'); const queue = getRouteQueue();
            if (queue.length === 0) { queueDiv.innerHTML = "Vacía."; }
            else { let html = "<ol style='padding-left: 20px; margin-top: 5px;'>"; queue.forEach(rn => { html += `<li>${rn}</li>`; }); html += "</ol>"; queueDiv.innerHTML = html; }
        }
        function clearRouteQueue() { if (confirm("¿Limpiar toda la cola?")) saveRouteQueue([]);}

        function checkRouteQueue() {
            let queue = getRouteQueue();
            if (queue.length > 0) {
                const nextRouteName = queue.shift(); saveRouteQueue(queue);
                if (confirm(`Ruta finalizada. ¿Iniciar siguiente ruta de la cola: "${nextRouteName}"?`)) {
                    const savedRoutesSelect = document.getElementById('savedRoutes');
                    let routeExists = Array.from(savedRoutesSelect.options).some(opt => opt.value === nextRouteName);
                    if (routeExists) {
                        savedRoutesSelect.value = nextRouteName; loadRoute();
                        setTimeout(() => {
                            const startPoint = routePoints.find(p => p.pointCategory === 'lineEndpoint' && p.isStartPoint);
                            const endPoint = routePoints.find(p => p.pointCategory === 'lineEndpoint' && !p.isStartPoint);
                            let canStart = startPoint && endPoint;
                            if (canStart) {
                                for (let i = 0; i < routeSettings.totalTurns; i++) {
                                    const turnNum = i + 1;
                                    if (!getEndpointTimeForTurn(startPoint,turnNum) || !getEndpointTimeForTurn(endPoint, turnNum)) {
                                        canStart = false; break;
                                    }
                                }
                            }
                            if (canStart) startTracking();
                            else alert(`Error al cargar la ruta "${nextRouteName}" de la cola o sus horarios son inválidos.`);
                        }, 500);
                    } else alert(`La ruta "${nextRouteName}" de la cola ya no existe.`);
                } else alert("Siguiente ruta de la cola no iniciada.");
            }
        }

        function updateGlobalStopRadiusSettings() {
            const newRadius = parseInt(document.getElementById('stopRadiusInput').value, 10);
            if (!isNaN(newRadius) && newRadius >= 10 && newRadius <= 500) {
                currentStopRadius = newRadius;
                routePoints.forEach(point => { if (point.radiusCircle) point.radiusCircle.setRadius(currentStopRadius); });
            } else {
                alert("Radio inválido (10-500m)."); document.getElementById('stopRadiusInput').value = currentStopRadius;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initMap(); loadSavedRoutesLists(); updateStopsList();
            updateManualNavButtons(); setActiveMode(null); updateTrackingStatusDisplay();
        });
    </script>
</body>
</html>
