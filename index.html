<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            overflow: hidden; /* Prevent body scroll */
            display: flex;
            flex-direction: column;
        }

        #map {
            height: 50vh; /* 50% of viewport height */
            width: 100%;
            background-color: #333; /* Placeholder color */
        }

        #controls {
            height: 50vh; /* 50% of viewport height */
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .control-section:last-child {
            border-bottom: none;
        }

        h2, h3, h4 {
            color: #FFFFFF;
            margin-top: 0;
            margin-bottom: 8px;
        }
        h3 { font-size: 1.1em; }
        h4 { font-size: 1em; margin-top: 10px;}


        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="text"], input[type="datetime-local"], input[type="number"], select {
            width: calc(100% - 12px);
            padding: 8px;
            margin-bottom: 10px;
            background-color: #222;
            color: #FFF;
            border: 1px solid #555;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        button:hover {
            background-color: #45a049;
        }
        button.danger {
            background-color: #f44336;
        }
        button.danger:hover {
            background-color: #da190b;
        }
        button.secondary {
            background-color: #007bff;
        }
        button.secondary:hover {
            background-color: #0056b3;
        }
        button.info {
            background-color: #17a2b8;
        }
        button.info:hover {
            background-color: #117a8b;
        }
        button.active-mode-button {
            background-color: #ff9800; /* Orange to show it's active */
            color: black;
            font-weight: bold;
        }
        button.active-mode-button:hover {
            background-color: #e68a00;
        }


        #statusDisplay {
            text-align: center;
            padding: 10px;
        }
        #timeDeviation {
            font-size: 3em; /* Larger font for time deviation */
            font-weight: bold;
            margin: 10px 0;
        }
        #trackingInfoDisplay, #speedDisplay, #nextStopDisplay {
            font-size: 1.2em;
            margin: 5px 0;
        }

        .stop-item {
            background-color: #1e1e1e;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
            cursor: pointer;
        }
        .stop-item:hover {
            background-color: #2f2f2f;
        }
        .stop-item.next-stop-highlight {
            background-color: #007bff;
            font-weight: bold;
        }
        .stop-item.line-endpoint-highlight {
            border-left: 3px solid #ffc107; /* Yellow border for line endpoints */
        }


        .leaflet-div-icon {
            background: transparent;
            border: none;
            text-align: center;
            font-weight: bold;
            color: white;
        }
        .waypoint-marker-icon { 
            background-color:#888888 !important; 
            width: 10px !important; 
            height: 10px !important; 
            border-radius: 50% !important; 
            border: 1px solid #FFFFFF !important; 
            box-sizing: border-box !important;
        }


        .user-location-icon {
            background-color: #007bff !important; /* Blue dot */
            border-radius: 50%;
            width: 16px !important;
            height: 16px !important;
            border: 2px solid white;
            box-shadow: 0 0 0 2px #007bff;
        }
        #lineEndpointTurnSchedulesContainer .turn-schedule-group {
            border-bottom: 1px dashed #444;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        #lineEndpointTurnSchedulesContainer .turn-schedule-group:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>

    <div id="map"></div>
    <div id="controls">
        <div id="statusDisplay" style="display: none;">
            <div id="trackingInfoDisplay">Vuelta: 1/1 - Bandera: IDA</div>
            <div id="timeDeviation">00:00</div>
            <div id="speedDisplay">Velocidad: 0 KM/H</div>
            <div id="nextStopDisplay">Próxima Parada: N/A</div>
        </div>

        <div class="control-section" id="routeCreationSection">
            <h3>Crear/Modificar Ruta</h3>
            <p style="font-size: 0.8em;">
                Utiliza los botones de modo para gestionar la ruta. Para añadir puntos (Paso, Parada, Punta de Línea), activa el modo correspondiente y luego toca el mapa.
                Para editar un punto existente, tócalo directamente en el mapa. El modo "Editar Horarios" prioriza la edición de tiempos al seleccionar un punto.
                Usa "Vista Trazado" para cambiar entre la visualización de la bandera IDA (azul) y VUELTA (roja).
            </p>
            <div id="editModeSelection" style="margin-bottom:10px; display: flex; flex-wrap: wrap;">
                <button onclick="setActiveMode('flagConfig')" id="modeFlagConfigBtn" class="secondary" style="margin-right:5px; margin-bottom:5px;">Editar Bandera</button>
                <button onclick="setActiveMode('waypoint')" id="modeWaypointBtn" class="info" style="margin-right:5px; margin-bottom:5px;">+Pto. Paso</button>
                <button onclick="setActiveMode('intermediateStop')" id="modeIntermediateStopBtn" class="info" style="margin-right:5px; margin-bottom:5px;">+Parada Inter.</button>
                <button onclick="setActiveMode('lineEndpoint')" id="modeLineEndpointBtn" class="info" style="margin-right:5px; margin-bottom:5px;">+Punta Línea</button>
                <button onclick="setActiveMode('schedule')" id="modeScheduleBtn" class="secondary" style="margin-right:5px; margin-bottom:5px;">Editar Horarios</button>
                <button onclick="toggleEditingFlagView()" id="toggleEditingFlagViewBtn" class="secondary" style="margin-right:5px; margin-bottom:5px;">Vista Trazado: IDA</button>
                <button onclick="setActiveMode(null)" id="modeCancelBtn" class="danger" style="display:none; margin-bottom:5px;">X Cancelar Modo</button>
            </div>
            <p id="activeModeStatus" style="font-size: 0.8em; color: #17a2b8; margin-top:0; min-height: 1.2em;"></p>
            
            <label for="pointName">Nombre Punto:</label>
            <input type="text" id="pointName" placeholder="Ej: Terminal Norte">
            
            <div id="lineEndpointTurnSchedulesContainer" style="display:none; max-height: 200px; overflow-y: auto; border: 1px solid #555; padding: 10px; margin-bottom:10px; background-color: #1a1a1a;">
                <!-- Horarios por vuelta para Puntas de Línea se generan aquí por JS -->
            </div>
             <small id="lineEndpointScheduleHelperText" style="font-size: 0.7em; display: none; margin-bottom: 10px; color: #ccc;">
                <b>P1 (Primera Punta de Línea):</b> Para cada vuelta, la "Salida" es el inicio de la bandera IDA y la "Llegada" es el fin de la bandera VUELTA.<br>
                <b>P2 (Segunda Punta de Línea):</b> Para cada vuelta, la "Llegada" es el fin de la bandera IDA y la "Salida" es el inicio de la bandera VUELTA.
            </small>

            <div id="intermediateStopTime" style="display:none;">
                <label for="pointScheduledTimeIntermediateIDA">Horario Programado (Parada Intermedia en IDA):</label>
                <input type="datetime-local" id="pointScheduledTimeIntermediateIDA">
                <label for="pointScheduledTimeIntermediateVUELTA">Horario Programado (Parada Intermedia en VUELTA):</label>
                <input type="datetime-local" id="pointScheduledTimeIntermediateVUELTA">
                <small style="font-size: 0.7em; display: block; margin-bottom: 5px; color: #ccc;">
                    Estos horarios para paradas intermedias se pueden calcular automáticamente usando la opción "Calcular horarios intermedios" (basado en la Vuelta 1 de las Puntas de Línea).
                </small>
            </div>

            <div id="editPointControls" style="display:none; margin-top:10px;">
                <button onclick="updateSelectedPoint()" class="secondary">Actualizar Punto</button>
                <button onclick="deleteSelectedPoint()" class="danger">Borrar Punto Seleccionado</button>
                <button onclick="cancelEdit()">Cancelar Edición</button>
            </div>
            <hr style="margin: 15px 0;">
            <input type="checkbox" id="autoCalcTimes" checked onchange="calculateAndApplyAllIntermediateTimes()">
            <label for="autoCalcTimes" style="display:inline;">Calcular horarios intermedios automáticamente (basado en horarios de Vuelta 1 de Puntas de Línea)</label>
            <br><br>
            <button onclick="clearCurrentRoute()">Limpiar Ruta Actual</button>
        </div>
        
        <div class="control-section" id="routeSettingsSection">
            <h3>Configuración de Vueltas y Banderas</h3>
            <label for="totalTurnsInput">Cantidad de Vueltas (ciclos completos IDA-VUELTA):</label>
            <input type="number" id="totalTurnsInput" value="1" min="1" onchange="updateRouteSettings()">
            <label for="flagNameIdaInput">Nombre Bandera IDA:</label>
            <input type="text" id="flagNameIdaInput" value="IDA" onchange="updateRouteSettings()">
            <label for="flagNameVueltaInput">Nombre Bandera VUELTA:</label>
            <input type="text" id="flagNameVueltaInput" value="VUELTA" onchange="updateRouteSettings()">
        </div>

        <div class="control-section">
            <h3>Configuración de Visualización</h3>
            <label for="stopRadiusInput">Radio de Paradas/Puntas (metros):</label>
            <input type="number" id="stopRadiusInput" value="50" min="10" max="500" onchange="updateGlobalStopRadiusSettings()">
        </div>

        <div class="control-section">
            <h3>Lista de Puntos (Paradas y Puntas de Línea)</h3>
            <div id="stopsList">No hay puntos definidos.</div>
        </div>
        
        <div class="control-section">
            <h3>Guardar/Cargar Rutas</h3>
            <label for="routeName">Nombre para Guardar Ruta:</label>
            <input type="text" id="routeName" placeholder="Ej: Ruta Mañana Lunes">
            <button onclick="saveRoute()">Guardar Ruta</button>
            <br><br>
            <label for="savedRoutes">Cargar Ruta:</label>
            <select id="savedRoutes"></select>
            <button onclick="loadRoute()">Cargar</button>
            <button onclick="deleteRoute()" class="danger">Borrar Seleccionada</button>
        </div>

        <div class="control-section">
            <h3>Seguimiento</h3>
            <button id="startTrackingBtn" onclick="startTracking()">Iniciar Seguimiento</button>
            <button id="stopTrackingBtn" onclick="stopTracking()" class="danger" style="display:none;">Detener Seguimiento</button>
            <br>
            <input type="checkbox" id="manualStopNav" onchange="updateManualNavButtons()">
            <label for="manualStopNav" style="display:inline;">Navegación Manual de Puntos</label>
            <button id="prevStopBtn" onclick="goToPreviousActivePoint()" style="display:none;">Anterior</button>
            <button id="nextStopBtn" onclick="goToNextActivePoint()" style="display:none;">Siguiente</button>
        </div>
        
        <div class="control-section">
            <h3>Cola de Rutas</h3>
            <label for="routeToQueue">Añadir ruta guardada a la cola:</label>
            <select id="routeToQueue"></select>
            <button onclick="addRouteToQueue()">Añadir a Cola</button>
            <h4>En Cola:</h4>
            <div id="routeQueueDisplay">Vacía.</div>
            <button onclick="clearRouteQueue()">Limpiar Cola</button>
        </div>

    </div>

    <script>
        'use strict';
        let map;
        let routePoints = []; 
        let routeLine;
        let userMarker;
        let trackingIntervalId;
        let isTracking = false;
        let currentSegmentStartIndex = 0; 
        let lastKnownPosition = null;
        let currentlyEditingPoint = null; 
        let currentStopRadius = 50; 
        
        let activePointCreationMode = null; // null | 'waypoint' | 'intermediateStop' | 'lineEndpoint'
        let timeEditingPriority = false; // true if 'schedule' mode is active

        const CACHE_PREFIX = 'smartMovePro_route_';
        const ROUTE_QUEUE_CACHE_KEY = 'smartMovePro_routeQueue';

        let routeSettings = {
            totalTurns: 1,
            flagNameIda: "IDA",
            flagNameVuelta: "VUELTA"
        };
        
        let currentEditingFlagView = routeSettings.flagNameIda; // For route creation polyline view

        let trackingState = {
            currentTurn: 1,
            currentFlag: routeSettings.flagNameIda, 
            activeLegPoints: [], 
        };
        
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }
        
        function createDivIcon(text, pointCategory = '', isFirstEndpoint = false) {
            let htmlContent = '';
            let iconSize = [30,30]; 
            let iconAnchor = [15,15]; 
            let className = 'leaflet-div-icon';

            if (pointCategory === 'waypoint') {
                className += ' waypoint-marker-icon'; 
                iconSize = [12,12]; 
                iconAnchor = [6,6];
            } else if (pointCategory === 'lineEndpoint') {
                const bgColor = isFirstEndpoint ? '#FF8C00' : '#DA70D6'; 
                const P_char = text ? text.substring(0,1).toUpperCase() : (isFirstEndpoint ? 'P1' : 'P2');
                htmlContent = `<div style="background-color:${bgColor}; width: 28px; height:28px; display:flex; justify-content:center; align-items:center; border-radius: 50%; color: white; font-size:14px; font-weight:bold; border: 2px solid white;">${P_char}</div>`;
                iconSize = [32,32]; 
                iconAnchor = [16,16];
            } else { // intermediateStop
                const bgColor = '#2196F3'; 
                const displayText = text || '?';
                htmlContent = `<div style="background-color:${bgColor}; padding: 5px 8px; border-radius: 5px; color: white; font-size:12px; font-weight:bold; border: 1px solid white; min-width: 15px; text-align: center;">${displayText}</div>`;
                iconSize = [displayText.length > 1 ? 35 : 30, 30]; 
                iconAnchor = [iconSize[0]/2, 15];
            }
            
            return L.divIcon({
                className: className,
                html: htmlContent,
                iconSize: iconSize, 
                iconAnchor: iconAnchor
            });
        }
        
        function createUserLocationIcon() {
            return L.divIcon({
                className: 'user-location-icon',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        function initMap() {
            map = L.map('map').setView([-34.6037, -58.3816], 13); 
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            map.on('click', onMapClick);
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    map.setView([position.coords.latitude, position.coords.longitude], 13);
                });
            }
            document.getElementById('stopRadiusInput').value = currentStopRadius;
            updateRouteSettings(); 
        }

        function setActiveMode(modeName) {
            const modeButtons = {
                flagConfig: document.getElementById('modeFlagConfigBtn'),
                waypoint: document.getElementById('modeWaypointBtn'),
                intermediateStop: document.getElementById('modeIntermediateStopBtn'),
                lineEndpoint: document.getElementById('modeLineEndpointBtn'),
                schedule: document.getElementById('modeScheduleBtn')
            };
            const statusP = document.getElementById('activeModeStatus');
            const cancelBtn = document.getElementById('modeCancelBtn');

            activePointCreationMode = null;
            timeEditingPriority = false;
            Object.values(modeButtons).forEach(btn => { 
                if(btn) btn.classList.remove('active-mode-button');
            });
            cancelEdit(); 

            if (modeName === null) { 
                statusP.textContent = "Selecciona un modo o toca un punto existente para editar.";
                statusP.style.color = '#FFFFFF'; 
                cancelBtn.style.display = 'none';
                updateWaypointMarkersVisibility(false); 
                return;
            }

            if(modeButtons[modeName]) modeButtons[modeName].classList.add('active-mode-button');
            cancelBtn.style.display = 'inline-block';
            statusP.style.color = '#17a2b8';

            switch (modeName) {
                case 'flagConfig':
                    statusP.textContent = "Modo Edición de Bandera: Configure vueltas y nombres de bandera en su sección.";
                    document.getElementById('routeSettingsSection')?.scrollIntoView({ behavior: 'smooth' });
                    updateWaypointMarkersVisibility(false);
                    break;
                case 'waypoint':
                    activePointCreationMode = 'waypoint';
                    statusP.textContent = "Modo 'Añadir Punto de Paso' ACTIVO. Toca el mapa para añadir. Toca un punto de paso existente para borrarlo.";
                    updateWaypointMarkersVisibility(true);
                    break;
                case 'intermediateStop':
                    activePointCreationMode = 'intermediateStop';
                    statusP.textContent = "Modo 'Añadir Parada Intermedia' ACTIVO. Toca el mapa para añadir.";
                    updateWaypointMarkersVisibility(false);
                    break;
                case 'lineEndpoint':
                    activePointCreationMode = 'lineEndpoint';
                    statusP.textContent = "Modo 'Añadir Punta de Línea' ACTIVO. Toca el mapa para añadir (máx. 2).";
                    updateWaypointMarkersVisibility(false);
                    break;
                case 'schedule':
                    timeEditingPriority = true;
                    statusP.textContent = "Modo 'Editar Horarios' ACTIVO. Toca una parada o punta de línea para editar sus horarios.";
                    updateWaypointMarkersVisibility(false);
                    break;
            }
        }
        
        function updateWaypointMarkersVisibility(showWaypointsOverride = null) {
            const show = showWaypointsOverride !== null ? showWaypointsOverride : (activePointCreationMode === 'waypoint');
            routePoints.forEach(p => {
                if (p.pointCategory === 'waypoint' && p.marker) {
                    if (show) {
                        if (!map.hasLayer(p.marker)) map.addLayer(p.marker);
                    } else {
                        if (map.hasLayer(p.marker)) map.removeLayer(p.marker);
                    }
                }
            });
        }

        function toggleEditingFlagView() {
            const btn = document.getElementById('toggleEditingFlagViewBtn');
            if (currentEditingFlagView === routeSettings.flagNameIda) {
                currentEditingFlagView = routeSettings.flagNameVuelta;
            } else {
                currentEditingFlagView = routeSettings.flagNameIda;
            }
            btn.textContent = `Vista Trazado: ${currentEditingFlagView}`;
            redrawRouteLine();
        }
        
        function updateRouteSettings() {
            const oldIdaName = routeSettings.flagNameIda;
            const oldVueltaName = routeSettings.flagNameVuelta;
            const oldTotalTurns = routeSettings.totalTurns;
        
            routeSettings.totalTurns = parseInt(document.getElementById('totalTurnsInput').value) || 1;
            routeSettings.flagNameIda = document.getElementById('flagNameIdaInput').value || "IDA";
            routeSettings.flagNameVuelta = document.getElementById('flagNameVueltaInput').value || "VUELTA";
        
            if (currentEditingFlagView === oldIdaName) {
                currentEditingFlagView = routeSettings.flagNameIda;
            } else if (currentEditingFlagView === oldVueltaName) {
                currentEditingFlagView = routeSettings.flagNameVuelta;
            } else { 
                currentEditingFlagView = routeSettings.flagNameIda;
            }
        
            const btn = document.getElementById('toggleEditingFlagViewBtn');
            if (btn) { 
                btn.textContent = `Vista Trazado: ${currentEditingFlagView}`;
            }
            
            if (oldTotalTurns !== routeSettings.totalTurns) {
                routePoints.forEach(p => {
                    if (p.pointCategory === 'lineEndpoint') {
                        if (!p.turnSchedules) p.turnSchedules = [];
                        const newSchedules = new Array(routeSettings.totalTurns);
                        for (let i = 0; i < routeSettings.totalTurns; i++) {
                            const existing = p.turnSchedules[i] || {};
                            newSchedules[i] = {
                                scheduledDeparture: existing.scheduledDeparture || null,
                                scheduledArrival: existing.scheduledArrival || null
                            };
                        }
                        p.turnSchedules = newSchedules;
                    }
                });
                // If a line endpoint is currently being edited, refresh its schedule UI
                if (currentlyEditingPoint && currentlyEditingPoint.pointCategory === 'lineEndpoint') {
                    activateEditModeForPoint(currentlyEditingPoint); 
                }
            }

            if (!isTracking) {
                trackingState.currentFlag = routeSettings.flagNameIda;
            }
            redrawRouteLine(); 
            updateTrackingStatusDisplay();
        }

        function formatDateTimeForInput(date) {
            if (!date || isNaN(new Date(date).getTime())) return "";
            const d = new Date(date);
            d.setMinutes(d.getMinutes() - d.getTimezoneOffset());
            return d.toISOString().slice(0, 16);
        }

        function activateEditModeForPoint(point) {
            if (isTracking) { return; }
            if (point.pointCategory === 'waypoint') {
                 if (activePointCreationMode === 'waypoint') {
                    // Deletion is handled by waypoint's own click listener when in waypoint mode
                 } else {
                    alert("Para interactuar con Puntos de Paso, active el modo '+Pto. Paso'.");
                 }
                return;
            }
            
            if (activePointCreationMode !== null && activePointCreationMode !== 'schedule') {
                setActiveMode(null); 
            } else if (activePointCreationMode !== 'schedule') { // if it's null, and not schedule mode
                 cancelEdit();
            }


            currentlyEditingPoint = point;
            document.getElementById('pointName').value = point.name;
            document.getElementById('pointName').readOnly = timeEditingPriority;
            
            document.getElementById('lineEndpointTurnSchedulesContainer').style.display = 'none';
            document.getElementById('lineEndpointScheduleHelperText').style.display = 'none';
            document.getElementById('intermediateStopTime').style.display = 'none';

            if (point.pointCategory === 'lineEndpoint') {
                const container = document.getElementById('lineEndpointTurnSchedulesContainer');
                container.innerHTML = ''; // Clear previous
                container.style.display = 'block';
                document.getElementById('lineEndpointScheduleHelperText').style.display = 'block';

                const totalTurns = routeSettings.totalTurns;
                // Ensure turnSchedules array is initialized and of correct length
                if (!point.turnSchedules || point.turnSchedules.length !== totalTurns) {
                    const newSchedules = new Array(totalTurns);
                    for (let i = 0; i < totalTurns; i++) {
                        const existing = (point.turnSchedules && point.turnSchedules[i]) ? point.turnSchedules[i] : {};
                        newSchedules[i] = {
                            scheduledDeparture: existing.scheduledDeparture || null,
                            scheduledArrival: existing.scheduledArrival || null
                        };
                    }
                    point.turnSchedules = newSchedules;
                }

                for (let i = 0; i < totalTurns; i++) {
                    const turnNum = i + 1;
                    const turnSchedule = point.turnSchedules[i];

                    const turnDiv = document.createElement('div');
                    turnDiv.className = 'turn-schedule-group';
                    turnDiv.innerHTML = `<h4>Vuelta ${turnNum}</h4>`;

                    let label1Text, input1Id, value1;
                    let label2Text, input2Id, value2;

                    if (point.isFirstEndpoint) { // P1
                        label1Text = "Salida Programada (Inicio IDA):";
                        input1Id = `endpoint_turn_${turnNum}_time1`; // P1 Departure
                        value1 = turnSchedule.scheduledDeparture;

                        label2Text = "Llegada Programada (Fin VUELTA):";
                        input2Id = `endpoint_turn_${turnNum}_time2`; // P1 Arrival
                        value2 = turnSchedule.scheduledArrival;
                    } else { // P2
                        label1Text = "Llegada Programada (Fin IDA):";
                        input1Id = `endpoint_turn_${turnNum}_time1`; // P2 Arrival
                        value1 = turnSchedule.scheduledArrival;

                        label2Text = "Salida Programada (Inicio VUELTA):";
                        input2Id = `endpoint_turn_${turnNum}_time2`; // P2 Departure
                        value2 = turnSchedule.scheduledDeparture;
                    }

                    turnDiv.innerHTML += `
                        <label for="${input1Id}">${label1Text}</label>
                        <input type="datetime-local" id="${input1Id}" value="${formatDateTimeForInput(value1)}">
                        <label for="${input2Id}">${label2Text}</label>
                        <input type="datetime-local" id="${input2Id}" value="${formatDateTimeForInput(value2)}">
                    `;
                    container.appendChild(turnDiv);
                }
                if(timeEditingPriority && document.getElementById(`endpoint_turn_1_time1`)) {
                    document.getElementById(`endpoint_turn_1_time1`).focus();
                }

            } else if (point.pointCategory === 'intermediateStop') {
                document.getElementById('intermediateStopTime').style.display = 'block';
                document.getElementById('pointScheduledTimeIntermediateIDA').value = formatDateTimeForInput(point.times.scheduledIDA);
                document.getElementById('pointScheduledTimeIntermediateVUELTA').value = formatDateTimeForInput(point.times.scheduledVUELTA);
                 if(timeEditingPriority) document.getElementById('pointScheduledTimeIntermediateIDA').focus();
            }
            
            document.getElementById('editPointControls').style.display = 'block';
            if (!timeEditingPriority) document.getElementById('pointName').focus();
        }

        function cancelEdit() {
            currentlyEditingPoint = null;
            document.getElementById('pointName').value = "";
            document.getElementById('pointName').readOnly = false;

            document.getElementById('lineEndpointTurnSchedulesContainer').style.display = 'none';
            document.getElementById('lineEndpointTurnSchedulesContainer').innerHTML = '';
            document.getElementById('lineEndpointScheduleHelperText').style.display = 'none';
            
            document.getElementById('pointScheduledTimeIntermediateIDA').value = "";
            document.getElementById('pointScheduledTimeIntermediateVUELTA').value = "";
            document.getElementById('intermediateStopTime').style.display = 'none';
            
            document.getElementById('editPointControls').style.display = 'none';
        }

        function updateSelectedPoint() {
            if (!currentlyEditingPoint || currentlyEditingPoint.pointCategory === 'waypoint') return;

            if (!timeEditingPriority) { 
                const newName = document.getElementById('pointName').value.trim();
                if (!newName) { alert("El nombre del punto no puede estar vacío."); return; }
                currentlyEditingPoint.name = newName;
            }

            if (currentlyEditingPoint.pointCategory === 'lineEndpoint') {
                const totalTurns = routeSettings.totalTurns;
                currentlyEditingPoint.turnSchedules = []; 

                for (let i = 0; i < totalTurns; i++) {
                    const turnNum = i + 1;
                    const time1Value = document.getElementById(`endpoint_turn_${turnNum}_time1`).value;
                    const time2Value = document.getElementById(`endpoint_turn_${turnNum}_time2`).value;
                    
                    let date1 = time1Value ? new Date(time1Value) : null;
                    let date2 = time2Value ? new Date(time2Value) : null;

                    if ((time1Value && isNaN(date1.getTime())) || (time2Value && isNaN(date2.getTime()))) {
                        alert(`Formato de fecha/hora inválido para Punta de Línea, Vuelta ${turnNum}.`); return;
                    }
                    
                    if (currentlyEditingPoint.isFirstEndpoint) { // P1
                        currentlyEditingPoint.turnSchedules.push({ scheduledDeparture: date1, scheduledArrival: date2 });
                    } else { // P2
                        currentlyEditingPoint.turnSchedules.push({ scheduledArrival: date1, scheduledDeparture: date2 });
                    }
                }
            } else if (currentlyEditingPoint.pointCategory === 'intermediateStop') {
                const idaTimeValue = document.getElementById('pointScheduledTimeIntermediateIDA').value;
                const vueltaTimeValue = document.getElementById('pointScheduledTimeIntermediateVUELTA').value;

                currentlyEditingPoint.times.scheduledIDA = idaTimeValue ? new Date(idaTimeValue) : null;
                if (idaTimeValue && isNaN(currentlyEditingPoint.times.scheduledIDA.getTime())) {
                     alert("Formato de fecha/hora inválido para Parada Intermedia (IDA).");
                     currentlyEditingPoint.times.scheduledIDA = null; return;
                }
                currentlyEditingPoint.times.scheduledVUELTA = vueltaTimeValue ? new Date(vueltaTimeValue) : null;
                if (vueltaTimeValue && isNaN(currentlyEditingPoint.times.scheduledVUELTA.getTime())) {
                     alert("Formato de fecha/hora inválido para Parada Intermedia (VUELTA).");
                     currentlyEditingPoint.times.scheduledVUELTA = null; return;
                }
            }
            
            if (document.getElementById('autoCalcTimes').checked) {
                calculateAndApplyAllIntermediateTimes();
            }
            updateAllMarkerIconsAndLabels(); 
            redrawRouteLine();
            updateStopsList();
            alert(`Punto "${currentlyEditingPoint.name}" actualizado.`);
            cancelEdit(); 
        }

        function deleteSelectedPoint() {
            if (!currentlyEditingPoint || currentlyEditingPoint.pointCategory === 'waypoint') return;
        
            if (confirm(`¿Seguro que quieres borrar el punto "${currentlyEditingPoint.name}"?`)) {
                map.removeLayer(currentlyEditingPoint.marker);
                if (currentlyEditingPoint.radiusCircle) map.removeLayer(currentlyEditingPoint.radiusCircle);
                
                const originalPointCategory = currentlyEditingPoint.pointCategory;
                const pointNameToDelete = currentlyEditingPoint.name; 
                routePoints = routePoints.filter(p => p.id !== currentlyEditingPoint.id);
                
                if (originalPointCategory === 'lineEndpoint') {
                    const remainingLineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
                    if (remainingLineEndpoints.length > 0) {
                         remainingLineEndpoints.sort((a,b) => a.originalIndex - b.originalIndex);
                         remainingLineEndpoints[0].isFirstEndpoint = true;
                         if(remainingLineEndpoints.length > 1) remainingLineEndpoints[1].isFirstEndpoint = false;
                    }
                }
        
                if (document.getElementById('autoCalcTimes').checked) {
                    calculateAndApplyAllIntermediateTimes();
                }
                updateAllMarkerIconsAndLabels();
                redrawRouteLine();
                updateStopsList();
                alert(`Punto "${pointNameToDelete}" borrado.`);
            }
            cancelEdit(); 
        }
        
        function updateAllMarkerIconsAndLabels() {
            const displayOrderedPoints = getSortedRoutePointsForDisplay(); 

            routePoints.forEach(p => { 
                if (p.marker) {
                    let text = '';
                    if (p.pointCategory === 'lineEndpoint') {
                        text = p.name; 
                    } else if (p.pointCategory === 'intermediateStop') {
                        const intermediateStopsOnly = displayOrderedPoints.filter(dp => dp.pointCategory === 'intermediateStop');
                        const displayIdx = intermediateStopsOnly.findIndex(dp => dp.id === p.id);
                        text = (displayIdx !== -1) ? String(displayIdx + 1) : '?';
                    }
                    p.marker.setIcon(createDivIcon(text, p.pointCategory, p.isFirstEndpoint));
                }
            });
        }

        function onMapClick(e) {
            if (isTracking) { alert("Detén el seguimiento para modificar la ruta."); return; }
            
            let targetIsMarkerIcon = e.originalEvent.target.closest && e.originalEvent.target.closest('.leaflet-marker-icon');
            
            if (currentlyEditingPoint && !targetIsMarkerIcon) {
                cancelEdit();
            }
            if (targetIsMarkerIcon) return; 

            const latlng = e.latlng;
            const pointId = generateUniqueId();
            
            if (activePointCreationMode) {
                document.getElementById('pointName').value = ""; 
                let newPointData = {
                    id: pointId, lat: latlng.lat, lng: latlng.lng,
                    originalIndex: routePoints.length, 
                };

                switch (activePointCreationMode) {
                    case 'waypoint':
                        const waypoint = {
                            id: pointId, lat: latlng.lat, lng: latlng.lng, 
                            name: `Paso ${routePoints.filter(p => p.pointCategory === 'waypoint').length + 1}`,
                            pointCategory: 'waypoint',
                            marker: L.marker(latlng, { icon: createDivIcon(null, 'waypoint'), draggable: true }),
                            radiusCircle: null, originalIndex: routePoints.length 
                        };
                        if (map.hasLayer(waypoint.marker)) map.removeLayer(waypoint.marker);
                        map.addLayer(waypoint.marker);

                        waypoint.marker.on('dragend', function(event) {
                            if (isTracking) { event.target.setLatLng(L.latLng(waypoint.lat, waypoint.lng)); return; }
                            const pos = event.target.getLatLng(); waypoint.lat = pos.lat; waypoint.lng = pos.lng;
                            redrawRouteLine();
                            if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                        });
                        waypoint.marker.on('click', function(ev) {
                            L.DomEvent.stopPropagation(ev); if (isTracking) return;
                            if (activePointCreationMode === 'waypoint') { 
                                if (confirm(`¿Borrar este punto de paso "${waypoint.name}"?`)) {
                                    map.removeLayer(waypoint.marker);
                                    routePoints = routePoints.filter(p => p.id !== waypoint.id);
                                    redrawRouteLine();
                                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                                }
                            } else {
                                alert("Para borrar Puntos de Paso, active el modo '+Pto. Paso'.");
                            }
                        });
                        routePoints.push(waypoint);
                        routePoints.sort((a,b) => a.originalIndex - b.originalIndex); 
                        routePoints.forEach((p, idx) => p.originalIndex = idx);

                        if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes(); 
                        redrawRouteLine();
                        return; 

                    case 'intermediateStop':
                        newPointData.name = `Parada ${routePoints.filter(p => p.pointCategory === 'intermediateStop').length + 1}`;
                        newPointData.pointCategory = 'intermediateStop';
                        newPointData.times = { scheduledIDA: null, scheduledVUELTA: null };
                        break;

                    case 'lineEndpoint':
                        const currentLineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
                        if (currentLineEndpoints.length >= 2) {
                            alert("Ya existen dos Puntas de Línea. No se pueden añadir más.");
                            return;
                        }
                        const isFirstEp = (currentLineEndpoints.length === 0);
                        newPointData.name = isFirstEp ? "Punta de Línea 1" : "Punta de Línea 2";
                        newPointData.pointCategory = 'lineEndpoint';
                        newPointData.isFirstEndpoint = isFirstEp;
                        newPointData.turnSchedules = new Array(routeSettings.totalTurns).fill(null).map(() => ({
                            scheduledDeparture: null, scheduledArrival: null
                        }));
                        break;
                    default: return; 
                }
                
                const newPoint = { ...newPointData };
                routePoints.push(newPoint);
                routePoints.sort((a,b) => a.originalIndex - b.originalIndex); 
                routePoints.forEach((p, idx) => p.originalIndex = idx);

                newPoint.marker = L.marker(latlng, { 
                    icon: createDivIcon(newPoint.name, newPoint.pointCategory, newPoint.isFirstEndpoint), draggable: true 
                }).addTo(map);
                newPoint.radiusCircle = L.circle(latlng, {
                    radius: currentStopRadius, 
                    color: (newPoint.pointCategory === 'lineEndpoint' ? (newPoint.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'), 
                    weight: 1, opacity: 0.5, 
                    fillColor: (newPoint.pointCategory === 'lineEndpoint' ? (newPoint.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'), fillOpacity: 0.2
                }).addTo(map);

                newPoint.marker.on('dragend', function(event) {
                    if (isTracking) {event.target.setLatLng(L.latLng(newPoint.lat, newPoint.lng)); return; }
                    const pos = event.target.getLatLng(); newPoint.lat = pos.lat; newPoint.lng = pos.lng;
                    if (newPoint.radiusCircle) newPoint.radiusCircle.setLatLng(pos);
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                    updateStopsList(); 
                });
                newPoint.marker.on('click', function(ev) { L.DomEvent.stopPropagation(ev); if (isTracking) return; activateEditModeForPoint(newPoint); });
                
                updateAllMarkerIconsAndLabels();
                if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                redrawRouteLine();
                updateStopsList();
            } else if (timeEditingPriority) {
                // In 'schedule' mode, map click itself does nothing unless it's on a marker.
            }
        }
        
        function getPathPointsForPolyline(flagNameToUse) {
            const allPointsSorted = [...routePoints].sort((a, b) => a.originalIndex - b.originalIndex);
            if (allPointsSorted.length < 1) return []; 

            const lineEndpoints = allPointsSorted.filter(p => p.pointCategory === 'lineEndpoint');

            if (lineEndpoints.length < 2) {
                return allPointsSorted;
            }

            const p1 = lineEndpoints.find(p => p.isFirstEndpoint);
            const p2 = lineEndpoints.find(p => !p.isFirstEndpoint);

            if (!p1 || !p2) { 
                return allPointsSorted;
            }

            const p1ActualIndexInSortedArray = allPointsSorted.findIndex(p => p.id === p1.id);
            const p2ActualIndexInSortedArray = allPointsSorted.findIndex(p => p.id === p2.id);

            if (flagNameToUse === routeSettings.flagNameIda) {
                if (p1ActualIndexInSortedArray < p2ActualIndexInSortedArray) {
                    return allPointsSorted.slice(p1ActualIndexInSortedArray, p2ActualIndexInSortedArray + 1);
                } else { 
                    return [
                        ...allPointsSorted.slice(p1ActualIndexInSortedArray), 
                        ...allPointsSorted.slice(0, p2ActualIndexInSortedArray + 1)
                    ];
                }
            } else { // VUELTA
                if (p2ActualIndexInSortedArray < p1ActualIndexInSortedArray) {
                    return allPointsSorted.slice(p2ActualIndexInSortedArray, p1ActualIndexInSortedArray + 1);
                } else { 
                    return [
                        ...allPointsSorted.slice(p2ActualIndexInSortedArray), 
                        ...allPointsSorted.slice(0, p1ActualIndexInSortedArray + 1)
                    ];
                }
            }
        }


        function calculateAndApplyAllIntermediateTimes() {
            const autoCalc = document.getElementById('autoCalcTimes').checked;
            if (!autoCalc) { 
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => {
                    stop.times.scheduledIDA = null;
                    stop.times.scheduledVUELTA = null;
                });
                updateStopsList(); return; 
            }

            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint').sort((a,b)=>a.originalIndex - b.originalIndex);
            if (lineEndpoints.length < 2) { updateStopsList(); return; }
            
            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);
            if (!p1 || !p2) { updateStopsList(); return; }

            // Use Turn 1 schedules for calculating intermediate stop times
            if (!p1.turnSchedules || p1.turnSchedules.length === 0 || !p2.turnSchedules || p2.turnSchedules.length === 0) {
                console.warn("Turn schedules for P1 or P2 are not initialized for auto-calculation.");
                updateStopsList(); return;
            }
            const p1Turn1Schedule = p1.turnSchedules[0];
            const p2Turn1Schedule = p2.turnSchedules[0];


            const allPointsSorted = [...routePoints].sort((a, b) => a.originalIndex - b.originalIndex);
            const p1ActualIndex = allPointsSorted.findIndex(p => p.id === p1.id);
            const p2ActualIndex = allPointsSorted.findIndex(p => p.id === p2.id);

            // IDA leg times calculation (based on Turn 1 of P1/P2)
            if (p1Turn1Schedule.scheduledDeparture && p2Turn1Schedule.scheduledArrival) {
                let idaLegPath;
                if (p1ActualIndex < p2ActualIndex) {
                    idaLegPath = allPointsSorted.slice(p1ActualIndex, p2ActualIndex + 1);
                } else { // Wrap around
                    idaLegPath = [...allPointsSorted.slice(p1ActualIndex), ...allPointsSorted.slice(0, p2ActualIndex + 1)];
                }
                distributeTimesProportionally(idaLegPath, new Date(p1Turn1Schedule.scheduledDeparture), new Date(p2Turn1Schedule.scheduledArrival), 'scheduledIDA');
            } else {
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => stop.times.scheduledIDA = null);
            }

            // VUELTA leg times calculation (based on Turn 1 of P1/P2)
            if (p2Turn1Schedule.scheduledDeparture && p1Turn1Schedule.scheduledArrival) {
                let vueltaLegPath;
                 if (p2ActualIndex < p1ActualIndex) {
                    vueltaLegPath = allPointsSorted.slice(p2ActualIndex, p1ActualIndex + 1);
                } else { // Wrap around
                    vueltaLegPath = [...allPointsSorted.slice(p2ActualIndex), ...allPointsSorted.slice(0, p1ActualIndex + 1)];
                }
                distributeTimesProportionally(vueltaLegPath, new Date(p2Turn1Schedule.scheduledDeparture), new Date(p1Turn1Schedule.scheduledArrival), 'scheduledVUELTA');
            } else {
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => stop.times.scheduledVUELTA = null);
            }
            updateStopsList();
        }

        function distributeTimesProportionally(legPathPoints, legStartTimeDate, legEndTimeDate, timeKey) {
            if (!legStartTimeDate || !legEndTimeDate || legPathPoints.length < 2) return;
            
            const legStartMillis = legStartTimeDate.getTime();
            const legEndMillis = legEndTimeDate.getTime();
            const totalDurationMillis = legEndMillis - legStartMillis;

            const intermediateStopsInLeg = legPathPoints.slice(1, -1).filter(p => p.pointCategory === 'intermediateStop');
            if (totalDurationMillis <= 0) { // Includes same start/end time
                intermediateStopsInLeg.forEach(p_leg => {
                    const pointInMainRoute = routePoints.find(rp => rp.id === p_leg.id);
                    if(pointInMainRoute) {
                        // If duration is zero, set intermediate times to be same as leg start time
                        pointInMainRoute.times[timeKey] = new Date(legStartMillis); 
                    }
                });
                return;
            }


            let totalDistance = 0;
            const segmentDistances = [];
            for (let i = 0; i < legPathPoints.length - 1; i++) {
                const dist = L.latLng(legPathPoints[i].lat, legPathPoints[i].lng)
                               .distanceTo(L.latLng(legPathPoints[i+1].lat, legPathPoints[i+1].lng));
                segmentDistances.push(dist);
                totalDistance += dist;
            }

            if (totalDistance < 1.0) { 
                const numTimeSegments = intermediateStopsInLeg.length + 1;
                if (numTimeSegments <= 0) return;
                const timePerSegment = totalDurationMillis / numTimeSegments;
                let currentTime = legStartMillis;
                legPathPoints.slice(1, -1).forEach(p_leg => { 
                    if (p_leg.pointCategory === 'intermediateStop') {
                       currentTime += timePerSegment; 
                       const pointInMainRoute = routePoints.find(rp => rp.id === p_leg.id);
                       if(pointInMainRoute) pointInMainRoute.times[timeKey] = new Date(currentTime);
                    }
                });
            } else {
                let accumulatedDistance = 0;
                for (let i = 0; i < legPathPoints.length - 1; i++) {
                    accumulatedDistance += segmentDistances[i];
                    const nextPointInPath = legPathPoints[i+1];
                    if (nextPointInPath.pointCategory === 'intermediateStop') {
                        const proportionOfRoute = accumulatedDistance / totalDistance;
                        const timeOffsetMillis = totalDurationMillis * proportionOfRoute;
                        const pointInMainRoute = routePoints.find(rp => rp.id === nextPointInPath.id);
                        if(pointInMainRoute) pointInMainRoute.times[timeKey] = new Date(legStartMillis + timeOffsetMillis);
                    }
                }
            }
        }
        
        function clearCurrentRoute() {
            setActiveMode(null); 
            routePoints.forEach(p => {
                if (p.marker) map.removeLayer(p.marker);
                if (p.radiusCircle) map.removeLayer(p.radiusCircle);
            });
            routePoints = [];
            if (routeLine) map.removeLayer(routeLine); routeLine = null;
            document.getElementById('pointName').value = "";
            currentEditingFlagView = routeSettings.flagNameIda;
            const editFlagBtn = document.getElementById('toggleEditingFlagViewBtn');
            if(editFlagBtn) editFlagBtn.textContent = `Vista Trazado: ${routeSettings.flagNameIda}`;

            updateStopsList(); updateAllMarkerIconsAndLabels(); 
            redrawRouteLine(); 
        }

        function redrawRouteLine() {
            if (routeLine) map.removeLayer(routeLine); routeLine = null;
            
            const flagForPolyline = isTracking ? trackingState.currentFlag : currentEditingFlagView;
            const polylinePathPoints = getPathPointsForPolyline(flagForPolyline); 
            
            if (polylinePathPoints.length > 1) {
                const latlngs = polylinePathPoints.map(p => [p.lat, p.lng]);
                const color = (flagForPolyline === routeSettings.flagNameIda) ? 'blue' : 'red';
                routeLine = L.polyline(latlngs, {color: color, weight: 5}).addTo(map);
            }
        }
        
        function getSortedRoutePointsForDisplay() { 
            return [...routePoints].sort((a, b) => a.originalIndex - b.originalIndex)
                                  .filter(p => p.pointCategory !== 'waypoint'); 
        }

        function formatTime(dateObj, includeDate = true) { 
            if (!dateObj || isNaN(new Date(dateObj).getTime())) return "N/A";
            let timeStr = new Date(dateObj).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            if (includeDate) {
                 timeStr += ` (${new Date(dateObj).toLocaleDateString('es-ES', {day:'2-digit', month:'2-digit'})})`;
            }
            return timeStr;
        }
        
        function updateStopsList() {
            const listDiv = document.getElementById('stopsList');
            const displayPoints = getSortedRoutePointsForDisplay(); 

            if (displayPoints.length === 0) { listDiv.innerHTML = "No hay puntos definidos."; return; }

            let html = "<ul style='padding-left: 10px; list-style: none;'>";
            let intermediateVisualCounter = 1; 
            let overallCounter = 1;
            displayPoints.forEach((p) => { 
                let typeText = "", timeStr = "N/A";
                let itemClass = "stop-item";
                let prefix = `${overallCounter++}. `;


                if (p.pointCategory === 'lineEndpoint') {
                    itemClass += " line-endpoint-highlight";
                    typeText = p.isFirstEndpoint ? "P1" : "P2";
                    if (p.turnSchedules && p.turnSchedules.length > 0) {
                        const turn1Schedule = p.turnSchedules[0];
                        let depTime, arrTime;
                        if (p.isFirstEndpoint) {
                            depTime = turn1Schedule.scheduledDeparture; // P1 IDA departure
                            arrTime = turn1Schedule.scheduledArrival;   // P1 VUELTA arrival
                        } else {
                            arrTime = turn1Schedule.scheduledArrival;   // P2 IDA arrival
                            depTime = turn1Schedule.scheduledDeparture; // P2 VUELTA departure
                        }
                        timeStr = `Sal (V1): ${formatTime(depTime, false)} / Lleg (V1): ${formatTime(arrTime, false)}`;
                        if (depTime) timeStr += ` (${new Date(depTime).toLocaleDateString('es-ES',{day:'2-digit',month:'2-digit'})})`;
                        else if(arrTime) timeStr += ` (${new Date(arrTime).toLocaleDateString('es-ES',{day:'2-digit',month:'2-digit'})})`;
                    } else {
                        timeStr = "Horarios no definidos";
                    }
                } else if (p.pointCategory === 'intermediateStop') {
                    typeText = `Inter. ${intermediateVisualCounter++}`;
                    timeStr = `IDA: ${formatTime(p.times.scheduledIDA, false)} / VTA: ${formatTime(p.times.scheduledVUELTA, false)}`;
                    if (p.times.scheduledIDA) timeStr += ` (${new Date(p.times.scheduledIDA).toLocaleDateString('es-ES',{day:'2-digit',month:'2-digit'})})`;
                    else if (p.times.scheduledVUELTA) timeStr += ` (${new Date(p.times.scheduledVUELTA).toLocaleDateString('es-ES',{day:'2-digit',month:'2-digit'})})`;
                }
                html += `<li class="${itemClass}" onclick="focusPointOnMap('${p.id}')">${prefix}<b>${p.name}</b> (${typeText}) - ${timeStr}</li>`;
            });
            html += "</ul>";
            listDiv.innerHTML = html;
            highlightNextStopInList(); 
        }

        function focusPointOnMap(pointId) {
            const point = routePoints.find(p => p.id === pointId);
            if (point && map) {
                map.setView([point.lat, point.lng], Math.max(map.getZoom(), 16));
            }
        }

        function saveRoute() {
            setActiveMode(null); 
            const routeNameInput = document.getElementById('routeName');
            if (!routeNameInput.value) { alert("Por favor, ingresa un nombre para la ruta."); return; }
            
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
            if (lineEndpoints.length < 2) {
                 alert("Una ruta debe tener dos Puntas de Línea definidas (P1 y P2)."); return;
            }
            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);

            if (!p1 || !p2) {
                alert("P1 y/o P2 no están correctamente identificados. Revisa la configuración de las puntas de línea."); return;
            }

            let allEndpointTimesSet = true;
            for (let i = 0; i < routeSettings.totalTurns; i++) {
                if (!p1.turnSchedules || !p1.turnSchedules[i] || !p1.turnSchedules[i].scheduledDeparture || !p1.turnSchedules[i].scheduledArrival) {
                    allEndpointTimesSet = false; break;
                }
                if (!p2.turnSchedules || !p2.turnSchedules[i] || !p2.turnSchedules[i].scheduledArrival || !p2.turnSchedules[i].scheduledDeparture) {
                    allEndpointTimesSet = false; break;
                }
            }
            if (!allEndpointTimesSet) {
                alert("Ambas Puntas de Línea (P1 y P2) deben tener sus horarios de salida y llegada definidos para CADA VUELTA.");
                return;
            }

            const savablePoints = routePoints.map(p => {
                const pointData = { 
                    id: p.id, lat: p.lat, lng: p.lng, name: p.name, 
                    pointCategory: p.pointCategory,
                    originalIndex: p.originalIndex,
                };
                if (p.pointCategory === 'lineEndpoint') {
                    pointData.isFirstEndpoint = p.isFirstEndpoint;
                    pointData.turnSchedules = (p.turnSchedules || []).map(ts => ({
                        scheduledDeparture: ts.scheduledDeparture ? new Date(ts.scheduledDeparture).toISOString() : null,
                        scheduledArrival: ts.scheduledArrival ? new Date(ts.scheduledArrival).toISOString() : null
                    }));
                } else if (p.pointCategory === 'intermediateStop') {
                    pointData.times = {
                        scheduledIDA: p.times.scheduledIDA ? new Date(p.times.scheduledIDA).toISOString() : null,
                        scheduledVUELTA: p.times.scheduledVUELTA ? new Date(p.times.scheduledVUELTA).toISOString() : null
                    };
                }
                return pointData;
            });
            
            const routeDataToSave = { points: savablePoints, settings: routeSettings };
            localStorage.setItem(CACHE_PREFIX + routeNameInput.value, JSON.stringify(routeDataToSave));
            alert(`Ruta "${routeNameInput.value}" guardada.`);
            loadSavedRoutesLists();
        }

        function loadRoute() {
            setActiveMode(null); 
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) { alert("Selecciona una ruta para cargar."); return; }
            const savedDataRaw = localStorage.getItem(CACHE_PREFIX + selectedRouteName);
            if (!savedDataRaw) { alert("Error al cargar la ruta."); return; }

            clearCurrentRoute(); 
            const loadedRouteData = JSON.parse(savedDataRaw);
            const loadedPointsData = loadedRouteData.points;
            routeSettings = loadedRouteData.settings || { totalTurns: 1, flagNameIda: "IDA", flagNameVuelta: "VUELTA"};
            
            document.getElementById('totalTurnsInput').value = routeSettings.totalTurns;
            document.getElementById('flagNameIdaInput').value = routeSettings.flagNameIda;
            document.getElementById('flagNameVueltaInput').value = routeSettings.flagNameVuelta;
            currentEditingFlagView = routeSettings.flagNameIda;
            const editFlagBtn = document.getElementById('toggleEditingFlagViewBtn');
            if (editFlagBtn) editFlagBtn.textContent = `Vista Trazado: ${routeSettings.flagNameIda}`;
            trackingState.currentFlag = routeSettings.flagNameIda;


            loadedPointsData.forEach((p_data) => {
                const newPointBase = { ...p_data }; 
                delete newPointBase.times; // Remove old times structure if present from very old saves
                delete newPointBase.turnSchedules; // Remove this before re-assigning

                if (p_data.pointCategory === 'lineEndpoint') {
                    newPointBase.isFirstEndpoint = p_data.isFirstEndpoint; 
                    newPointBase.turnSchedules = (p_data.turnSchedules || []).map(ts_data => ({
                         scheduledDeparture: ts_data.scheduledDeparture ? new Date(ts_data.scheduledDeparture) : null,
                         scheduledArrival: ts_data.scheduledArrival ? new Date(ts_data.scheduledArrival) : null
                    }));
                    // Ensure turnSchedules length matches current routeSettings.totalTurns
                    if (newPointBase.turnSchedules.length !== routeSettings.totalTurns) {
                        const adjustedSchedules = new Array(routeSettings.totalTurns);
                        for(let i=0; i < routeSettings.totalTurns; i++) {
                            adjustedSchedules[i] = newPointBase.turnSchedules[i] || { scheduledDeparture: null, scheduledArrival: null };
                        }
                        newPointBase.turnSchedules = adjustedSchedules;
                    }

                } else if (p_data.pointCategory === 'intermediateStop') {
                     newPointBase.times = {
                        scheduledIDA: p_data.times && p_data.times.scheduledIDA ? new Date(p_data.times.scheduledIDA) : null,
                        scheduledVUELTA: p_data.times && p_data.times.scheduledVUELTA ? new Date(p_data.times.scheduledVUELTA) : null
                     };
                } else if (p_data.pointCategory === 'waypoint') {
                    // Waypoints don't have special time structures here
                }


                const newPoint = { ...newPointBase }; 
                routePoints.push(newPoint);
            });
            routePoints.sort((a,b) => a.originalIndex - b.originalIndex);

            routePoints.forEach(p => {
                 p.marker = L.marker([p.lat, p.lng], { 
                    icon: createDivIcon(p.name, p.pointCategory, p.isFirstEndpoint), 
                    draggable: true 
                }).addTo(map);
                 if (p.pointCategory !== 'waypoint') {
                    p.radiusCircle = L.circle([p.lat, p.lng], {
                        radius: currentStopRadius, 
                        color: (p.pointCategory === 'lineEndpoint' ? (p.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'), 
                        weight: 1, opacity: 0.5, 
                        fillColor: (p.pointCategory === 'lineEndpoint' ? (p.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'), fillOpacity: 0.2
                    }).addTo(map);
                    p.marker.on('click', function(ev) {L.DomEvent.stopPropagation(ev); if(isTracking)return; activateEditModeForPoint(p); });
                 } else { 
                    p.marker.on('click', function(ev) {
                        L.DomEvent.stopPropagation(ev); if (isTracking) return;
                        if (activePointCreationMode === 'waypoint') { 
                            if (confirm(`¿Borrar este punto de paso "${p.name}"?`)) {
                                map.removeLayer(p.marker);
                                routePoints = routePoints.filter(rp => rp.id !== p.id);
                                routePoints.forEach((rp, idx) => rp.originalIndex = idx); 
                                redrawRouteLine();
                                if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                            }
                        } else {
                             alert("Para borrar Puntos de Paso, active el modo '+Pto. Paso'.");
                        }
                    });
                 }
                 p.marker.on('dragend', function(event){
                    if (isTracking) { event.target.setLatLng(L.latLng(p.lat, p.lng)); return; }
                    const pos = event.target.getLatLng(); p.lat = pos.lat; p.lng = pos.lng;
                    if (p.radiusCircle) p.radiusCircle.setLatLng(pos);
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                    updateStopsList();
                });
            });
            
            updateAllMarkerIconsAndLabels(); 
            updateWaypointMarkersVisibility(false); 
            redrawRouteLine();
            updateStopsList();

            const boundsPoints = routePoints; 
            if (boundsPoints.length > 0) {
                const bounds = L.latLngBounds(boundsPoints.map(p => [p.lat, p.lng]));
                if (bounds.isValid()) map.fitBounds(bounds);
            }
            document.getElementById('routeName').value = selectedRouteName;
            alert(`Ruta "${selectedRouteName}" cargada.`);
        }

        function deleteRoute() {
            setActiveMode(null);
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) { alert("Selecciona una ruta para borrar."); return; }
            if (confirm(`¿Estás seguro de que quieres borrar la ruta "${selectedRouteName}"?`)) {
                localStorage.removeItem(CACHE_PREFIX + selectedRouteName);
                let queue = getRouteQueue();
                queue = queue.filter(name => name !== selectedRouteName);
                saveRouteQueue(queue);
                loadSavedRoutesLists(); 
                alert(`Ruta "${selectedRouteName}" borrada.`);
            }
        }

        function loadSavedRoutesLists() { 
            const savedRoutesSelect = document.getElementById('savedRoutes');
            const routeToQueueSelect = document.getElementById('routeToQueue');
            const currentSavedRouteValue = savedRoutesSelect.value;
            const currentQueueRouteValue = routeToQueueSelect.value;

            savedRoutesSelect.innerHTML = ""; routeToQueueSelect.innerHTML = "";
            let hasRoutes = false;
            const routeNames = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(CACHE_PREFIX)) routeNames.push(key.substring(CACHE_PREFIX.length));
            }
            routeNames.sort(); 
            routeNames.forEach(routeName => {
                const option = document.createElement('option');
                option.value = routeName; option.textContent = routeName;
                savedRoutesSelect.appendChild(option.cloneNode(true));
                routeToQueueSelect.appendChild(option.cloneNode(true));
                hasRoutes = true;
            });
            if (!hasRoutes) {
                 const option = document.createElement('option');
                 option.textContent = "No hay rutas guardadas"; option.disabled = true;
                 savedRoutesSelect.appendChild(option.cloneNode(true));
                 routeToQueueSelect.appendChild(option);
            } else {
                if (routeNames.includes(currentSavedRouteValue)) savedRoutesSelect.value = currentSavedRouteValue;
                if (routeNames.includes(currentQueueRouteValue)) routeToQueueSelect.value = currentQueueRouteValue;
            }
            updateRouteQueueDisplay();
        }
        
        function getEndpointTimesForTurn(point, turnNumber) { // turnNumber is 1-based
            if (!point || point.pointCategory !== 'lineEndpoint' || !point.turnSchedules || 
                turnNumber < 1 || turnNumber > point.turnSchedules.length || !point.turnSchedules[turnNumber - 1]) {
                return { departureIDA: null, arrivalIDA: null, departureVUELTA: null, arrivalVUELTA: null };
            }
            const turnSchedule = point.turnSchedules[turnNumber - 1];
            if (point.isFirstEndpoint) { // P1
                return {
                    departureIDA: turnSchedule.scheduledDeparture, 
                    arrivalVUELTA: turnSchedule.scheduledArrival,
                    arrivalIDA: null, // P1 doesn't have IDA arrival in this context
                    departureVUELTA: null // P1 doesn't have VUELTA departure in this context
                };
            } else { // P2
                return {
                    arrivalIDA: turnSchedule.scheduledArrival,     
                    departureVUELTA: turnSchedule.scheduledDeparture,
                    departureIDA: null, // P2 doesn't have IDA departure
                    arrivalVUELTA: null // P2 doesn't have VUELTA arrival
                };
            }
        }


        function setupCurrentLegForTracking() {
            trackingState.activeLegPoints = [];
            const legPathPointsSource = getPathPointsForPolyline(trackingState.currentFlag); // These are from routePoints
            if(legPathPointsSource.length === 0) {
                console.error("No points found for current leg in tracking.");
                return false;
            }

            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);

            if (!p1 || !p2 || !p1.turnSchedules || !p2.turnSchedules || 
                trackingState.currentTurn > p1.turnSchedules.length || 
                trackingState.currentTurn > p2.turnSchedules.length ) {
                alert(`Horarios de Puntas de Línea incompletos para la vuelta ${trackingState.currentTurn}.`);
                return false;
            }

            const p1TimesForCurrentTurn = getEndpointTimesForTurn(p1, trackingState.currentTurn);
            const p2TimesForCurrentTurn = getEndpointTimesForTurn(p2, trackingState.currentTurn);
            
            trackingState.activeLegPoints = legPathPointsSource.map(legPoint => {
                const originalPoint = routePoints.find(rp => rp.id === legPoint.id); // Should always find it
                if (!originalPoint) return { ...legPoint, effectiveScheduledTime: null }; 

                let effTime = null;
                if (originalPoint.pointCategory === 'lineEndpoint') {
                    if (trackingState.currentFlag === routeSettings.flagNameIda) { // IDA leg
                        if (originalPoint.id === p1?.id) effTime = p1TimesForCurrentTurn.departureIDA;
                        else if (originalPoint.id === p2?.id) effTime = p2TimesForCurrentTurn.arrivalIDA;
                    } else { // VUELTA leg
                        if (originalPoint.id === p2?.id) effTime = p2TimesForCurrentTurn.departureVUELTA;
                        else if (originalPoint.id === p1?.id) effTime = p1TimesForCurrentTurn.arrivalVUELTA;
                    }
                } else if (originalPoint.pointCategory === 'intermediateStop') {
                    effTime = (trackingState.currentFlag === routeSettings.flagNameIda) ? originalPoint.times.scheduledIDA : originalPoint.times.scheduledVUELTA;
                }
                return { ...originalPoint, effectiveScheduledTime: effTime ? new Date(effTime) : null };
            });


            if (trackingState.activeLegPoints.length > 0 && 
                (!trackingState.activeLegPoints[0].effectiveScheduledTime || 
                 !trackingState.activeLegPoints[trackingState.activeLegPoints.length -1].effectiveScheduledTime)
                ) {
                 alert(`Horarios incompletos para los extremos de la bandera ${trackingState.currentFlag} (Vuelta ${trackingState.currentTurn}).`);
                 return false;
            }
            return true;
        }

        function startTracking() {
            setActiveMode(null); 
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
            if (lineEndpoints.length < 2) { alert("La ruta debe tener dos Puntas de Línea (P1 y P2)."); return; }
            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);
            if (!p1 || !p2){ alert("P1 y/o P2 no están correctamente definidos."); return; }
            
            // Check if all turns have schedules for P1 and P2
            for (let i = 0; i < routeSettings.totalTurns; i++) {
                const turnNum = i + 1;
                const p1t = getEndpointTimesForTurn(p1, turnNum);
                const p2t = getEndpointTimesForTurn(p2, turnNum);
                if (!p1t.departureIDA || !p1t.arrivalVUELTA || !p2t.arrivalIDA || !p2t.departureVUELTA) {
                    alert(`Horarios incompletos para P1/P2 en Vuelta ${turnNum}. No se puede iniciar seguimiento.`);
                    return;
                }
            }
            
            isTracking = true;
            trackingState.currentTurn = 1;
            trackingState.currentFlag = routeSettings.flagNameIda; 
            currentSegmentStartIndex = 0; 
            
            if (!setupCurrentLegForTracking()) {
                stopTracking(false, "Error configurando pierna inicial de seguimiento."); return;
            }
            
            document.getElementById('startTrackingBtn').style.display = 'none';
            document.getElementById('stopTrackingBtn').style.display = 'inline-block';
            document.getElementById('routeCreationSection').style.display = 'none'; 
            updateTrackingStatusDisplay();
            redrawRouteLine(); 
            updateWaypointMarkersVisibility(false); 

            if (navigator.geolocation) {
                trackingIntervalId = navigator.geolocation.watchPosition(
                    handlePositionUpdate, handleGeolocationError,
                    { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 } 
                );
                if (trackingState.activeLegPoints.length > 0 && trackingState.activeLegPoints[0]) {
                    map.setView([trackingState.activeLegPoints[0].lat, trackingState.activeLegPoints[0].lng], 16); 
                }
                highlightNextStopInList(); 
            } else {
                alert("Geolocalización no disponible."); stopTracking(false); 
            }
            updateManualNavButtons();
        }

        function stopTracking(completedNaturally = false, reason = "") {
            if (trackingIntervalId) navigator.geolocation.clearWatch(trackingIntervalId);
            trackingIntervalId = null; isTracking = false; lastKnownPosition = null;
            document.getElementById('startTrackingBtn').style.display = 'inline-block';
            document.getElementById('stopTrackingBtn').style.display = 'none';
            document.getElementById('routeCreationSection').style.display = 'block'; 
            if (userMarker) { map.removeLayer(userMarker); userMarker = null; }
            
            currentEditingFlagView = routeSettings.flagNameIda;
            const editFlagBtn = document.getElementById('toggleEditingFlagViewBtn');
            if (editFlagBtn) editFlagBtn.textContent = `Vista Trazado: ${routeSettings.flagNameIda}`;
            
            trackingState.currentFlag = routeSettings.flagNameIda; 
            redrawRouteLine(); updateStopsList(); 
            currentSegmentStartIndex = 0; 
            updateManualNavButtons();
            setActiveMode(null); 
            updateWaypointMarkersVisibility(false); 


            if (completedNaturally) {
                document.getElementById('trackingInfoDisplay').textContent = "RUTA COMPLETADA";
                alert("Ruta completada!"); checkRouteQueue();
            } else {
                const msg = "Seguimiento detenido." + (reason ? " Razón: " + reason : "");
                console.log(msg); if (reason && reason.startsWith("Error")) alert(msg); // Only alert actual errors
                document.getElementById('trackingInfoDisplay').textContent = "SEGUIMIENTO DETENIDO";
            }
        }
        
        function updateTrackingStatusDisplay() {
            if (!isTracking) {
                document.getElementById('statusDisplay').style.display = 'none';
                return;
            }

            document.getElementById('statusDisplay').style.display = 'block';
            document.getElementById('trackingInfoDisplay').textContent = 
                `Vuelta: ${trackingState.currentTurn}/${routeSettings.totalTurns} - Bandera: ${trackingState.currentFlag}`;
        }

        function updateManualNavButtons() {
            const manualNav = document.getElementById('manualStopNav').checked;
            const prevBtn = document.getElementById('prevStopBtn');
            const nextBtn = document.getElementById('nextStopBtn');
            
            if (isTracking && manualNav && trackingState.activeLegPoints && trackingState.activeLegPoints.length > 0) {
                prevBtn.style.display = 'inline-block';
                nextBtn.style.display = 'inline-block';
                prevBtn.disabled = currentSegmentStartIndex === 0;
                nextBtn.disabled = currentSegmentStartIndex >= trackingState.activeLegPoints.length - 2; // -2 because target is index+1
            } else {
                prevBtn.style.display = 'none'; nextBtn.style.display = 'none';
            }
        }

        function handlePositionUpdate(position) {
            lastKnownPosition = position;
            const { latitude, longitude, speed } = position.coords;
            if (!userMarker) userMarker = L.marker([latitude, longitude], { icon: createUserLocationIcon() }).addTo(map);
            else userMarker.setLatLng([latitude, longitude]);
            // map.panTo([latitude, longitude], {animate: true, duration: 0.5}); // Can be annoying if map is manually panned
            document.getElementById('speedDisplay').textContent = `Velocidad: ${(speed ? (speed * 3.6) : 0).toFixed(1)} KM/H`;

            if (!trackingState.activeLegPoints || currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) {
                return; 
            }
            
            const manualNav = document.getElementById('manualStopNav').checked;
            let advancedThisTick = false;

            if (!manualNav) {
                const currentTargetPoint = trackingState.activeLegPoints[currentSegmentStartIndex + 1];
                if (currentTargetPoint && currentTargetPoint.pointCategory !== 'waypoint') { 
                    const distanceToTarget = L.latLng(latitude, longitude).distanceTo(L.latLng(currentTargetPoint.lat, currentTargetPoint.lng));
                    if (distanceToTarget < currentStopRadius) {
                        advanceToNextActivePoint(); advancedThisTick = true;
                    }
                }
            }
            if (!advancedThisTick && currentSegmentStartIndex < trackingState.activeLegPoints.length -1 && trackingState.activeLegPoints[currentSegmentStartIndex+1]) { 
                 calculateTimeDeviation(position);
            }
        }
        
        function advanceToNextActivePoint() { 
            currentSegmentStartIndex++;
            if (!trackingState.activeLegPoints || currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) { 
                handleEndOfLeg();
            } else {
                highlightNextStopInList(); updateManualNavButtons();
                if (lastKnownPosition && trackingState.activeLegPoints[currentSegmentStartIndex+1]) calculateTimeDeviation(lastKnownPosition);
            }
        }

        function handleEndOfLeg() {
            if (trackingState.currentFlag === routeSettings.flagNameIda) {
                trackingState.currentFlag = routeSettings.flagNameVuelta;
            } else {
                trackingState.currentTurn++;
                if (trackingState.currentTurn > routeSettings.totalTurns) {
                    stopTracking(true); return;
                }
                trackingState.currentFlag = routeSettings.flagNameIda;
            }

            currentSegmentStartIndex = 0;
            if (!setupCurrentLegForTracking()) {
                 stopTracking(false, `Error configurando pierna ${trackingState.currentFlag} (Vuelta ${trackingState.currentTurn}).`); return;
            }
            updateTrackingStatusDisplay(); redrawRouteLine(); highlightNextStopInList();
            updateManualNavButtons(); 
            if (lastKnownPosition && trackingState.activeLegPoints && trackingState.activeLegPoints.length > 1 && trackingState.activeLegPoints[1]) {
                 calculateTimeDeviation(lastKnownPosition);
            }
            
            if (trackingState.activeLegPoints.length > 0 && trackingState.activeLegPoints[0]) {
                map.setView([trackingState.activeLegPoints[0].lat, trackingState.activeLegPoints[0].lng], map.getZoom()); 
            }
        }
        
        function goToPreviousActivePoint() {
            if (!isTracking || currentSegmentStartIndex === 0) return;
            currentSegmentStartIndex--;
            highlightNextStopInList(); updateManualNavButtons();
            if (lastKnownPosition && trackingState.activeLegPoints && trackingState.activeLegPoints[currentSegmentStartIndex+1]) calculateTimeDeviation(lastKnownPosition);
        }
        function goToNextActivePoint() { 
            if (!isTracking || !trackingState.activeLegPoints || currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) return;
            advanceToNextActivePoint();
        }

        function highlightNextStopInList() {
            document.querySelectorAll('#stopsList .stop-item').forEach(item => item.classList.remove('next-stop-highlight'));
            let nextStopName = "N/A";

            if (isTracking && trackingState.activeLegPoints && trackingState.activeLegPoints.length > 0 && 
                currentSegmentStartIndex < trackingState.activeLegPoints.length - 1) {
                
                let displayableNextTarget = null;
                for(let i = currentSegmentStartIndex + 1; i < trackingState.activeLegPoints.length; i++){
                    if(trackingState.activeLegPoints[i].pointCategory !== 'waypoint'){
                        displayableNextTarget = trackingState.activeLegPoints[i];
                        break;
                    }
                }
                if (!displayableNextTarget && trackingState.activeLegPoints.length > currentSegmentStartIndex +1 ) {
                     displayableNextTarget = trackingState.activeLegPoints[currentSegmentStartIndex + 1];
                }


                if(displayableNextTarget) {
                    nextStopName = displayableNextTarget.name;
                    const listPoints = getSortedRoutePointsForDisplay(); 
                    const displayIndexInList = listPoints.findIndex(dp => dp.id === displayableNextTarget.id);
                    
                    if (displayIndexInList !== -1 && document.querySelectorAll('#stopsList .stop-item')[displayIndexInList]) {
                        document.querySelectorAll('#stopsList .stop-item')[displayIndexInList].classList.add('next-stop-highlight');
                    }
                }
            } else if (!isTracking) {
                const displayPoints = getSortedRoutePointsForDisplay();
                if (displayPoints.length > 0 && displayPoints[0].pointCategory !== 'waypoint') {
                     nextStopName = displayPoints[0].name;
                }
            }
            document.getElementById('nextStopDisplay').textContent = `Próxima: ${nextStopName}`;
        }

        function calculateTimeDeviation(currentUserGeoPosition) { 
            if (!isTracking || !trackingState.activeLegPoints || currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) {
                document.getElementById('timeDeviation').textContent = "00:00";
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                return;
            }

            const pointA = trackingState.activeLegPoints[currentSegmentStartIndex];
            const pointB = trackingState.activeLegPoints[currentSegmentStartIndex + 1];

            if (!pointA || !pointB || !pointA.effectiveScheduledTime || !pointB.effectiveScheduledTime ||
                pointA.pointCategory === 'waypoint' || pointB.pointCategory === 'waypoint') { 
                document.getElementById('timeDeviation').textContent = "N/A_T";
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                return;
            }
            const scheduledTimeA = new Date(pointA.effectiveScheduledTime);
            const scheduledTimeB = new Date(pointB.effectiveScheduledTime);
            const segmentTotalScheduledMillis = scheduledTimeB.getTime() - scheduledTimeA.getTime();

            if (segmentTotalScheduledMillis <= 0 && !(scheduledTimeA.getTime() === scheduledTimeB.getTime() && pointA.id === pointB.id) ) { 
                document.getElementById('timeDeviation').textContent = "ERR_DUR";
                document.getElementById('timeDeviation').style.color = "#FFA500"; // Orange for duration error
                return;
            }

            const latLngA = L.latLng(pointA.lat, pointA.lng);
            const latLngB = L.latLng(pointB.lat, pointB.lng);
            const currentUserLatLng = L.latLng(currentUserGeoPosition.coords.latitude, currentUserGeoPosition.coords.longitude);
            const distanceTotalSegment = latLngA.distanceTo(latLngB);
            let progressPercentage;

            if (distanceTotalSegment < 1.0) { 
                // If segment is tiny, assume progress is 0 unless very close to B
                const distToBForTiny = currentUserLatLng.distanceTo(latLngB);
                progressPercentage = (distToBForTiny < 5.0 && distanceTotalSegment > 0.1) ? 1.0 : 0.0;
                 // For tiny segments, deviation is essentially against the scheduled time of A or B
                const now = new Date();
                let expectedTimeAtCurrentPosMillis;
                // If segment is point-like or duration is zero, compare to B if past midpoint of A's time, else A
                if(segmentTotalScheduledMillis === 0 || now.getTime() > (scheduledTimeA.getTime() + segmentTotalScheduledMillis / 2)){
                    expectedTimeAtCurrentPosMillis = scheduledTimeB.getTime();
                } else {
                    expectedTimeAtCurrentPosMillis = scheduledTimeA.getTime();
                }
                const deviationMillisSpecial = expectedTimeAtCurrentPosMillis - now.getTime();
                displayDeviation(deviationMillisSpecial);
                return;
            }
            
            // Projection logic (simplified)
            const distToA = currentUserLatLng.distanceTo(latLngA); 
            const distToB = currentUserLatLng.distanceTo(latLngB); 

            if (distToA < 10.0) progressPercentage = 0.0; 
            else if (distToB < 10.0) progressPercentage = 1.0; 
            // Check if user is "beyond" B relative to A->B vector
            else if (distToA > distanceTotalSegment && distToA > distToB) progressPercentage = 1.0;
            // Check if user is "before" A relative to A->B vector
            else if (distToB > distanceTotalSegment && distToB > distToA) progressPercentage = 0.0;
            else { 
                 // Using a simplified approach: proportion of distance along the line segment
                // This is an approximation and doesn't handle being off-route well.
                // A more robust method uses vector projection.
                // Simplified: (TotalDist - DistToB) / TotalDist
                // This assumes user is roughly on the segment between A and B
                let projectedProgress = (distanceTotalSegment - distToB) / distanceTotalSegment;
                progressPercentage = Math.max(0, Math.min(1, projectedProgress));
                 // If distances suggest user is closer to A than projection indicates, or vice versa, cap it.
                 // Example: if dist_A_to_P_prime_on_AB logic from previous version is preferred:
                 const dist_A_to_P_prime_on_AB = (Math.pow(distanceTotalSegment, 2) + Math.pow(distToA, 2) - Math.pow(distToB, 2)) / (2 * distanceTotalSegment);
                 progressPercentage = dist_A_to_P_prime_on_AB / distanceTotalSegment;

            }
            progressPercentage = Math.max(0, Math.min(1, progressPercentage)); 

            const expectedTimeElapsedMillis = segmentTotalScheduledMillis * progressPercentage;
            const expectedTimeAtCurrentPosition = new Date(scheduledTimeA.getTime() + expectedTimeElapsedMillis);
            const currentTime = new Date();
            const deviationMillis = expectedTimeAtCurrentPosition.getTime() - currentTime.getTime();
            displayDeviation(deviationMillis);
        }

        function displayDeviation(deviationMillis) { 
            const absMillis = Math.abs(deviationMillis);
            const totalSecondsValue = Math.floor(absMillis / 1000);
            const displaySeconds = totalSecondsValue % 60;
            const totalMinutesValue = Math.floor(totalSecondsValue / 60);
            const sign = deviationMillis >= 0 ? "+" : "-";
            const formattedDeviation = `${sign}${String(totalMinutesValue).padStart(2, '0')}:${String(displaySeconds).padStart(2, '0')}`;
            const deviationDiv = document.getElementById('timeDeviation');
            deviationDiv.textContent = formattedDeviation;
            if (deviationMillis >= -59999 && deviationMillis <= 59999) deviationDiv.style.color = "#FFFFFF"; 
            else if (deviationMillis > 59999) deviationDiv.style.color = "#00FF00"; 
            else deviationDiv.style.color = "#FF0000"; 
        }
        function handleGeolocationError(error) { 
            console.error("Error de geolocalización: ", error);
            alert(`Error de geolocalización: ${error.message}.`);
            if (isTracking) stopTracking(false, "Error de geolocalización"); 
        }

        function getRouteQueue() { const q = localStorage.getItem(ROUTE_QUEUE_CACHE_KEY); return q ? JSON.parse(q) : [];}
        function saveRouteQueue(queue) { localStorage.setItem(ROUTE_QUEUE_CACHE_KEY, JSON.stringify(queue)); updateRouteQueueDisplay();}
        function addRouteToQueue() { 
            const selectedRouteName = document.getElementById('routeToQueue').value;
            if (!selectedRouteName || document.getElementById('routeToQueue').options[0]?.disabled) { 
                alert("Selecciona una ruta válida para añadir."); return;
            }
            const queue = getRouteQueue(); if (queue.includes(selectedRouteName)) { alert("Ruta ya en cola."); return; }
            queue.push(selectedRouteName); saveRouteQueue(queue); alert(`Ruta "${selectedRouteName}" añadida.`);
        }
        function updateRouteQueueDisplay() { 
            const queueDiv = document.getElementById('routeQueueDisplay'); const queue = getRouteQueue();
            if (queue.length === 0) { queueDiv.innerHTML = "Vacía."; } 
            else { let html = "<ol style='padding-left: 20px; margin-top: 5px;'>"; queue.forEach(rn => { html += `<li>${rn}</li>`; }); html += "</ol>"; queueDiv.innerHTML = html; }
        }
        function clearRouteQueue() { if (confirm("¿Limpiar toda la cola?")) saveRouteQueue([]);}
        
        function checkRouteQueue() { 
            let queue = getRouteQueue();
            if (queue.length > 0) {
                const nextRouteName = queue.shift(); saveRouteQueue(queue); 
                if (confirm(`Ruta finalizada. ¿Iniciar siguiente ruta de la cola: "${nextRouteName}"?`)) {
                    const savedRoutesSelect = document.getElementById('savedRoutes');
                    // Check if the route name exists in the dropdown
                    let routeExists = false;
                    for (let i = 0; i < savedRoutesSelect.options.length; i++) {
                        if (savedRoutesSelect.options[i].value === nextRouteName) {
                            routeExists = true;
                            break;
                        }
                    }

                    if (routeExists) {
                        savedRoutesSelect.value = nextRouteName; 
                        loadRoute(); // This function is synchronous for data loading
                        
                        // Use a timeout to ensure DOM updates from loadRoute (if any) are processed
                        // and then attempt to start tracking.
                        setTimeout(() => { 
                            // Re-validate P1/P2 and their schedules for all turns for the newly loaded route
                            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
                            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
                            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);
                            let canStart = p1 && p2;
                            if (canStart) {
                                for (let i = 0; i < routeSettings.totalTurns; i++) {
                                    const turnNum = i + 1;
                                    const p1t = getEndpointTimesForTurn(p1, turnNum);
                                    const p2t = getEndpointTimesForTurn(p2, turnNum);
                                    if (!p1t.departureIDA || !p1t.arrivalVUELTA || !p2t.arrivalIDA || !p2t.departureVUELTA) {
                                        canStart = false; break;
                                    }
                                }
                            }

                            if (canStart) {
                                startTracking();
                            } else {
                                alert(`Error al cargar la ruta "${nextRouteName}" de la cola o sus horarios son inválidos. Verifique la configuración de P1/P2 para todas las vueltas.`);
                            }
                        }, 500); 
                    } else {
                        alert(`La ruta "${nextRouteName}" de la cola ya no existe o no se pudo encontrar.`);
                    }
                } else {
                    alert("Siguiente ruta de la cola no iniciada.");
                }
            }
        }


        function updateGlobalStopRadiusSettings() { 
            const newRadius = parseInt(document.getElementById('stopRadiusInput').value, 10);
            if (!isNaN(newRadius) && newRadius >= 10 && newRadius <= 500) {
                currentStopRadius = newRadius;
                routePoints.forEach(point => {
                    if (point.radiusCircle) point.radiusCircle.setRadius(currentStopRadius);
                });
            } else {
                alert("Radio inválido (10-500m).");
                document.getElementById('stopRadiusInput').value = currentStopRadius;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initMap(); 
            loadSavedRoutesLists(); 
            updateStopsList(); 
            updateManualNavButtons(); 
            setActiveMode(null); 
            updateTrackingStatusDisplay();
        });

    </script>
</body>
</html>
