<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Move Pro</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#4CAF50">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #f4f4f4;
        }
        #map {
            height: 50vh; /* Ajustado para mejor visibilidad en móvil */
            width: 100%;
            border-bottom: 2px solid #ccc;
        }
        .controls-panel {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            background-color: #fff;
        }
        .control-section {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .control-section h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="text"], input[type="time"], select {
            width: calc(100% - 12px);
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            margin: 5px 2px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .stop-list-item {
            padding: 5px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .stop-list-item:last-child {
            border-bottom: none;
        }
        .remove-stop-btn {
            background-color: #f44336;
            padding: 3px 8px;
            font-size: 0.8em;
        }
        #tracking-status, #next-stop-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #e7f3fe;
            border: 1px solid #b3d7ff;
            border-radius: 4px;
        }
        .error-message {
            color: red;
            font-weight: bold;
        }
        .info-message {
            color: blue;
        }
         /* Leaflet custom icons */
        .leaflet-marker-icon.custom-marker-icon-S,
        .leaflet-marker-icon.custom-marker-icon-F,
        .leaflet-marker-icon.custom-marker-icon-N {
            text-align: center;
            line-height: 20px; /* Adjust based on icon size */
            font-weight: bold;
            color: white;
            border-radius: 50%;
            width: 20px !important;
            height: 20px !important;
            margin-left: -10px !important; /* Center horizontally */
            margin-top: -10px !important;  /* Center vertically */
        }
        .leaflet-marker-icon.custom-marker-icon-S { background-color: green; }
        .leaflet-marker-icon.custom-marker-icon-F { background-color: red; }
        .leaflet-marker-icon.custom-marker-icon-N { background-color: orange; }

        .manual-controls button {
            background-color: #2196F3;
        }
        .manual-controls button:hover {
            background-color: #0b7dda;
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <div class="controls-panel">
        <!-- Route Definition -->
        <div class="control-section">
            <h3>Definición de Ruta</h3>
            <div>
                <label for="start-point-name">Nombre Punto Inicio (ej: Terminal):</label>
                <input type="text" id="start-point-name" placeholder="Nombre opcional">
                <label for="start-point-time">Hora Salida Programada Inicio:</label>
                <input type="time" id="start-point-time">
                <button id="set-start-point-btn">Definir Inicio en Mapa</button>
            </div>
            <div style="margin-top:10px;">
                <label for="end-point-name">Nombre Punto Final (ej: Plaza):</label>
                <input type="text" id="end-point-name" placeholder="Nombre opcional">
                <label for="end-point-time">Hora Llegada Programada Final:</label>
                <input type="time" id="end-point-time">
                <button id="set-end-point-btn">Definir Fin en Mapa</button>
            </div>
            <div style="margin-top:10px;">
                <input type="checkbox" id="auto-calculate-times" checked>
                <label for="auto-calculate-times" style="display:inline; font-weight:normal;">Calcular horarios intermedios automáticamente</label>
            </div>
            <p><i>Toca el mapa para añadir paradas intermedias (después de definir Inicio/Fin).</i></p>
            <h4>Paradas:</h4>
            <div id="stops-list">Vacío</div>
        </div>

        <!-- Route Management -->
        <div class="control-section">
            <h3>Gestión de Rutas</h3>
            <label for="route-name">Nombre de la Ruta para Guardar:</label>
            <input type="text" id="route-name" placeholder="Ej: Linea 101 - Mañana">
            <button id="save-route-btn">Guardar Ruta</button>
            <hr>
            <label for="load-route-select">Cargar Ruta:</label>
            <select id="load-route-select"></select>
            <button id="load-route-btn">Cargar Seleccionada</button>
            <button id="delete-route-btn">Eliminar Seleccionada</button>
        </div>

        <!-- Tracking Queue -->
        <div class="control-section">
            <h3>Cola de Seguimiento</h3>
            <button id="add-to-queue-btn">Añadir Ruta Cargada a Cola</button>
            <button id="clear-queue-btn">Limpiar Cola</button>
            <h4>Rutas en Cola:</h4>
            <div id="tracking-queue-list">Vacía</div>
        </div>

        <!-- Tracking Control -->
        <div class="control-section">
            <h3>Control de Seguimiento</h3>
            <button id="start-tracking-btn">Iniciar Seguimiento</button>
            <button id="stop-tracking-btn" disabled>Detener Seguimiento</button>
            <div style="margin-top:10px;">
                <input type="checkbox" id="manual-control-checkbox">
                <label for="manual-control-checkbox" style="display:inline; font-weight:normal;">Control Manual Parada/Ruta</label>
            </div>
            <div id="manual-nav-buttons" style="display:none;" class="manual-controls">
                <button id="prev-stop-btn">Parada Anterior</button>
                <button id="next-stop-btn">Parada Siguiente / Próxima Ruta</button>
            </div>
            <div id="tracking-status">Estado: Inactivo</div>
            <div id="next-stop-info">Próxima parada: N/A</div>
            <div id="error-log" class="error-message"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <script>
        (function() {
            // --- PWA Service Worker Registration ---
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js')
                        .then(registration => {
                            console.log('ServiceWorker registration successful with scope: ', registration.scope);
                        })
                        .catch(err => {
                            console.log('ServiceWorker registration failed: ', err);
                        });
                });
            }

            // --- Constants ---
            const PROXIMITY_THRESHOLD_METERS = 50; // For intermediate stops
            const GEOFENCE_RADIUS_METERS = 100; // For start/end points
            const LOCALSTORAGE_ROUTES_KEY = 'smartMoveProRoutes';
            const LOCALSTORAGE_TRACKING_STATUS_KEY = 'smartMoveProTrackingStatus';

            // --- Leaflet Map Variables ---
            let map;
            let routeLayerGroup = L.layerGroup();
            let geofenceLayerGroup = L.layerGroup();
            let currentUserPositionMarker = null;
            let mapClickHandlerEnabled = false;

            // --- Route Definition State ---
            let currentRoute = {
                name: "",
                startPoint: null, // { name, lat, lng, departureTime (HH:MM string), type: 'start' }
                intermediateStops: [], // Array of { name, lat, lng, arrivalTime, departureTime, type: 'intermediate' }
                endPoint: null, // { name, lat, lng, arrivalTime (HH:MM string), type: 'end' }
            };

            // --- Route Management State ---
            let savedRoutes = {}; // { "routeName": routeObject, ... }

            // --- Tracking Queue State ---
            let trackingQueue = []; // Array of route names

            // --- Tracking State ---
            let isTracking = false;
            let watchId = null;
            let activeRouteDetails = null; // Full route object being tracked
            let currentTrackingStopIndex = -1; // -1: at start, 0: heading to 1st intermediate, etc.
            let actualDepartureTimeOfCurrentLegStart = null; // Timestamp
            let trackingStatusUpdateInterval = null;
            let timeDifferenceUpdateInterval = null;

            // --- DOM Elements ---
            const startPointNameInput = document.getElementById('start-point-name');
            const startPointTimeInput = document.getElementById('start-point-time');
            const setStartPointBtn = document.getElementById('set-start-point-btn');
            const endPointNameInput = document.getElementById('end-point-name');
            const endPointTimeInput = document.getElementById('end-point-time');
            const setEndPointBtn = document.getElementById('set-end-point-btn');
            const autoCalculateTimesCheckbox = document.getElementById('auto-calculate-times');
            const stopsListDiv = document.getElementById('stops-list');
            const routeNameInput = document.getElementById('route-name');
            const saveRouteBtn = document.getElementById('save-route-btn');
            const loadRouteSelect = document.getElementById('load-route-select');
            const loadRouteBtn = document.getElementById('load-route-btn');
            const deleteRouteBtn = document.getElementById('delete-route-btn');
            const addToQueueBtn = document.getElementById('add-to-queue-btn');
            const clearQueueBtn = document.getElementById('clear-queue-btn');
            const trackingQueueListDiv = document.getElementById('tracking-queue-list');
            const startTrackingBtn = document.getElementById('start-tracking-btn');
            const stopTrackingBtn = document.getElementById('stop-tracking-btn');
            const manualControlCheckbox = document.getElementById('manual-control-checkbox');
            const manualNavButtonsDiv = document.getElementById('manual-nav-buttons');
            const prevStopBtn = document.getElementById('prev-stop-btn');
            const nextStopBtn = document.getElementById('next-stop-btn');
            const trackingStatusDiv = document.getElementById('tracking-status');
            const nextStopInfoDiv = document.getElementById('next-stop-info');
            const errorLogDiv = document.getElementById('error-log');

            // --- Helper Functions ---
            function logError(message) {
                console.error(message);
                errorLogDiv.textContent = message;
                setTimeout(() => errorLogDiv.textContent = '', 5000);
            }

            function parseHHMMToDate(hhmmStr) {
                if (!hhmmStr || !hhmmStr.includes(':')) return null;
                const [hours, minutes] = hhmmStr.split(':').map(Number);
                const date = new Date();
                date.setHours(hours, minutes, 0, 0);
                return date;
            }

            function formatDateToHHMM(dateObj) {
                if (!dateObj) return "";
                return dateObj.getHours().toString().padStart(2, '0') + ':' +
                       dateObj.getMinutes().toString().padStart(2, '0');
            }
            
            function formatDelay(ms) {
                if (ms === null || isNaN(ms)) return "N/A";
                const sign = ms >= 0 ? "+" : "-";
                const absMs = Math.abs(ms);
                const totalSeconds = Math.floor(absMs / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${sign}${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            function calculateDistance(lat1, lon1, lat2, lon2) { // Haversine
                const R = 6371e3; // metres
                const φ1 = lat1 * Math.PI/180;
                const φ2 = lat2 * Math.PI/180;
                const Δφ = (lat2-lat1) * Math.PI/180;
                const Δλ = (lon2-lon1) * Math.PI/180;

                const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                          Math.cos(φ1) * Math.cos(φ2) *
                          Math.sin(Δλ/2) * Math.sin(Δλ/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }

            function getStopIcon(type, index) {
                let label = '';
                let className = 'custom-marker-icon-N'; // Default for intermediate
                if (type === 'start') {
                    label = 'S'; // Start
                    className = 'custom-marker-icon-S';
                } else if (type === 'end') {
                    label = 'F'; // Finish
                    className = 'custom-marker-icon-F';
                } else { // intermediate
                    label = (index + 1).toString();
                }
                return L.divIcon({
                    className: `leaflet-marker-icon ${className}`,
                    html: `<span>${label}</span>`,
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                });
            }

            // --- Map Initialization and Functions ---
            function initMap() {
                map = L.map('map');
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                routeLayerGroup.addTo(map);
                geofenceLayerGroup.addTo(map);

                map.on('click', onMapClick);

                // Try to center on user's location once
                navigator.geolocation.getCurrentPosition(
                    (position) => map.setView([position.coords.latitude, position.coords.longitude], 13),
                    () => map.setView([0, 0], 2) // Default if location fails
                );
            }

            function onMapClick(e) {
                if (!mapClickHandlerEnabled) return;

                const { lat, lng } = e.latlng;
                if (!currentRoute.startPoint) {
                    alert("Define el Punto de Inicio primero.");
                    return;
                }
                if (!currentRoute.endPoint) {
                    alert("Define el Punto Final primero.");
                    return;
                }

                // Add intermediate stop
                const stopName = prompt("Nombre para esta parada (opcional):") || `Parada ${currentRoute.intermediateStops.length + 1}`;
                let arrivalTimeStr = "";
                if (!autoCalculateTimesCheckbox.checked) {
                    arrivalTimeStr = prompt("Hora de llegada/paso (HH:MM) para esta parada:", formatDateToHHMM(new Date()));
                    if (!parseHHMMToDate(arrivalTimeStr)) {
                        alert("Formato de hora inválido. Parada no añadida.");
                        return;
                    }
                }
                
                currentRoute.intermediateStops.push({
                    name: stopName,
                    lat: lat,
                    lng: lng,
                    arrivalTime: arrivalTimeStr, // Store as HH:MM string initially
                    departureTime: arrivalTimeStr, // Same as arrival
                    type: 'intermediate'
                });
                
                if (autoCalculateTimesCheckbox.checked) {
                    calculateAndSetIntermediateTimes();
                }
                drawCurrentRouteOnMap();
                updateStopsListDisplay();
            }

            function definePointOnMap(type) {
                alert(`Toca el mapa para definir el Punto de ${type === 'start' ? 'Inicio' : 'Fin'}.`);
                mapClickHandlerEnabled = false; // Disable intermediate stop adding
                map.once('click', (e) => {
                    const { lat, lng } = e.latlng;
                    if (type === 'start') {
                        const timeStr = startPointTimeInput.value;
                        if (!timeStr) { alert("Por favor, ingresa la hora de salida."); return; }
                        currentRoute.startPoint = { 
                            name: startPointNameInput.value || "Inicio", 
                            lat, lng, 
                            departureTime: timeStr, 
                            type: 'start' 
                        };
                        mapClickHandlerEnabled = true; // Re-enable for intermediate stops
                    } else { // end
                        const timeStr = endPointTimeInput.value;
                        if (!timeStr) { alert("Por favor, ingresa la hora de llegada."); return; }
                        currentRoute.endPoint = { 
                            name: endPointNameInput.value || "Fin", 
                            lat, lng, 
                            arrivalTime: timeStr, 
                            type: 'end' 
                        };
                        mapClickHandlerEnabled = true; // Re-enable for intermediate stops
                    }
                    if (autoCalculateTimesCheckbox.checked) {
                         calculateAndSetIntermediateTimes();
                    }
                    drawCurrentRouteOnMap();
                    updateStopsListDisplay();
                });
            }

            function drawCurrentRouteOnMap(routeToDraw = currentRoute, color = 'blue') {
                routeLayerGroup.clearLayers();
                if (!routeToDraw || (!routeToDraw.startPoint && !routeToDraw.intermediateStops.length && !routeToDraw.endPoint)) return;

                const points = [];
                if (routeToDraw.startPoint) {
                    const { lat, lng } = routeToDraw.startPoint;
                    L.marker([lat, lng], { icon: getStopIcon('start') })
                        .addTo(routeLayerGroup)
                        .bindPopup(`<b>Inicio:</b> ${routeToDraw.startPoint.name}<br>Sale: ${routeToDraw.startPoint.departureTime || 'N/A'}`);
                    points.push([lat, lng]);
                }

                routeToDraw.intermediateStops.forEach((stop, index) => {
                    const { lat, lng } = stop;
                    L.marker([lat, lng], { icon: getStopIcon('intermediate', index) })
                        .addTo(routeLayerGroup)
                        .bindPopup(`<b>Parada ${index + 1}:</b> ${stop.name}<br>Llega/Sale: ${stop.arrivalTime || 'N/A'}`);
                    points.push([lat, lng]);
                });

                if (routeToDraw.endPoint) {
                    const { lat, lng } = routeToDraw.endPoint;
                    L.marker([lat, lng], { icon: getStopIcon('end') })
                        .addTo(routeLayerGroup)
                        .bindPopup(`<b>Fin:</b> ${routeToDraw.endPoint.name}<br>Llega: ${routeToDraw.endPoint.arrivalTime || 'N/A'}`);
                    points.push([lat, lng]);
                }

                if (points.length > 1) {
                    L.polyline(points, { color: color, weight: 3 }).addTo(routeLayerGroup);
                }
            }
            
            function calculateAndSetIntermediateTimes() {
                if (!currentRoute.startPoint || !currentRoute.endPoint || !currentRoute.startPoint.departureTime || !currentRoute.endPoint.arrivalTime) {
                    return; // Not enough info
                }
                if (!currentRoute.intermediateStops.length) {
                    updateStopsListDisplay(); // Refresh display even if no intermediates
                    return;
                }

                const startTime = parseHHMMToDate(currentRoute.startPoint.departureTime);
                const endTime = parseHHMMToDate(currentRoute.endPoint.arrivalTime);

                if (!startTime || !endTime || endTime <= startTime) {
                    logError("Hora de fin debe ser posterior a la hora de inicio para cálculo automático.");
                    currentRoute.intermediateStops.forEach(stop => {
                        stop.arrivalTime = "";
                        stop.departureTime = "";
                    });
                    updateStopsListDisplay();
                    return;
                }

                const totalDurationMillis = endTime.getTime() - startTime.getTime();
                
                const allStopsForDistance = [currentRoute.startPoint, ...currentRoute.intermediateStops, currentRoute.endPoint];
                let totalDistance = 0;
                const legDistances = [];

                for (let i = 0; i < allStopsForDistance.length - 1; i++) {
                    const dist = calculateDistance(
                        allStopsForDistance[i].lat, allStopsForDistance[i].lng,
                        allStopsForDistance[i+1].lat, allStopsForDistance[i+1].lng
                    );
                    legDistances.push(dist);
                    totalDistance += dist;
                }

                if (totalDistance === 0 && currentRoute.intermediateStops.length > 0) {
                     logError("Distancia total es cero, no se pueden calcular tiempos intermedios proporcionalmente.");
                     currentRoute.intermediateStops.forEach(stop => {
                        stop.arrivalTime = "";
                        stop.departureTime = "";
                     });
                     updateStopsListDisplay();
                     return;
                }
                
                let accumulatedDistance = 0;
                currentRoute.intermediateStops.forEach((stop, index) => {
                    // Distance for this stop is from start to this stop.
                    // The leg to this intermediate stop is legDistances[index] (start to interm[0]), 
                    // legDistances[index+1] (interm[0] to interm[1]), etc.
                    accumulatedDistance += legDistances[index]; // Distance from start to current intermediate stop via previous stops
                    
                    const proportionOfDistance = totalDistance > 0 ? accumulatedDistance / totalDistance : 0;
                    const timeOffsetMillis = proportionOfDistance * totalDurationMillis;
                    
                    const arrivalAtStop = new Date(startTime.getTime() + timeOffsetMillis);
                    stop.arrivalTime = formatDateToHHMM(arrivalAtStop);
                    stop.departureTime = stop.arrivalTime; // As per spec
                });
                updateStopsListDisplay();
            }

            // --- UI Update Functions ---
            function updateStopsListDisplay() {
                stopsListDiv.innerHTML = '';
                const stops = [];
                if (currentRoute.startPoint) stops.push(currentRoute.startPoint);
                stops.push(...currentRoute.intermediateStops);
                if (currentRoute.endPoint) stops.push(currentRoute.endPoint);

                if (stops.length === 0) {
                    stopsListDiv.textContent = "Vacío";
                    return;
                }

                const ul = document.createElement('ul');
                ul.style.listStyleType = 'none';
                ul.style.paddingLeft = '0';

                stops.forEach((stop, index) => {
                    const li = document.createElement('li');
                    li.classList.add('stop-list-item');
                    let stopLabel = "";
                    let timeLabel = "";

                    if (stop.type === 'start') {
                        stopLabel = `Inicio: ${stop.name}`;
                        timeLabel = `Sale: ${stop.departureTime || 'N/A'}`;
                    } else if (stop.type === 'end') {
                        stopLabel = `Fin: ${stop.name}`;
                        timeLabel = `Llega: ${stop.arrivalTime || 'N/A'}`;
                    } else { // intermediate
                        // Find its original index in currentRoute.intermediateStops
                        const intermediateIndex = currentRoute.intermediateStops.findIndex(s => s === stop);
                        stopLabel = `Parada ${intermediateIndex + 1}: ${stop.name}`;
                        timeLabel = `Llega/Sale: ${stop.arrivalTime || 'N/A'}`;
                        
                        const removeBtn = document.createElement('button');
                        removeBtn.textContent = 'X';
                        removeBtn.classList.add('remove-stop-btn');
                        removeBtn.onclick = () => removeIntermediateStop(intermediateIndex);
                        li.appendChild(removeBtn);
                    }
                    
                    const textSpan = document.createElement('span');
                    textSpan.textContent = `${stopLabel} (${timeLabel})`;
                    li.prepend(textSpan); // Prepend to have button on the right
                    ul.appendChild(li);
                });
                stopsListDiv.appendChild(ul);
            }

            function removeIntermediateStop(index) {
                currentRoute.intermediateStops.splice(index, 1);
                if (autoCalculateTimesCheckbox.checked) {
                    calculateAndSetIntermediateTimes();
                }
                drawCurrentRouteOnMap();
                updateStopsListDisplay();
            }
            
            function updateLoadRouteDropdown() {
                loadRouteSelect.innerHTML = '';
                Object.keys(savedRoutes).forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    loadRouteSelect.appendChild(option);
                });
            }

            function updateTrackingQueueDisplay() {
                trackingQueueListDiv.innerHTML = '';
                if (trackingQueue.length === 0) {
                    trackingQueueListDiv.textContent = "Vacía";
                    return;
                }
                const ol = document.createElement('ol');
                trackingQueue.forEach(routeName => {
                    const li = document.createElement('li');
                    li.textContent = routeName;
                    ol.appendChild(li);
                });
                trackingQueueListDiv.appendChild(ol);
            }

            // --- Route Management Logic ---
            function saveRoute() {
                const name = routeNameInput.value.trim();
                if (!name) {
                    alert("Por favor, ingresa un nombre para la ruta.");
                    return;
                }
                if (!currentRoute.startPoint || !currentRoute.endPoint) {
                    alert("La ruta debe tener al menos un punto de inicio y fin definidos.");
                    return;
                }
                if (autoCalculateTimesCheckbox.checked) { // Ensure times are calculated before saving
                    calculateAndSetIntermediateTimes();
                }

                // Validate all times exist if manual calculation
                if (!autoCalculateTimesCheckbox.checked) {
                    if (!currentRoute.startPoint.departureTime || !currentRoute.endPoint.arrivalTime) {
                         alert("Asegúrate que el punto de inicio y fin tengan horarios definidos.");
                         return;
                    }
                    for (const stop of currentRoute.intermediateStops) {
                        if (!stop.arrivalTime) {
                            alert(`La parada intermedia "${stop.name}" no tiene horario definido. Por favor, ingrésalo o activa el cálculo automático.`);
                            return;
                        }
                    }
                }


                if (savedRoutes[name] && !confirm(`La ruta "${name}" ya existe. ¿Deseas sobrescribirla?`)) {
                    return;
                }
                
                // Deep copy currentRoute to avoid issues if currentRoute is modified later
                const routeToSave = JSON.parse(JSON.stringify(currentRoute));
                routeToSave.name = name; // Ensure name is part of the saved object
                savedRoutes[name] = routeToSave;
                
                localStorage.setItem(LOCALSTORAGE_ROUTES_KEY, JSON.stringify(savedRoutes));
                updateLoadRouteDropdown();
                alert(`Ruta "${name}" guardada.`);
            }

            function loadRoute() {
                const name = loadRouteSelect.value;
                if (!name || !savedRoutes[name]) {
                    alert("Ruta no encontrada.");
                    return;
                }
                // Deep copy from savedRoutes to currentRoute
                currentRoute = JSON.parse(JSON.stringify(savedRoutes[name]));
                
                // Populate UI fields
                routeNameInput.value = currentRoute.name || "";
                startPointNameInput.value = currentRoute.startPoint.name || "";
                startPointTimeInput.value = currentRoute.startPoint.departureTime || "";
                endPointNameInput.value = currentRoute.endPoint.name || "";
                endPointTimeInput.value = currentRoute.endPoint.arrivalTime || "";
                
                // Assuming auto-calculate was used or times are valid
                // No need to re-check autoCalculateTimesCheckbox status on load for re-calculation
                // as saved times are what matters.

                drawCurrentRouteOnMap();
                updateStopsListDisplay();
                alert(`Ruta "${name}" cargada.`);
            }

            function deleteRoute() {
                const name = loadRouteSelect.value;
                if (!name || !savedRoutes[name]) {
                    alert("Selecciona una ruta para eliminar.");
                    return;
                }
                if (confirm(`¿Estás seguro de que deseas eliminar la ruta "${name}"?`)) {
                    delete savedRoutes[name];
                    localStorage.setItem(LOCALSTORAGE_ROUTES_KEY, JSON.stringify(savedRoutes));
                    updateLoadRouteDropdown();
                    alert(`Ruta "${name}" eliminada.`);
                }
            }

            // --- Tracking Queue Logic ---
            function addToTrackingQueue() {
                const selectedRouteName = loadRouteSelect.value;
                if (!selectedRouteName || !savedRoutes[selectedRouteName]) {
                     // Try to use currentRoute.name if it's set and valid
                    if (currentRoute.name && savedRoutes[currentRoute.name]) {
                         if (!trackingQueue.includes(currentRoute.name)) {
                            trackingQueue.push(currentRoute.name);
                            updateTrackingQueueDisplay();
                        } else {
                            alert(`La ruta "${currentRoute.name}" ya está en la cola.`);
                        }
                    } else {
                        alert("Carga o selecciona una ruta válida para añadir a la cola.");
                    }
                    return;
                }
                
                if (!trackingQueue.includes(selectedRouteName)) {
                    trackingQueue.push(selectedRouteName);
                    updateTrackingQueueDisplay();
                } else {
                    alert(`La ruta "${selectedRouteName}" ya está en la cola.`);
                }
            }

            function clearTrackingQueue() {
                if (confirm("¿Limpiar toda la cola de seguimiento?")) {
                    trackingQueue = [];
                    updateTrackingQueueDisplay();
                }
            }

            // --- Tracking Logic ---
            function startTracking() {
                if (isTracking) {
                    alert("El seguimiento ya está activo.");
                    return;
                }
                if (trackingQueue.length === 0) {
                    alert("La cola de seguimiento está vacía. Añade rutas primero.");
                    return;
                }
                if (!navigator.geolocation) {
                    logError("Geolocalización no es soportada por este navegador.");
                    return;
                }

                isTracking = true;
                startTrackingBtn.disabled = true;
                stopTrackingBtn.disabled = false;
                manualControlCheckbox.disabled = true; // Disable mode change during tracking for now

                loadNextRouteFromQueueForTracking();

                watchId = navigator.geolocation.watchPosition(
                    onPositionUpdate,
                    onPositionError,
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                );

                // Start periodic updates to localStorage
                trackingStatusUpdateInterval = setInterval(updateTrackingStatusToLocalStorage, 3000); // Every 3s
                timeDifferenceUpdateInterval = setInterval(updateTimeDifferenceAndNextStopDisplay, 1000); // Every 1s
            }

            function stopTracking(reason = "Detenido por el usuario") {
                if (!isTracking) return;

                isTracking = false;
                if (watchId) navigator.geolocation.clearWatch(watchId);
                watchId = null;
                
                clearInterval(trackingStatusUpdateInterval);
                trackingStatusUpdateInterval = null;
                clearInterval(timeDifferenceUpdateInterval);
                timeDifferenceUpdateInterval = null;

                activeRouteDetails = null;
                currentTrackingStopIndex = -1;
                actualDepartureTimeOfCurrentLegStart = null;

                startTrackingBtn.disabled = false;
                stopTrackingBtn.disabled = true;
                manualControlCheckbox.disabled = false;

                if (currentUserPositionMarker) {
                    currentUserPositionMarker.remove();
                    currentUserPositionMarker = null;
                }
                geofenceLayerGroup.clearLayers();
                // Optionally, clear route drawing or revert to editor view
                // drawCurrentRouteOnMap(); // Re-draw editor route

                trackingStatusDiv.textContent = `Estado: Inactivo (${reason})`;
                nextStopInfoDiv.textContent = "Próxima parada: N/A";
                updateTrackingStatusToLocalStorage(); // Send final "isTracking: false"
                console.log("Seguimiento detenido:", reason);
            }
            
            function loadNextRouteFromQueueForTracking() {
                if (trackingQueue.length === 0) {
                    stopTracking("Cola de seguimiento completada.");
                    return;
                }
                const routeName = trackingQueue.shift(); // Get and remove first route
                updateTrackingQueueDisplay();

                if (!savedRoutes[routeName]) {
                    logError(`Ruta "${routeName}" no encontrada en rutas guardadas. Saltando.`);
                    loadNextRouteFromQueueForTracking(); // Try next one
                    return;
                }
                activeRouteDetails = JSON.parse(JSON.stringify(savedRoutes[routeName])); // Deep copy
                currentTrackingStopIndex = -1; // Reset to start of new route
                actualDepartureTimeOfCurrentLegStart = null; // Will be set when moving from start or stop

                console.log(`Iniciando seguimiento para ruta: ${activeRouteDetails.name}`);
                trackingStatusDiv.textContent = `Siguiendo: ${activeRouteDetails.name}`;
                
                drawCurrentRouteOnMap(activeRouteDetails, 'green');
                drawGeofencesForActiveRoute();
                updateTimeDifferenceAndNextStopDisplay(); // Initial display for new route
                updateTrackingStatusToLocalStorage();
            }
            
            function drawGeofencesForActiveRoute() {
                geofenceLayerGroup.clearLayers();
                if (!activeRouteDetails) return;

                if (activeRouteDetails.startPoint) {
                    L.circle([activeRouteDetails.startPoint.lat, activeRouteDetails.startPoint.lng], {
                        radius: GEOFENCE_RADIUS_METERS,
                        color: 'orange',
                        fillColor: 'orange',
                        fillOpacity: 0.2
                    }).addTo(geofenceLayerGroup);
                }
                if (activeRouteDetails.endPoint) {
                     L.circle([activeRouteDetails.endPoint.lat, activeRouteDetails.endPoint.lng], {
                        radius: GEOFENCE_RADIUS_METERS,
                        color: 'red',
                        fillColor: 'red',
                        fillOpacity: 0.2
                    }).addTo(geofenceLayerGroup);
                }
            }

            function onPositionUpdate(position) {
                const { latitude, longitude, accuracy } = position.coords;
                // console.log(`Pos: ${latitude}, ${longitude}, Acc: ${accuracy}m`);

                if (!currentUserPositionMarker) {
                    currentUserPositionMarker = L.circleMarker([latitude, longitude], {
                        radius: 8,
                        color: 'blue',
                        fillColor: '#3388ff',
                        fillOpacity: 0.8
                    }).addTo(map);
                } else {
                    currentUserPositionMarker.setLatLng([latitude, longitude]);
                }
                // map.panTo([latitude, longitude]); // Option: keep user centered

                if (isTracking && activeRouteDetails && !manualControlCheckbox.checked) {
                    checkProximityAndAdvance(latitude, longitude);
                }
                // updateTrackingStatusToLocalStorage() is called by its interval
                // updateTimeDifferenceAndNextStopDisplay() is called by its interval
            }

            function onPositionError(error) {
                let message = "";
                switch (error.code) {
                    case error.PERMISSION_DENIED:
                        message = "Usuario denegó la solicitud de Geolocalización.";
                        stopTracking(message);
                        break;
                    case error.POSITION_UNAVAILABLE:
                        message = "Información de ubicación no disponible.";
                        break;
                    case error.TIMEOUT:
                        message = "Se agotó el tiempo de espera para obtener la ubicación del usuario.";
                        break;
                    default:
                        message = "Error desconocido de Geolocalización.";
                        break;
                }
                logError(message);
                // Don't stop tracking for transient errors like TIMEOUT or UNAVAILABLE
                // updateTrackingStatusToLocalStorage will reflect hasError
            }

            function checkProximityAndAdvance(currentLat, currentLng) {
                if (!isTracking || !activeRouteDetails || manualControlCheckbox.checked) return;

                const allStops = [activeRouteDetails.startPoint, ...activeRouteDetails.intermediateStops, activeRouteDetails.endPoint];

                // 1. Check if leaving Start Geofence (if at start)
                if (currentTrackingStopIndex === -1) {
                    const distToStart = calculateDistance(currentLat, currentLng, activeRouteDetails.startPoint.lat, activeRouteDetails.startPoint.lng);
                    if (distToStart > GEOFENCE_RADIUS_METERS) {
                        console.log("Salió del geofence de inicio.");
                        currentTrackingStopIndex = 0; // Moved to first leg
                        actualDepartureTimeOfCurrentLegStart = Date.now();
                        updateTimeDifferenceAndNextStopDisplay();
                        updateTrackingStatusToLocalStorage();
                        // No need to draw geofence for next stop, only start/end of route.
                    }
                    return; // Wait until out of start geofence
                }

                // 2. Check if entering End Geofence
                const distToEnd = calculateDistance(currentLat, currentLng, activeRouteDetails.endPoint.lat, activeRouteDetails.endPoint.lng);
                if (distToEnd <= GEOFENCE_RADIUS_METERS) {
                    console.log("Entró al geofence de fin de ruta.");
                    currentTrackingStopIndex = allStops.length -1; // Mark as arrived at end
                    // actualDepartureTimeOfCurrentLegStart remains from last leg
                    updateTimeDifferenceAndNextStopDisplay();
                    updateTrackingStatusToLocalStorage(); // Store final status for this route
                    loadNextRouteFromQueueForTracking(); // This will reset state for the new route
                    return;
                }
                
                // 3. Check proximity to next intermediate stop
                // nextStopIndex is currentTrackingStopIndex + 1
                const nextStopLogicalIndex = currentTrackingStopIndex + 1;
                if (nextStopLogicalIndex < allStops.length -1) { // If next stop is not the end point
                    const nextIntermediateStop = allStops[nextStopLogicalIndex];
                    const distToNextIntermediate = calculateDistance(currentLat, currentLng, nextIntermediateStop.lat, nextIntermediateStop.lng);

                    if (distToNextIntermediate <= PROXIMITY_THRESHOLD_METERS) {
                        console.log(`Llegó a la parada intermedia: ${nextIntermediateStop.name}`);
                        currentTrackingStopIndex = nextStopLogicalIndex; // Now "departed" from this intermediate stop
                        actualDepartureTimeOfCurrentLegStart = Date.now();
                        updateTimeDifferenceAndNextStopDisplay();
                        updateTrackingStatusToLocalStorage();
                    }
                }
            }
            
            function findAndSetCurrentLeg() {
                if (!isTracking || !activeRouteDetails || !currentUserPositionMarker) {
                    console.warn("findAndSetCurrentLeg: No se puede ejecutar, tracking inactivo o sin posición.");
                    return;
                }

                const currentPos = currentUserPositionMarker.getLatLng();
                const allStops = [activeRouteDetails.startPoint, ...activeRouteDetails.intermediateStops, activeRouteDetails.endPoint];
                
                let closestStopIndex = -1;
                let minDistance = Infinity;

                allStops.forEach((stop, index) => {
                    const dist = calculateDistance(currentPos.lat, currentPos.lng, stop.lat, stop.lng);
                    if (dist < minDistance) {
                        minDistance = dist;
                        closestStopIndex = index;
                    }
                });

                if (closestStopIndex !== -1) {
                    console.log(`findAndSetCurrentLeg: Parada más cercana es ${allStops[closestStopIndex].name} (índice ${closestStopIndex}).`);
                    // We set currentTrackingStopIndex to the stop *before* the closest one,
                    // implying we are heading *towards* the closestStop.
                    currentTrackingStopIndex = closestStopIndex -1; 
                    // If closest is start point (index 0), currentTrackingStopIndex becomes -1 (correct).
                    actualDepartureTimeOfCurrentLegStart = Date.now(); // Assume we just "started" this leg for timing.
                    
                    console.log(`Re-sincronizado: currentTrackingStopIndex a ${currentTrackingStopIndex}.`);
                    updateTimeDifferenceAndNextStopDisplay();
                    updateTrackingStatusToLocalStorage();

                    // Immediately check if we are already within proximity of the "new" next stop
                    if (!manualControlCheckbox.checked) {
                         checkProximityAndAdvance(currentPos.lat, currentPos.lng);
                    }
                } else {
                    console.warn("findAndSetCurrentLeg: No se pudo encontrar una parada cercana.");
                }
            }

            function calculateCurrentBusDelayOrAheadMillis() {
                if (!isTracking || !activeRouteDetails || !currentUserPositionMarker) return null;

                const currentTime = Date.now();
                const currentPos = currentUserPositionMarker.getLatLng();
                const allStops = [activeRouteDetails.startPoint, ...activeRouteDetails.intermediateStops, activeRouteDetails.endPoint];

                if (currentTrackingStopIndex === -1) { // At Start Point (or before official departure)
                    const scheduledDepartureTime = parseHHMMToDate(activeRouteDetails.startPoint.departureTime);
                    if (!scheduledDepartureTime) return null;
                    return scheduledDepartureTime.getTime() - currentTime; // Positive if ahead (can wait), negative if late
                }

                // En Route
                if (currentTrackingStopIndex >= allStops.length - 1) { // Arrived at last stop or beyond
                    // Calculate delay based on arrival at the final stop
                    const finalStop = allStops[allStops.length -1];
                    const scheduledArrivalAtFinal = parseHHMMToDate(finalStop.arrivalTime);
                    if (!scheduledArrivalAtFinal) return null;
                    // If actualDepartureTimeOfCurrentLegStart holds the time we *entered* the leg towards final stop...
                    // This gets tricky. Simpler: if at final stop, delay is vs scheduled arrival.
                    // For simplicity, if past final stop, we don't calculate delay.
                    // During tracking, this case means we arrived at the last stop.
                    // The "delay" would be based on the scheduled arrival time of the last stop.
                    // Let's assume for "en route" we are always between two stops.
                    // When currentTrackingStopIndex becomes allStops.length - 1, it means we *arrived* at the last stop.
                    // The delay at that point is `scheduled_arrival_at_last_stop - current_time`.
                    // This function is usually called when *between* stops.
                    return null; // Or handle specifically if needed
                }

                const departedStop = allStops[currentTrackingStopIndex];
                const nextTargetStop = allStops[currentTrackingStopIndex + 1];

                const scheduledDepartureFromDeparted = parseHHMMToDate(departedStop.departureTime);
                const scheduledArrivalAtNextTarget = parseHHMMToDate(nextTargetStop.arrivalTime);

                if (!scheduledDepartureFromDeparted || !scheduledArrivalAtNextTarget || scheduledArrivalAtNextTarget <= scheduledDepartureFromDeparted) {
                    console.warn("Horarios de tramo inválidos para cálculo de adelanto/atraso.");
                    return null;
                }

                const scheduledLegDuration = scheduledArrivalAtNextTarget.getTime() - scheduledDepartureFromDeparted.getTime();
                
                const distanceTravelledOnLeg = calculateDistance(departedStop.lat, departedStop.lng, currentPos.lat, currentPos.lng);
                const totalLegDistance = calculateDistance(departedStop.lat, departedStop.lng, nextTargetStop.lat, nextTargetStop.lng);

                let proportionOfLegCovered = 0;
                if (totalLegDistance > 0) {
                    proportionOfLegCovered = Math.min(1, Math.max(0, distanceTravelledOnLeg / totalLegDistance));
                }
                
                const timeThatShouldHaveElapsedOnLegAccordingToSchedule = proportionOfLegCovered * scheduledLegDuration;
                const expectedTimeAtCurrentPositionOnSchedule = scheduledDepartureFromDeparted.getTime() + timeThatShouldHaveElapsedOnLegAccordingToSchedule;
                
                return expectedTimeAtCurrentPositionOnSchedule - currentTime; // Positive if ahead, negative if delayed
            }

            function updateTimeDifferenceAndNextStopDisplay() {
                if (!isTracking || !activeRouteDetails) {
                    trackingStatusDiv.textContent = "Estado: Inactivo";
                    nextStopInfoDiv.textContent = "Próxima parada: N/A";
                    return;
                }

                const delayMs = calculateCurrentBusDelayOrAheadMillis();
                const delayFormatted = formatDelay(delayMs);
                trackingStatusDiv.innerHTML = `Siguiendo: ${activeRouteDetails.name}<br>Diferencia Horaria: <b>${delayFormatted}</b>`;

                const allStops = [activeRouteDetails.startPoint, ...activeRouteDetails.intermediateStops, activeRouteDetails.endPoint];
                let nextStopText = "N/A";

                if (currentTrackingStopIndex === -1) { // At start
                    nextStopText = `Salida de ${activeRouteDetails.startPoint.name} a las ${activeRouteDetails.startPoint.departureTime}`;
                } else if (currentTrackingStopIndex < allStops.length - 1) {
                    const nextStop = allStops[currentTrackingStopIndex + 1];
                    let label = "";
                    if (nextStop.type === 'intermediate') {
                         // Find its original index in activeRouteDetails.intermediateStops for correct numbering
                        const intermediateIdx = activeRouteDetails.intermediateStops.findIndex(s => s.lat === nextStop.lat && s.lng === nextStop.lng);
                        label = `Parada ${intermediateIdx + 1}: ${nextStop.name}`;
                    } else { // end
                        label = `Fin: ${nextStop.name}`;
                    }
                    nextStopText = `Próxima: ${label} (prog. ${nextStop.arrivalTime})`;
                } else { // Arrived at last stop or completed
                    nextStopText = "Ruta completada. Esperando próxima ruta en cola.";
                }
                nextStopInfoDiv.textContent = nextStopText;
            }
            
            function updateTrackingStatusToLocalStorage() {
                let statusPayload = {
                    isTracking: isTracking,
                    hasError: false, // Basic implementation, could be enhanced
                    errorReason: "",
                    lastUpdateTime: Date.now()
                };

                if (isTracking && activeRouteDetails) {
                    const allStopsFlat = [activeRouteDetails.startPoint, ...activeRouteDetails.intermediateStops, activeRouteDetails.endPoint]
                        .map((stop, index) => {
                            let name = stop.name;
                            let type = stop.type;
                            // Ensure names for start/end points from route definition are used
                            if (type === 'start') name = activeRouteDetails.startPoint.name;
                            if (type === 'end') name = activeRouteDetails.endPoint.name;
                            
                            // For intermediate stops, ensure consistent naming if not user-defined
                            if (type === 'intermediate' && (!name || name.startsWith("Parada "))) {
                                const intermediateIdx = activeRouteDetails.intermediateStops.findIndex(s => s.lat === stop.lat && s.lng === stop.lng);
                                name = `Parada ${intermediateIdx + 1}`;
                            }

                            return {
                                name: name,
                                type: type,
                                arrivalTime: stop.arrivalTime || null, // HH:MM string
                                departureTime: stop.departureTime || null, // HH:MM string
                                lat: stop.lat,
                                lng: stop.lng
                            };
                        });
                    
                    statusPayload = {
                        ...statusPayload,
                        routeName: activeRouteDetails.name,
                        currentRouteIndexInQueue: trackingQueue.indexOf(activeRouteDetails.name), // This might be -1 if it was just popped
                        trackingQueueNames: [activeRouteDetails.name, ...trackingQueue], // Current + remaining
                        currentStopIndexFromWhichDeparted: currentTrackingStopIndex, // -1 for start, 0 for 1st interm., etc.
                        nextStopIndexTowardsWhichHeading: (currentTrackingStopIndex < allStopsFlat.length - 1) ? currentTrackingStopIndex + 1 : -1, // -1 if at/after last stop
                        currentBusDelayOrAheadMillis: calculateCurrentBusDelayOrAheadMillis(), // Positive if ahead
                        lastKnownPosition: currentUserPositionMarker ? currentUserPositionMarker.getLatLng() : null,
                        routeStops: allStopsFlat
                    };
                } else if (!isTracking) {
                     // Clear specific fields when not tracking or explicitly set isTracking to false
                     statusPayload.routeName = null;
                     statusPayload.routeStops = [];
                }
                
                try {
                    localStorage.setItem(LOCALSTORAGE_TRACKING_STATUS_KEY, JSON.stringify(statusPayload));
                } catch (e) {
                    logError("Error guardando estado en localStorage: " + e.message);
                }
            }


            // --- Manual Control Logic ---
            manualControlCheckbox.addEventListener('change', () => {
                const isManual = manualControlCheckbox.checked;
                manualNavButtonsDiv.style.display = isManual ? 'block' : 'none';
                if (isTracking) {
                    if (!isManual) { // Switched from Manual to Auto
                        console.log("Cambiado a modo Automático. Resincronizando...");
                        findAndSetCurrentLeg();
                    } else {
                        console.log("Cambiado a modo Manual.");
                    }
                }
            });

            prevStopBtn.addEventListener('click', () => {
                if (!isTracking || !activeRouteDetails || !manualControlCheckbox.checked) return;
                const allStops = [activeRouteDetails.startPoint, ...activeRouteDetails.intermediateStops, activeRouteDetails.endPoint];

                if (currentTrackingStopIndex > -1) {
                    currentTrackingStopIndex--;
                    // actualDepartureTimeOfCurrentLegStart = Date.now(); // Or keep previous if just correcting
                    console.log(`Manual: Parada Anterior. Nuevo currentTrackingStopIndex: ${currentTrackingStopIndex}`);
                    updateTimeDifferenceAndNextStopDisplay();
                    updateTrackingStatusToLocalStorage();
                } else {
                    console.log("Manual: Ya en el punto de inicio.");
                }
            });

            nextStopBtn.addEventListener('click', () => {
                if (!isTracking || !activeRouteDetails || !manualControlCheckbox.checked) return;
                const allStops = [activeRouteDetails.startPoint, ...activeRouteDetails.intermediateStops, activeRouteDetails.endPoint];

                if (currentTrackingStopIndex < allStops.length - 2) { // Not yet at the stop before the last one
                    currentTrackingStopIndex++;
                    actualDepartureTimeOfCurrentLegStart = Date.now();
                    console.log(`Manual: Parada Siguiente. Nuevo currentTrackingStopIndex: ${currentTrackingStopIndex}`);
                    updateTimeDifferenceAndNextStopDisplay();
                    updateTrackingStatusToLocalStorage();
                } else if (currentTrackingStopIndex === allStops.length - 2) { // At the stop before the last, moving to last
                    currentTrackingStopIndex++; // Arrived at last stop
                    actualDepartureTimeOfCurrentLegStart = Date.now();
                    console.log(`Manual: Llegado a la última parada ${allStops[currentTrackingStopIndex].name}.`);
                    updateTimeDifferenceAndNextStopDisplay();
                    updateTrackingStatusToLocalStorage();
                    // User must click again to go to next route
                } else if (currentTrackingStopIndex === allStops.length - 1) { // Already at the last stop
                    console.log("Manual: En la última parada. Intentando cargar próxima ruta.");
                    loadNextRouteFromQueueForTracking();
                }
            });

            // --- Event Listeners ---
            setStartPointBtn.addEventListener('click', () => definePointOnMap('start'));
            setEndPointBtn.addEventListener('click', () => definePointOnMap('end'));
            
            startPointNameInput.addEventListener('change', () => {
                if (currentRoute.startPoint) currentRoute.startPoint.name = startPointNameInput.value || "Inicio";
                updateStopsListDisplay();
            });
            endPointNameInput.addEventListener('change', () => {
                if (currentRoute.endPoint) currentRoute.endPoint.name = endPointNameInput.value || "Fin";
                updateStopsListDisplay();
            });
             startPointTimeInput.addEventListener('change', () => {
                if (currentRoute.startPoint) currentRoute.startPoint.departureTime = startPointTimeInput.value;
                if (autoCalculateTimesCheckbox.checked) calculateAndSetIntermediateTimes();
                updateStopsListDisplay();
            });
            endPointTimeInput.addEventListener('change', () => {
                if (currentRoute.endPoint) currentRoute.endPoint.arrivalTime = endPointTimeInput.value;
                if (autoCalculateTimesCheckbox.checked) calculateAndSetIntermediateTimes();
                updateStopsListDisplay();
            });
            autoCalculateTimesCheckbox.addEventListener('change', () => {
                if (autoCalculateTimesCheckbox.checked) {
                    calculateAndSetIntermediateTimes();
                }
                updateStopsListDisplay(); // Always update, as display might change (e.g. show 'N/A' if unchecked)
            });


            saveRouteBtn.addEventListener('click', saveRoute);
            loadRouteBtn.addEventListener('click', loadRoute);
            deleteRouteBtn.addEventListener('click', deleteRoute);

            addToQueueBtn.addEventListener('click', addToTrackingQueue);
            clearQueueBtn.addEventListener('click', clearTrackingQueue);

            startTrackingBtn.addEventListener('click', startTracking);
            stopTrackingBtn.addEventListener('click', () => stopTracking("Detenido manualmente por el usuario"));


            // --- Initialization ---
            function initApp() {
                initMap();
                
                const storedRoutes = localStorage.getItem(LOCALSTORAGE_ROUTES_KEY);
                if (storedRoutes) {
                    savedRoutes = JSON.parse(storedRoutes);
                    updateLoadRouteDropdown();
                }
                // Clear any stale tracking status from previous sessions
                localStorage.removeItem(LOCALSTORAGE_TRACKING_STATUS_KEY); 
                updateTrackingStatusToLocalStorage(); // Set initial isTracking: false

                updateStopsListDisplay();
                updateTrackingQueueDisplay();
                mapClickHandlerEnabled = true; // Enable map clicks for stops after initial setup
            }

            document.addEventListener('DOMContentLoaded', initApp);

        })();
    </script>
</body>
</html>
