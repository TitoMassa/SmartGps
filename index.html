<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <style>
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent body scroll, individual sections will scroll */
        }
        #map {
            height: 50vh; /* 50% of viewport height */
            width: 100%;
            background-color: #333; /* Placeholder color for map area */
        }
        #controls {
            height: 50vh; /* 50% of viewport height */
            width: 100%;
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        .control-section {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #555;
            border-radius: 5px;
        }
        .control-section h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #4CAF50; /* Accent color for headings */
        }
        button, input[type="text"], input[type="time"], select {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 1em;
        }
        button {
            cursor: pointer;
            background-color: #007bff;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.danger {
            background-color: #dc3545;
        }
        button.danger:hover {
            background-color: #c82333;
        }
        #stopsList li, #savedRoutesList li, #routeQueueDisplay li {
            background-color: #222;
            padding: 5px;
            margin-bottom: 3px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        #statusDisplay {
            font-size: 1.1em;
            padding: 10px;
            background-color: #1a1a1a;
            border-radius: 5px;
        }
        .adelantado { color: #4CAF50; /* Green */ }
        .atrasado { color: #F44336; /* Red */ }
        .a-tiempo { color: #FFFFFF; }

        /* Leaflet custom icons */
        .leaflet-div-icon {
            background: transparent;
            border: none;
        }
        .custom-icon-text {
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            line-height: 20px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            color: white;
        }
        #currentLocationMarker {
            background-color: blue;
            border-radius: 50%;
            width: 15px;
            height: 15px;
            border: 2px solid white;
        }
        .tabs {
            display: flex;
            margin-bottom: 10px;
        }
        .tab-button {
            flex-grow: 1;
            padding: 10px;
            background-color: #222;
            border: 1px solid #444;
            border-bottom: none;
            cursor: pointer;
        }
        .tab-button.active {
            background-color: #000;
            border-bottom: 1px solid #000;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <div id="controls">
        <div class="tabs">
            <button class="tab-button active" onclick="openTab('crearRutaTab')">Crear/Ver Ruta</button>
            <button class="tab-button" onclick="openTab('gestionRutasTab')">Gestión Rutas</button>
            <button class="tab-button" onclick="openTab('seguimientoTab')">Seguimiento</button>
        </div>

        <div id="crearRutaTab" class="tab-content active">
            <div class="control-section">
                <h3>Crear Ruta <small id="mapClickInstruction">(Toque el mapa para agregar paradas)</small></h3>
                <p id="currentAddingStopType">Modo: Esperando Inicio</p>
                <input type="text" id="stopName" placeholder="Nombre Parada (opcional)">
                <input type="time" id="stopTime">
                <button onclick="finishStopDefinition()">Confirmar Parada</button>
                <button onclick="cancelAddStop()">Cancelar Añadir Parada</button>
                <br>
                <label for="autoCalcTimes">
                    <input type="checkbox" id="autoCalcTimes" checked> Calcular horarios intermedios automáticamente
                </label>
                <button onclick="finalizeRouteStops()">Finalizar Definición de Paradas</button>
                 <button onclick="clearCurrentRoute()">Limpiar Ruta Actual</button>
            </div>

            <div class="control-section">
                <h3>Paradas de la Ruta Actual</h3>
                <ul id="stopsList"></ul>
            </div>
        </div>

        <div id="gestionRutasTab" class="tab-content">
            <div class="control-section">
                <h3>Guardar Ruta Actual</h3>
                <input type="text" id="routeName" placeholder="Nombre para guardar la ruta">
                <button onclick="saveCurrentRoute()">Guardar Ruta</button>
            </div>

            <div class="control-section">
                <h3>Cargar/Borrar Rutas Guardadas</h3>
                <select id="savedRoutesSelect"></select>
                <button onclick="loadSelectedRoute()">Cargar Ruta</button>
                <button onclick="deleteSelectedRoute()" class="danger">Borrar Ruta</button>
            </div>
             <div class="control-section">
                <h3>Cola de Rutas</h3>
                <select id="routeToQueueSelect"></select>
                <button onclick="addRouteToQueue()">Añadir a Cola</button>
                <ul id="routeQueueDisplay"></ul>
                <button onclick="clearRouteQueue()">Limpiar Cola</button>
            </div>
        </div>
        
        <div id="seguimientoTab" class="tab-content">
            <div class="control-section">
                <h3>Seguimiento en Tiempo Real</h3>
                <button onclick="startTracking()" id="startTrackingBtn">Iniciar Seguimiento</button>
                <button onclick="stopTracking()" id="stopTrackingBtn" disabled>Detener Seguimiento</button>
                <br>
                <label for="manualAdvanceCheckbox">
                    <input type="checkbox" id="manualAdvanceCheckbox" onchange="toggleManualAdvance(this.checked)"> Avance Manual
                </label>
                <button onclick="manualAdvanceStop('prev')" id="prevStopBtn" disabled>Parada Anterior</button>
                <button onclick="manualAdvanceStop('next')" id="nextStopBtn" disabled>Siguiente Parada</button>
            </div>

            <div id="statusDisplay" class="control-section">
                <p>Velocidad: <span id="speed">--</span> km/h</p>
                <p>Próxima Parada: <span id="nextStopInfo">--</span></p>
                <p>Desvío Horario: <span id="timeDeviation" class="a-tiempo">00:00</span></p>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <script>
        let map;
        let currentRoute = {
            name: '',
            stops: [], // {latlng, name, type: 'inicio'/'intermedia'/'final', scheduledTime (Date obj), originalTimeInput: "HH:MM"}
            polyline: null,
            markers: []
        };
        let addingStopState = 'inicio'; // 'inicio', 'final', 'intermedia', 'done'
        let tempStopData = null; // {latlng, type}

        let trackingState = {
            isActive: false,
            watchId: null,
            currentPositionMarker: null,
            lastPosition: null,
            currentSegmentStartIndex: -1, // Index of the stop we *departed from* or start
            nextStopIndex: 0,      // Index of the stop we are *heading to*
            manualAdvance: false
        };
        
        let routeQueue = []; // Array of route objects

        const CACHE_PREFIX = 'smartMovePro_route_';
        const CACHE_QUEUE_KEY = 'smartMovePro_routeQueue';

        // --- UI Tabs ---
        function openTab(tabName) {
            let i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
                tabcontent[i].classList.remove("active");
            }
            tablinks = document.getElementsByClassName("tab-button");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].classList.remove("active");
            }
            document.getElementById(tabName).style.display = "block";
            document.getElementById(tabName).classList.add("active");
            event.currentTarget.classList.add("active");
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', function () {
            initializeMap();
            loadRoutesFromCache();
            loadRouteQueueFromCache();
            updateStopAddingUI();

            // Set default tab
            openTab('crearRutaTab');
            document.querySelector('.tab-button').classList.add('active'); // First tab active
        });

        function initializeMap() {
            map = L.map('map').setView([-34.6037, -58.3816], 13); // Buenos Aires
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            map.on('click', onMapClick);
            
            // Attempt to get current location for initial view
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    map.setView([position.coords.latitude, position.coords.longitude], 15);
                }, () => {
                    console.warn("Error getting initial location.");
                });
            }
        }
        
        function updateStopAddingUI() {
            const instructionEl = document.getElementById('mapClickInstruction');
            const currentAddingEl = document.getElementById('currentAddingStopType');
            const stopTimeInput = document.getElementById('stopTime');
            
            stopTimeInput.required = false; // Default

            switch (addingStopState) {
                case 'inicio':
                    currentAddingEl.textContent = 'Modo: Esperando Inicio (obligatorio horario)';
                    stopTimeInput.required = true;
                    break;
                case 'final':
                    currentAddingEl.textContent = 'Modo: Esperando Final (obligatorio horario)';
                    stopTimeInput.required = true;
                    break;
                case 'intermedia':
                    currentAddingEl.textContent = 'Modo: Añadiendo Parada Intermedia (horario opcional)';
                    stopTimeInput.required = !document.getElementById('autoCalcTimes').checked;
                    break;
                case 'confirm_stop':
                     currentAddingEl.textContent = `Confirmar ${tempStopData.type === 'inicio' ? 'Inicio' : tempStopData.type === 'final' ? 'Final' : 'Parada Intermedia'}`;
                     instructionEl.textContent = "Complete detalles y confirme.";
                     break;
                case 'done':
                    currentAddingEl.textContent = 'Modo: Paradas definidas. Puede guardar o iniciar seguimiento.';
                    instructionEl.textContent = "";
                    break;
            }
        }

        function onMapClick(e) {
            if (addingStopState === 'done' || addingStopState === 'confirm_stop') {
                alert('Primero finalice la definición de paradas o confirme la parada actual.');
                return;
            }
            
            tempStopData = { latlng: e.latlng, type: addingStopState };
            document.getElementById('stopName').value = '';
            document.getElementById('stopTime').value = '';
            
            addingStopState = 'confirm_stop';
            updateStopAddingUI();
            
            // Show stop name/time inputs more prominently if hidden or provide modal
            alert(`Toque en el mapa para ${tempStopData.type}. Ahora ingrese nombre y hora si es necesario.`);
        }
        
        function finishStopDefinition() {
            if (addingStopState !== 'confirm_stop' || !tempStopData) {
                alert("Primero toque el mapa para elegir una ubicación.");
                return;
            }

            const name = document.getElementById('stopName').value || `${tempStopData.type} ${currentRoute.stops.filter(s => s.type === tempStopData.type).length + 1}`;
            const timeInput = document.getElementById('stopTime').value;
            let scheduledTime = null;

            if (tempStopData.type === 'inicio' || tempStopData.type === 'final') {
                if (!timeInput) {
                    alert('El horario es obligatorio para Inicio y Final.');
                    return;
                }
                scheduledTime = parseTimeInput(timeInput);
            } else if (tempStopData.type === 'intermedia') {
                if (timeInput) {
                    scheduledTime = parseTimeInput(timeInput);
                } else if (!document.getElementById('autoCalcTimes').checked) {
                    alert('Ingrese horario para parada intermedia o active cálculo automático.');
                    return;
                }
            }

            const newStop = {
                latlng: tempStopData.latlng,
                name: name,
                type: tempStopData.type,
                scheduledTime: scheduledTime,
                originalTimeInput: timeInput // Store for saving
            };

            // Logic for adding stops in order: inicio -> final -> intermedias
            if (newStop.type === 'inicio') {
                if (currentRoute.stops.find(s => s.type === 'inicio')) {
                    alert('Ya existe una parada de Inicio.');
                    addingStopState = tempStopData.type; // Revert to allow re-picking
                    tempStopData = null;
                    updateStopAddingUI();
                    return;
                }
                currentRoute.stops.unshift(newStop); // Add to beginning
                addingStopState = 'final';
            } else if (newStop.type === 'final') {
                 if (currentRoute.stops.find(s => s.type === 'final')) {
                    alert('Ya existe una parada Final.');
                    addingStopState = tempStopData.type;
                    tempStopData = null;
                    updateStopAddingUI();
                    return;
                }
                // Ensure 'inicio' exists before 'final'
                const inicioIndex = currentRoute.stops.findIndex(s => s.type === 'inicio');
                if (inicioIndex === -1) {
                    alert('Debe agregar una parada de Inicio primero.');
                    addingStopState = 'inicio'; // Force back to inicio
                    tempStopData = null;
                    updateStopAddingUI();
                    return;
                }
                currentRoute.stops.push(newStop); // Add to end
                addingStopState = 'intermedia';
            } else if (newStop.type === 'intermedia') {
                const finalIndex = currentRoute.stops.findIndex(s => s.type === 'final');
                if (finalIndex !== -1) {
                    currentRoute.stops.splice(finalIndex, 0, newStop); // Insert before final
                } else {
                    currentRoute.stops.push(newStop); // Or at the end if no final yet (should not happen with state flow)
                }
                // Stays in 'intermedia' state to add more
            }
            
            tempStopData = null;
            renderCurrentRoute();
            updateStopAddingUI();
        }

        function cancelAddStop() {
            if (addingStopState === 'confirm_stop' && tempStopData) {
                addingStopState = tempStopData.type; // Go back to the state before clicking map
                tempStopData = null;
                updateStopAddingUI();
            } else {
                 // If not confirming a stop, maybe reset to 'inicio' if route is empty
                if (currentRoute.stops.length === 0) addingStopState = 'inicio';
                updateStopAddingUI();
            }
        }

        function finalizeRouteStops() {
            const hasInicio = currentRoute.stops.find(s => s.type === 'inicio');
            const hasFinal = currentRoute.stops.find(s => s.type === 'final');

            if (!hasInicio || !hasFinal) {
                alert('Debe definir una parada de Inicio y una de Final.');
                return;
            }
            addingStopState = 'done';
            autoCalculateIntermediateTimesIfNeeded();
            renderCurrentRoute(); // Re-render to show calculated times
            updateStopAddingUI();
            alert('Definición de paradas finalizada.');
        }

        function parseTimeInput(timeStr) { // "HH:MM"
            if (!timeStr) return null;
            const [hours, minutes] = timeStr.split(':').map(Number);
            const date = new Date();
            date.setHours(hours, minutes, 0, 0);
            return date;
        }

        function formatTime(dateObj) {
            if (!dateObj) return "--:--";
            return dateObj.toTimeString().substring(0, 5);
        }
        
        function autoCalculateIntermediateTimesIfNeeded() {
            if (!document.getElementById('autoCalcTimes').checked) return;

            const inicioStop = currentRoute.stops.find(s => s.type === 'inicio');
            const finalStop = currentRoute.stops.find(s => s.type === 'final');

            if (!inicioStop || !finalStop || !inicioStop.scheduledTime || !finalStop.scheduledTime) {
                console.warn("Inicio/Final o sus horarios no definidos para cálculo automático.");
                return;
            }

            const intermediateStopsIndices = [];
            currentRoute.stops.forEach((stop, index) => {
                if (stop.type === 'intermedia' && !stop.scheduledTime) { // Only calculate for those without manual time
                    intermediateStopsIndices.push(index);
                }
            });

            if (intermediateStopsIndices.length === 0) return;

            let totalDistance = 0;
            const segmentDistances = [];

            // Calculate total distance considering all stops between inicio and final
            let lastCalcStop = inicioStop;
            for (let i = 0; i < currentRoute.stops.length; i++) {
                const currentCalcStop = currentRoute.stops[i];
                if (i > 0 && currentRoute.stops[i-1].latlng && currentCalcStop.latlng) {
                     // Only sum distances for segments relevant to auto-calculation path
                    if (currentRoute.stops.indexOf(lastCalcStop) < i && currentRoute.stops.indexOf(currentCalcStop) <= currentRoute.stops.indexOf(finalStop)) {
                        const dist = lastCalcStop.latlng.distanceTo(currentCalcStop.latlng);
                        segmentDistances.push({ from: lastCalcStop, to: currentCalcStop, distance: dist });
                        totalDistance += dist;
                        if (currentCalcStop.type === 'final') break; // Stop summing if we reached final
                        if (currentCalcStop.type === 'intermedia' && currentCalcStop.scheduledTime) {
                            // If an intermediate has a fixed time, it acts as a new "start" for proportioning
                            // This part can get very complex. For this version, assume simple proportioning between THE main Inicio and Final
                        }
                         lastCalcStop = currentCalcStop;
                    }
                }
                 if (currentRoute.stops[i].type === 'inicio') lastCalcStop = currentRoute.stops[i];
            }
            
            // Recalculate totalDistance strictly from inicio to final through all intermediate stops
            totalDistance = 0;
            let pathStops = [inicioStop];
            currentRoute.stops.forEach(s => {
                if (s.type === 'intermedia') pathStops.push(s);
            });
            pathStops.push(finalStop);

            for(let i = 1; i < pathStops.length; i++) {
                totalDistance += pathStops[i-1].latlng.distanceTo(pathStops[i].latlng);
            }
            
            if (totalDistance === 0) {
                console.warn("Distancia total es cero, no se pueden calcular tiempos intermedios.");
                return;
            }

            const totalDurationMs = finalStop.scheduledTime.getTime() - inicioStop.scheduledTime.getTime();
            let accumulatedTimeMs = inicioStop.scheduledTime.getTime();
            let accumulatedDistance = 0;
            
            let lastTimedStop = inicioStop;

            for (let i = 0; i < currentRoute.stops.length; i++) {
                const stop = currentRoute.stops[i];
                if (stop.type === 'intermedia' && !stop.originalTimeInput) { // Only calc for those without user time
                    const distFromLastTimed = stop.latlng.distanceTo(lastTimedStop.latlng);
                    // This needs segment distance relative to total path, not just last stop
                    // This calculation should be based on the distance of this intermediate stop along the *entire* path from Inicio to Final
                    
                    // Simplified: iterate through stops from Inicio to Final
                    // Calculate distance for each segment
                    // Distribute time proportionally.
                    
                    // Let's trace path from Inicio to Final, accumulating distances
                    let currentPathDistance = 0;
                    let pathFromInicioToCurrentIntermediate = [inicioStop];
                    for (let j = currentRoute.stops.indexOf(inicioStop) + 1; j <= i; j++) {
                        pathFromInicioToCurrentIntermediate.push(currentRoute.stops[j]);
                    }

                    for (let k = 1; k < pathFromInicioToCurrentIntermediate.length; k++) {
                         currentPathDistance += pathFromInicioToCurrentIntermediate[k-1].latlng.distanceTo(pathFromInicioToCurrentIntermediate[k].latlng);
                    }

                    const proportionOfDistance = currentPathDistance / totalDistance;
                    const timeOffsetMs = totalDurationMs * proportionOfDistance;
                    stop.scheduledTime = new Date(inicioStop.scheduledTime.getTime() + timeOffsetMs);
                }
                if (stop.scheduledTime) { // If it has a time (manual or just calculated)
                    lastTimedStop = stop; // Update for next potential calculation
                }
            }
            renderCurrentRoute(); // Re-render to show times
        }

        function renderCurrentRoute() {
            // Clear previous markers and polyline
            currentRoute.markers.forEach(m => map.removeLayer(m));
            currentRoute.markers = [];
            if (currentRoute.polyline) {
                map.removeLayer(currentRoute.polyline);
                currentRoute.polyline = null;
            }

            const stopsListEl = document.getElementById('stopsList');
            stopsListEl.innerHTML = '';
            const latlngs = [];

            // Sort stops: inicio, intermedias in order of addition, final
            currentRoute.stops.sort((a, b) => {
                if (a.type === 'inicio') return -1;
                if (b.type === 'inicio') return 1;
                if (a.type === 'final') return 1;
                if (b.type === 'final') return -1;
                // Keep original order for intermediates if not specified otherwise
                return currentRoute.stops.indexOf(a) - currentRoute.stops.indexOf(b); 
            });


            currentRoute.stops.forEach((stop, index) => {
                const li = document.createElement('li');
                li.textContent = `${index + 1}. ${stop.name} (${stop.type}) - ${formatTime(stop.scheduledTime)}`;
                stopsListEl.appendChild(li);

                if (stop.latlng) {
                    latlngs.push(stop.latlng);
                    let iconHtml, iconColor;
                    let iconText = '';
                    switch (stop.type) {
                        case 'inicio':
                            iconText = 'I';
                            iconColor = getRandomColor();
                            break;
                        case 'final':
                            iconText = 'F';
                            iconColor = getRandomColor();
                            break;
                        case 'intermedia':
                            iconText = (currentRoute.stops.filter(s => s.type === 'intermedia').indexOf(stop) + 1).toString();
                            iconColor = '#888888'; // Grey for intermediates
                            break;
                    }
                    iconHtml = `<div class="custom-icon-text" style="background-color:${iconColor};">${iconText}</div>`;
                    
                    const customIcon = L.divIcon({
                        className: 'leaflet-div-icon',
                        html: iconHtml,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });
                    const marker = L.marker(stop.latlng, { icon: customIcon }).addTo(map);
                    marker.bindPopup(`${stop.name} (${stop.type})<br>${formatTime(stop.scheduledTime)}`);
                    currentRoute.markers.push(marker);
                }
            });

            if (latlngs.length > 1) {
                currentRoute.polyline = L.polyline(latlngs, { color: 'blue' }).addTo(map);
                // map.fitBounds(currentRoute.polyline.getBounds()); // Optional: zoom to route
            }
        }
        
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function clearCurrentRoute() {
            currentRoute = { name: '', stops: [], polyline: null, markers: [] };
            addingStopState = 'inicio';
            tempStopData = null;
            renderCurrentRoute();
            updateStopAddingUI();
            document.getElementById('stopName').value = '';
            document.getElementById('stopTime').value = '';
            document.getElementById('routeName').value = '';
        }

        // --- Route Persistence (Cache/localStorage) ---
        function saveCurrentRoute() {
            if (currentRoute.stops.length < 2) {
                alert("La ruta debe tener al menos Inicio y Final.");
                return;
            }
            if (addingStopState !== 'done') {
                alert("Finalice la definición de paradas antes de guardar.");
                return;
            }
            const routeName = document.getElementById('routeName').value.trim();
            if (!routeName) {
                alert("Por favor, ingrese un nombre para la ruta.");
                return;
            }
            
            // Ensure times are calculated if auto is on
            autoCalculateIntermediateTimesIfNeeded();

            const routeToSave = {
                name: routeName,
                stops: currentRoute.stops.map(stop => ({
                    latlng: { lat: stop.latlng.lat, lng: stop.latlng.lng }, // Serialize LatLng
                    name: stop.name,
                    type: stop.type,
                    originalTimeInput: stop.originalTimeInput || (stop.scheduledTime ? formatTime(stop.scheduledTime) : null)
                })),
                autoCalcTimes: document.getElementById('autoCalcTimes').checked
            };

            try {
                localStorage.setItem(CACHE_PREFIX + routeName, JSON.stringify(routeToSave));
                alert(`Ruta "${routeName}" guardada.`);
                loadRoutesFromCache(); // Refresh lists
            } catch (e) {
                console.error("Error saving to localStorage:", e);
                alert("Error al guardar la ruta. El almacenamiento podría estar lleno.");
            }
        }

        function loadRoutesFromCache() {
            const savedRoutesSelect = document.getElementById('savedRoutesSelect');
            const routeToQueueSelect = document.getElementById('routeToQueueSelect');
            savedRoutesSelect.innerHTML = '';
            routeToQueueSelect.innerHTML = '';

            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(CACHE_PREFIX)) {
                    const routeName = key.substring(CACHE_PREFIX.length);
                    const option = document.createElement('option');
                    option.value = routeName;
                    option.textContent = routeName;
                    savedRoutesSelect.appendChild(option.cloneNode(true));
                    routeToQueueSelect.appendChild(option);
                }
            }
        }

        function loadSelectedRoute() {
            const routeName = document.getElementById('savedRoutesSelect').value;
            if (!routeName) {
                alert("Seleccione una ruta para cargar.");
                return;
            }
            const routeDataString = localStorage.getItem(CACHE_PREFIX + routeName);
            if (routeDataString) {
                const parsedRoute = JSON.parse(routeDataString);
                
                clearCurrentRoute(); // Clear existing before loading
                currentRoute.name = parsedRoute.name;
                document.getElementById('routeName').value = parsedRoute.name;
                document.getElementById('autoCalcTimes').checked = parsedRoute.autoCalcTimes !== undefined ? parsedRoute.autoCalcTimes : true;

                currentRoute.stops = parsedRoute.stops.map(stopData => ({
                    latlng: L.latLng(stopData.latlng.lat, stopData.latlng.lng),
                    name: stopData.name,
                    type: stopData.type,
                    scheduledTime: stopData.originalTimeInput ? parseTimeInput(stopData.originalTimeInput) : null,
                    originalTimeInput: stopData.originalTimeInput
                }));
                
                addingStopState = 'done'; // Mark as defined
                autoCalculateIntermediateTimesIfNeeded(); // Recalculate if needed based on loaded autoCalcTimes state
                renderCurrentRoute();
                updateStopAddingUI();
                alert(`Ruta "${routeName}" cargada.`);
                openTab('crearRutaTab'); // Switch to route view
            } else {
                alert("Error al cargar la ruta seleccionada.");
            }
        }

        function deleteSelectedRoute() {
            const routeName = document.getElementById('savedRoutesSelect').value;
            if (!routeName) {
                alert("Seleccione una ruta para borrar.");
                return;
            }
            if (confirm(`¿Está seguro de que quiere borrar la ruta "${routeName}"?`)) {
                localStorage.removeItem(CACHE_PREFIX + routeName);
                loadRoutesFromCache(); // Refresh list
                // If the deleted route was the current route, clear it
                if (currentRoute.name === routeName) {
                    clearCurrentRoute();
                }
                alert(`Ruta "${routeName}" borrada.`);
            }
        }

        // --- Real-Time Tracking ---
        function startTracking() {
            if (trackingState.isActive) {
                alert("El seguimiento ya está activo.");
                return;
            }
            if (currentRoute.stops.length < 2 || !currentRoute.stops.find(s=>s.type==='inicio')?.scheduledTime || !currentRoute.stops.find(s=>s.type==='final')?.scheduledTime) {
                alert("Cargue o cree una ruta completa con horarios de inicio y fin antes de iniciar el seguimiento.");
                return;
            }
            
            // Ensure stops are correctly ordered and times potentially recalculated
            if (addingStopState !== 'done') finalizeRouteStops(); 
            autoCalculateIntermediateTimesIfNeeded(); // Recalculate times if auto is on
            renderCurrentRoute(); // Ensure map is up-to-date

            trackingState.isActive = true;
            trackingState.currentSegmentStartIndex = currentRoute.stops.findIndex(s => s.type === 'inicio');
            trackingState.nextStopIndex = findNextLogicalStopIndex(trackingState.currentSegmentStartIndex, null);

            if (trackingState.currentSegmentStartIndex === -1 || trackingState.nextStopIndex === -1) {
                alert("Error: No se pudo determinar la parada de inicio o siguiente para la ruta.");
                trackingState.isActive = false;
                return;
            }

            document.getElementById('startTrackingBtn').disabled = true;
            document.getElementById('stopTrackingBtn').disabled = false;
            updateManualAdvanceButtons();

            if (navigator.geolocation) {
                trackingState.watchId = navigator.geolocation.watchPosition(
                    geolocationSuccess,
                    geolocationError,
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                );
                alert("Seguimiento iniciado.");
                openTab('seguimientoTab');
            } else {
                alert("La geolocalización no es soportada por este navegador.");
                trackingState.isActive = false;
            }
        }

        function stopTracking() {
            if (trackingState.watchId) {
                navigator.geolocation.clearWatch(trackingState.watchId);
            }
            if (trackingState.currentPositionMarker) {
                map.removeLayer(trackingState.currentPositionMarker);
                trackingState.currentPositionMarker = null;
            }
            trackingState.isActive = false;
            trackingState.watchId = null;
            trackingState.lastPosition = null;
            // trackingState.currentSegmentStartIndex = -1; // Keep these to allow resuming or for queue
            // trackingState.nextStopIndex = 0;
            document.getElementById('startTrackingBtn').disabled = false;
            document.getElementById('stopTrackingBtn').disabled = true;
            document.getElementById('speed').textContent = '--';
            // document.getElementById('nextStopInfo').textContent = '--'; // Keep for queue
            // document.getElementById('timeDeviation').textContent = '00:00';
            // document.getElementById('timeDeviation').className = 'a-tiempo';
            updateManualAdvanceButtons();
            alert("Seguimiento detenido.");

            // Check route queue
            if (routeQueue.length > 0) {
                if (confirm("Hay rutas en cola. ¿Desea iniciar la siguiente?")) {
                    startNextRouteFromQueue();
                }
            }
        }

        function geolocationSuccess(position) {
            const { latitude, longitude, speed } = position.coords;
            const currentLatlng = L.latLng(latitude, longitude);

            if (!trackingState.currentPositionMarker) {
                const driverIcon = L.divIcon({
                    className: 'driver-marker',
                    html: '<div id="currentLocationMarker"></div>',
                    iconSize: [15,15],
                    iconAnchor: [7,7]
                });
                trackingState.currentPositionMarker = L.marker(currentLatlng, {icon: driverIcon}).addTo(map);
            } else {
                trackingState.currentPositionMarker.setLatLng(currentLatlng);
            }
            map.panTo(currentLatlng); // Keep driver centered

            // Speed (convert m/s to km/h if available)
            document.getElementById('speed').textContent = speed ? (speed * 3.6).toFixed(1) : '--';

            // Calculate deviation and update next stop
            if (trackingState.nextStopIndex < currentRoute.stops.length) {
                 updateNextStopAndDeviation(currentLatlng);
            } else {
                document.getElementById('nextStopInfo').textContent = "Ruta Completada";
                document.getElementById('timeDeviation').textContent = "00:00";
                 document.getElementById('timeDeviation').className = 'a-tiempo';
                 // stopTracking(); // Optionally auto-stop
            }
            trackingState.lastPosition = position;
        }
        
        function findNextLogicalStopIndex(currentStopIndex, userPosition) {
            // If tracking hasn't started, or currentStop is invalid, start from beginning
            if (currentStopIndex === -1 || currentStopIndex >= currentRoute.stops.length -1) {
                 let firstRoutableStop = currentRoute.stops.findIndex(s => s.type === 'inicio' && s.scheduledTime);
                 if (firstRoutableStop === -1) firstRoutableStop = 0; // fallback
                 if (currentRoute.stops.length > firstRoutableStop + 1) return firstRoutableStop + 1;
                 return -1; // No next stop
            }
            
            // Default: simply the next stop in the list
            let nextIdx = currentStopIndex + 1;
            if (nextIdx >= currentRoute.stops.length) return -1; // End of route

            if (!trackingState.manualAdvance && userPosition) {
                // Automatic "skip" logic (simplified: if very close to a *future* stop, jump to it)
                // This is complex. For now, simple proximity to current `nextStopIndex` is handled in `updateNextStopAndDeviation`.
                // A more advanced skip would check distances to ALL subsequent stops.
                // For now, we rely on sequential progression or manual override.
            }
            return nextIdx;
        }

        function updateNextStopAndDeviation(currentDriverPos) {
            if (trackingState.nextStopIndex >= currentRoute.stops.length || trackingState.currentSegmentStartIndex < 0) {
                 document.getElementById('nextStopInfo').textContent = (trackingState.nextStopIndex >= currentRoute.stops.length) ? "Ruta Completada" : "Error de seguimiento";
                 if (trackingState.nextStopIndex >= currentRoute.stops.length && trackingState.isActive) {
                     alert("¡Ruta completada!");
                     stopTracking(); // This will also check queue
                 }
                return;
            }

            const stopA = currentRoute.stops[trackingState.currentSegmentStartIndex];
            const stopB = currentRoute.stops[trackingState.nextStopIndex];

            document.getElementById('nextStopInfo').textContent = `${stopB.name} (${formatTime(stopB.scheduledTime)})`;

            // Auto-advance if not in manual mode and close to next stop
            if (!trackingState.manualAdvance && stopB.latlng) {
                const distanceToNextStop = currentDriverPos.distanceTo(stopB.latlng);
                const REACH_THRESHOLD = 50; // meters
                if (distanceToNextStop < REACH_THRESHOLD) {
                    console.log(`Reached ${stopB.name}, advancing.`);
                    trackingState.currentSegmentStartIndex = trackingState.nextStopIndex;
                    trackingState.nextStopIndex = findNextLogicalStopIndex(trackingState.currentSegmentStartIndex, currentDriverPos);
                    
                    if (trackingState.nextStopIndex === -1 || trackingState.nextStopIndex >= currentRoute.stops.length) { // Reached final stop
                        document.getElementById('nextStopInfo').textContent = "Ruta Completada";
                        alert("¡Ruta completada!");
                        stopTracking();
                        return;
                    }
                    // Recurse or update UI for the new segment
                    updateNextStopAndDeviation(currentDriverPos); // Call again for the new segment
                    return; 
                }
            }
            
            // Calculate desvío for current segment (stopA to stopB)
            if (stopA && stopB && stopA.scheduledTime && stopB.scheduledTime && stopA.latlng && stopB.latlng) {
                const timeTotalSegmentMs = stopB.scheduledTime.getTime() - stopA.scheduledTime.getTime();
                if (timeTotalSegmentMs <= 0 && stopA !== stopB) { // Avoid division by zero or negative duration for distinct stops
                    console.warn(`Segmento ${stopA.name} -> ${stopB.name} tiene duración no positiva. Desvío no calculado.`);
                    document.getElementById('timeDeviation').textContent = 'Error Horario';
                    document.getElementById('timeDeviation').className = 'atrasado'; // Mark as an issue
                    return;
                }
                
                const distTotalSegment = stopA.latlng.distanceTo(stopB.latlng);
                if (distTotalSegment === 0 && stopA !== stopB) {
                     console.warn(`Segmento ${stopA.name} -> ${stopB.name} tiene distancia cero. Desvío no calculado.`);
                     // If distance is zero, we are either at stopA or stopB.
                     // If at stopA, percentage is 0. If at stopB, percentage is 1.
                     // This case likely means stops are coincident.
                }

                const distRecorridaEnSegmento = stopA.latlng.distanceTo(currentDriverPos);
                
                let porcentajeRecorrido = 0;
                if (distTotalSegment > 0) {
                     porcentajeRecorrido = Math.min(1, Math.max(0, distRecorridaEnSegmento / distTotalSegment)); 
                     // A more accurate way would be to project currentDriverPos onto the line segment AB.
                     // For simplicity, direct distance from A is used. This works well if driver is on path.
                } else if (currentDriverPos.equals(stopB.latlng, 0.0001)) { // If at stop B and distance is 0
                    porcentajeRecorrido = 1;
                }


                const tiempoEsperadoHastaAhoraMs = stopA.scheduledTime.getTime() + (timeTotalSegmentMs * porcentajeRecorrido);
                const currentTimeMs = new Date().getTime();
                const desvioMs = tiempoEsperadoHastaAhoraMs - currentTimeMs; // Positive = adelantado

                const desvioSecsTotal = Math.round(desvioMs / 1000);
                const absDesvioSecs = Math.abs(desvioSecsTotal);
                const desvioMins = Math.floor(absDesvioSecs / 60);
                const desvioSecs = absDesvioSecs % 60;
                const sign = desvioMs >= 0 ? '+' : '-';

                const desvioStr = `${sign}${String(desvioMins).padStart(2, '0')}:${String(desvioSecs).padStart(2, '0')}`;
                document.getElementById('timeDeviation').textContent = desvioStr;
                
                if (desvioMs > 30000) { // More than 30s ahead
                    document.getElementById('timeDeviation').className = 'adelantado';
                } else if (desvioMs < -30000) { // More than 30s behind
                    document.getElementById('timeDeviation').className = 'atrasado';
                } else {
                    document.getElementById('timeDeviation').className = 'a-tiempo';
                }

            } else {
                document.getElementById('timeDeviation').textContent = '--:--';
                document.getElementById('timeDeviation').className = 'a-tiempo';
                 console.warn("Datos insuficientes para calcular desvío (faltan paradas, horarios o ubicaciones).", stopA, stopB);
            }
        }
        
        function geolocationError(error) {
            console.error("Error de Geolocalización: ", error);
            alert(`Error de Geolocalización: ${error.message}`);
            // Consider stopping tracking if errors persist
        }

        function toggleManualAdvance(isManual) {
            trackingState.manualAdvance = isManual;
            updateManualAdvanceButtons();
        }

        function updateManualAdvanceButtons() {
            const manualMode = trackingState.manualAdvance && trackingState.isActive;
            document.getElementById('prevStopBtn').disabled = !manualMode || trackingState.currentSegmentStartIndex <= 0;
            document.getElementById('nextStopBtn').disabled = !manualMode || trackingState.nextStopIndex >= currentRoute.stops.length -1 || trackingState.nextStopIndex === -1;
        }

        function manualAdvanceStop(direction) {
            if (!trackingState.isActive || !trackingState.manualAdvance) return;

            if (direction === 'next') {
                if (trackingState.nextStopIndex < currentRoute.stops.length -1 && trackingState.nextStopIndex !== -1) {
                    trackingState.currentSegmentStartIndex = trackingState.nextStopIndex;
                    trackingState.nextStopIndex++;
                } else if (trackingState.nextStopIndex === currentRoute.stops.length -1) { // Was at last segment, now completed
                     trackingState.currentSegmentStartIndex = trackingState.nextStopIndex;
                     trackingState.nextStopIndex = -1; // Indicates completion
                     alert("Ruta completada (avance manual).");
                     stopTracking(); // This will also check queue
                     updateManualAdvanceButtons();
                     return;
                }
            } else if (direction === 'prev') {
                // To go "previous", we need to set nextStopIndex to currentSegmentStartIndex,
                // and currentSegmentStartIndex to the stop before that.
                if (trackingState.currentSegmentStartIndex > 0) {
                    trackingState.nextStopIndex = trackingState.currentSegmentStartIndex;
                    // Find the stop *before* the new nextStopIndex (which was the old currentSegmentStartIndex)
                    // This logic ensures we always have a valid segment A->B
                    // If currentSegmentStartIndex was stop_k, new nextStopIndex is stop_k.
                    // New currentSegmentStartIndex should be stop_{k-1}.
                    trackingState.currentSegmentStartIndex--; 
                }
            }
            // Update UI based on new segment/next stop
            if (trackingState.lastPosition) { // If we have a current position
                 updateNextStopAndDeviation(L.latLng(trackingState.lastPosition.coords.latitude, trackingState.lastPosition.coords.longitude));
            } else if (currentRoute.stops[0] && currentRoute.stops[0].latlng) { // Fallback to route start if no GPS yet
                 updateNextStopAndDeviation(currentRoute.stops[0].latlng);
            }
            updateManualAdvanceButtons();
        }

        // --- Route Queue ---
        function addRouteToQueue() {
            const routeName = document.getElementById('routeToQueueSelect').value;
            if (!routeName) {
                alert("Seleccione una ruta para añadir a la cola.");
                return;
            }
            const routeDataString = localStorage.getItem(CACHE_PREFIX + routeName);
            if (routeDataString) {
                const parsedRoute = JSON.parse(routeDataString); // Save the full object for easier start
                routeQueue.push(parsedRoute);
                updateRouteQueueDisplay();
                saveRouteQueueToCache();
                alert(`Ruta "${routeName}" añadida a la cola.`);
            } else {
                alert("Error al cargar datos de la ruta para la cola.");
            }
        }

        function updateRouteQueueDisplay() {
            const queueDisplay = document.getElementById('routeQueueDisplay');
            queueDisplay.innerHTML = '';
            routeQueue.forEach((routeData, index) => {
                const li = document.createElement('li');
                li.textContent = `${index + 1}. ${routeData.name}`;
                queueDisplay.appendChild(li);
            });
        }
        
        function clearRouteQueue() {
            routeQueue = [];
            updateRouteQueueDisplay();
            saveRouteQueueToCache();
            alert("Cola de rutas limpiada.");
        }

        function saveRouteQueueToCache() {
             try {
                localStorage.setItem(CACHE_QUEUE_KEY, JSON.stringify(routeQueue.map(r => r.name))); // Save only names
            } catch (e) {
                console.error("Error saving route queue:", e);
            }
        }

        function loadRouteQueueFromCache() {
            const storedQueueNames = localStorage.getItem(CACHE_QUEUE_KEY);
            if (storedQueueNames) {
                try {
                    const routeNames = JSON.parse(storedQueueNames);
                    routeQueue = []; // Clear current memory queue
                    routeNames.forEach(name => {
                        const routeDataString = localStorage.getItem(CACHE_PREFIX + name);
                        if (routeDataString) {
                             routeQueue.push(JSON.parse(routeDataString));
                        } else {
                            console.warn(`Route "${name}" from queue not found in localStorage.`);
                        }
                    });
                    updateRouteQueueDisplay();
                } catch (e) {
                    console.error("Error loading route queue:", e);
                    localStorage.removeItem(CACHE_QUEUE_KEY); // Clear corrupted data
                }
            }
        }

        function startNextRouteFromQueue() {
            if (routeQueue.length > 0) {
                const nextRouteData = routeQueue.shift(); // Get and remove from front
                updateRouteQueueDisplay();
                saveRouteQueueToCache();

                // Load this route data into currentRoute
                clearCurrentRoute();
                currentRoute.name = nextRouteData.name;
                document.getElementById('routeName').value = nextRouteData.name;
                document.getElementById('autoCalcTimes').checked = nextRouteData.autoCalcTimes !== undefined ? nextRouteData.autoCalcTimes : true;


                currentRoute.stops = nextRouteData.stops.map(stopData => ({
                    latlng: L.latLng(stopData.latlng.lat, stopData.latlng.lng),
                    name: stopData.name,
                    type: stopData.type,
                    scheduledTime: stopData.originalTimeInput ? parseTimeInput(stopData.originalTimeInput) : null,
                    originalTimeInput: stopData.originalTimeInput
                }));
                
                addingStopState = 'done';
                autoCalculateIntermediateTimesIfNeeded(); // Recalculate if needed based on loaded autoCalcTimes state
                renderCurrentRoute(); // Update map and lists
                updateStopAddingUI();
                
                alert(`Iniciando siguiente ruta de la cola: "${currentRoute.name}"`);
                startTracking(); // Automatically start tracking the new route
            } else {
                alert("No hay más rutas en la cola.");
            }
        }

    </script>
</body>
</html>
