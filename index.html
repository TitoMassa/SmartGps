<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            overflow: hidden; /* Prevent body scroll */
            display: flex;
            flex-direction: column;
        }

        #map {
            height: 50vh; /* 50% of viewport height */
            width: 100%;
            background-color: #333; /* Placeholder color */
        }

        #controls {
            height: 50vh; /* 50% of viewport height */
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .control-section:last-child {
            border-bottom: none;
        }

        h2, h3 {
            color: #FFFFFF;
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="text"], input[type="datetime-local"], input[type="number"], select {
            width: calc(100% - 12px);
            padding: 8px;
            margin-bottom: 10px;
            background-color: #222;
            color: #FFF;
            border: 1px solid #555;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        button:hover {
            background-color: #45a049;
        }
        button.danger {
            background-color: #f44336;
        }
        button.danger:hover {
            background-color: #da190b;
        }
        button.secondary {
            background-color: #007bff;
        }
        button.secondary:hover {
            background-color: #0056b3;
        }
        button.info {
            background-color: #17a2b8;
        }
        button.info:hover {
            background-color: #117a8b;
        }


        #statusDisplay {
            text-align: center;
            padding: 10px;
        }
        #timeDeviation {
            font-size: 3em; /* Larger font for time deviation */
            font-weight: bold;
            margin: 10px 0;
        }
        #trackingInfoDisplay, #speedDisplay, #nextStopDisplay {
            font-size: 1.2em;
            margin: 5px 0;
        }

        .stop-item {
            background-color: #1e1e1e;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
            cursor: pointer;
        }
        .stop-item:hover {
            background-color: #2f2f2f;
        }
        .stop-item.next-stop-highlight {
            background-color: #007bff;
            font-weight: bold;
        }
        .stop-item.line-endpoint-highlight {
            border-left: 3px solid #ffc107; /* Yellow border for line endpoints */
        }


        .leaflet-div-icon {
            background: transparent;
            border: none;
            text-align: center;
            font-weight: bold;
            color: white;
        }
        .waypoint-marker-icon {
            background-color:#888888 !important;
            width: 10px !important;
            height: 10px !important;
            border-radius: 50% !important;
            border: 1px solid #FFFFFF !important;
            box-sizing: border-box !important;
        }


        .user-location-icon {
            background-color: #007bff !important; /* Blue dot */
            border-radius: 50%;
            width: 16px !important;
            height: 16px !important;
            border: 2px solid white;
            box-shadow: 0 0 0 2px #007bff;
        }
    </style>
</head>
<body>

    <div id="map"></div>
    <div id="controls">
        <div id="statusDisplay" style="display: none;">
            <div id="trackingInfoDisplay">Vuelta: 1/1 - Bandera: IDA</div>
            <div id="timeDeviation">00:00</div>
            <div id="speedDisplay">Velocidad: 0 KM/H</div>
            <div id="nextStopDisplay">Próxima Parada: N/A</div>
        </div>

        <div class="control-section" id="routeCreationSection">
            <h3>Crear/Modificar Ruta</h3>
            <p style="font-size: 0.8em;">
                Toca el mapa para agregar Puntas de Línea (2 máx.) o Paradas Intermedias.
                Toca un punto existente para editarlo. Las primeras dos paradas (no puntos de paso) añadidas se considerarán Puntas de Línea.
            </p>

            <button onclick="toggleAddWaypointMode()" id="addWaypointBtn" class="info">Añadir Punto de Paso</button>
            <p id="waypointModeStatus" style="font-size: 0.8em; color: #17a2b8; display: none;">Modo 'Añadir Punto de Paso' ACTIVO. Toca el mapa.</p>
            <hr style="margin: 10px 0;">

            <label for="pointName">Nombre Punto:</label>
            <input type="text" id="pointName" placeholder="Ej: Terminal Norte">

            <div id="lineEndpointTimes" style="display:none;">
                <label for="pointScheduledDepartureTime">Horario Salida Programado (de esta Punta de Línea):</label>
                <input type="datetime-local" id="pointScheduledDepartureTime">
                <label for="pointScheduledArrivalTime">Horario Llegada Programado (a esta Punta de Línea):</label>
                <input type="datetime-local" id="pointScheduledArrivalTime">
                <small style="font-size: 0.7em; display: block; margin-bottom: 5px;">
                    <b>1ra Punta de Línea (P1):</b> Salida inicia IDA, Llegada termina VUELTA.<br>
                    <b>2da Punta de Línea (P2):</b> Llegada termina IDA, Salida inicia VUELTA.
                </small>
            </div>
            <div id="intermediateStopTime" style="display:none;">
                <label for="pointScheduledTimeIntermediate">Horario Programado (Parada Intermedia en IDA):</label>
                <input type="datetime-local" id="pointScheduledTimeIntermediate">
                <small style="font-size: 0.7em; display: block; margin-bottom: 5px;">
                    El horario para VUELTA se calculará automáticamente si la opción está activa.
                </small>
            </div>


            <div id="editPointControls" style="display:none; margin-top:10px;">
                <button onclick="updateSelectedPoint()" class="secondary">Actualizar Punto</button>
                <button onclick="deleteSelectedPoint()" class="danger">Borrar Punto Seleccionado</button>
                <button onclick="cancelEdit()">Cancelar Edición</button>
            </div>
            <hr style="margin: 15px 0;">
            <input type="checkbox" id="autoCalcTimes" checked onchange="calculateAndApplyAllIntermediateTimes()">
            <label for="autoCalcTimes" style="display:inline;">Calcular horarios intermedios automáticamente (para IDA y VUELTA)</label>
            <br><br>
            <button onclick="clearCurrentRoute()">Limpiar Ruta Actual</button>
        </div>

        <div class="control-section">
            <h3>Configuración de Vueltas y Banderas</h3>
            <label for="totalTurnsInput">Cantidad de Vueltas (ciclos completos IDA-VUELTA):</label>
            <input type="number" id="totalTurnsInput" value="1" min="1" onchange="updateRouteSettings()">
            <label for="flagNameIdaInput">Nombre Bandera IDA:</label>
            <input type="text" id="flagNameIdaInput" value="IDA" onchange="updateRouteSettings()">
            <label for="flagNameVueltaInput">Nombre Bandera VUELTA:</label>
            <input type="text" id="flagNameVueltaInput" value="VUELTA" onchange="updateRouteSettings()">
        </div>

        <div class="control-section">
            <h3>Configuración de Visualización</h3>
            <label for="stopRadiusInput">Radio de Paradas/Puntas (metros):</label>
            <input type="number" id="stopRadiusInput" value="50" min="10" max="500" onchange="updateGlobalStopRadiusSettings()">
        </div>

        <div class="control-section">
            <h3>Lista de Puntos (Paradas y Puntas de Línea)</h3>
            <div id="stopsList">No hay puntos definidos.</div>
        </div>

        <div class="control-section">
            <h3>Guardar/Cargar Rutas</h3>
            <label for="routeName">Nombre para Guardar Ruta:</label>
            <input type="text" id="routeName" placeholder="Ej: Ruta Mañana Lunes">
            <button onclick="saveRoute()">Guardar Ruta</button>
            <br><br>
            <label for="savedRoutes">Cargar Ruta:</label>
            <select id="savedRoutes"></select>
            <button onclick="loadRoute()">Cargar</button>
            <button onclick="deleteRoute()" class="danger">Borrar Seleccionada</button>
        </div>

        <div class="control-section">
            <h3>Seguimiento</h3>
            <button id="startTrackingBtn" onclick="startTracking()">Iniciar Seguimiento</button>
            <button id="stopTrackingBtn" onclick="stopTracking()" class="danger" style="display:none;">Detener Seguimiento</button>
            <br>
            <input type="checkbox" id="manualStopNav" onchange="updateManualNavButtons()">
            <label for="manualStopNav" style="display:inline;">Navegación Manual de Puntos</label>
            <button id="prevStopBtn" onclick="goToPreviousActivePoint()" style="display:none;">Anterior</button>
            <button id="nextStopBtn" onclick="goToNextActivePoint()" style="display:none;">Siguiente</button>
        </div>

        <div class="control-section">
            <h3>Cola de Rutas</h3>
            <label for="routeToQueue">Añadir ruta guardada a la cola:</label>
            <select id="routeToQueue"></select>
            <button onclick="addRouteToQueue()">Añadir a Cola</button>
            <h4>En Cola:</h4>
            <div id="routeQueueDisplay">Vacía.</div>
            <button onclick="clearRouteQueue()">Limpiar Cola</button>
        </div>

    </div>

    <script>
        'use strict';
        let map;
        let routePoints = [];
        let routeLineIda; // Polyline for IDA leg (Blue)
        let routeLineVuelta; // Polyline for VUELTA leg (Red)
        let userMarker;
        let trackingIntervalId;
        let isTracking = false;
        let currentSegmentStartIndex = 0;
        let lastKnownPosition = null;
        let currentlyEditingPoint = null;
        let currentStopRadius = 50;
        let addingWaypointMode = false;

        const CACHE_PREFIX = 'smartMovePro_route_';
        const ROUTE_QUEUE_CACHE_KEY = 'smartMovePro_routeQueue';

        let routeSettings = {
            totalTurns: 1,
            flagNameIda: "IDA",
            flagNameVuelta: "VUELTA"
        };

        let trackingState = {
            currentTurn: 1,
            currentFlag: routeSettings.flagNameIda,
            activeLegPoints: [],
        };

        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }

        function createDivIcon(text, pointCategory = '', isFirstEndpoint = false) {
            let htmlContent = '';
            let iconSize = [30,30];
            let iconAnchor = [15,15];
            let className = 'leaflet-div-icon';

            if (pointCategory === 'waypoint') {
                className += ' waypoint-marker-icon';
                iconSize = [12,12];
                iconAnchor = [6,6];
            } else if (pointCategory === 'lineEndpoint') {
                const bgColor = isFirstEndpoint ? '#FF8C00' : '#DA70D6';
                const P_char = text ? text.substring(0,1).toUpperCase() : (isFirstEndpoint ? 'P1' : 'P2');
                htmlContent = `<div style="background-color:${bgColor}; width: 28px; height:28px; display:flex; justify-content:center; align-items:center; border-radius: 50%; color: white; font-size:14px; font-weight:bold; border: 2px solid white;">${P_char}</div>`;
                iconSize = [32,32];
                iconAnchor = [16,16];
            } else { // intermediateStop
                const bgColor = '#2196F3';
                const displayText = text || '?';
                htmlContent = `<div style="background-color:${bgColor}; padding: 5px 8px; border-radius: 5px; color: white; font-size:12px; font-weight:bold; border: 1px solid white; min-width: 15px; text-align: center;">${displayText}</div>`;
                iconSize = [displayText.length > 1 ? 35 : 30, 30];
                iconAnchor = [iconSize[0]/2, 15];
            }

            return L.divIcon({
                className: className,
                html: htmlContent,
                iconSize: iconSize,
                iconAnchor: iconAnchor
            });
        }

        function createUserLocationIcon() {
            return L.divIcon({
                className: 'user-location-icon',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        function initMap() {
            map = L.map('map').setView([-34.6037, -58.3816], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            map.on('click', onMapClick);
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    map.setView([position.coords.latitude, position.coords.longitude], 13);
                });
            }
            document.getElementById('stopRadiusInput').value = currentStopRadius;
            updateRouteSettings();
            redrawRouteLine(); // Initial draw in case there are default points or for empty state
        }

        function toggleAddWaypointMode() {
            if (isTracking) {
                alert("Detén el seguimiento para modificar la ruta.");
                return;
            }
            addingWaypointMode = !addingWaypointMode;
            const statusP = document.getElementById('waypointModeStatus');
            const button = document.getElementById('addWaypointBtn');
            if (addingWaypointMode) {
                cancelEdit();
                statusP.style.display = 'block';
                button.classList.add('danger');
                button.textContent = "Cancelar Añadir Punto de Paso";
            } else {
                statusP.style.display = 'none';
                button.classList.remove('danger');
                button.textContent = "Añadir Punto de Paso";
            }
            updateWaypointMarkersVisibility();
        }

        function updateWaypointMarkersVisibility() {
            routePoints.forEach(p => {
                if (p.pointCategory === 'waypoint' && p.marker) {
                    if (addingWaypointMode) {
                        if (!map.hasLayer(p.marker)) map.addLayer(p.marker);
                    } else {
                        // Waypoints are part of the polyline, so keep them on map if route exists
                        // This function was perhaps for hiding them when not in waypoint mode.
                        // For now, let's always show them if they are part of routePoints.
                        // If distinct visibility is needed, this can be adjusted.
                         if (!map.hasLayer(p.marker)) map.addLayer(p.marker); // Keep visible
                    }
                }
            });
        }

        function updateRouteSettings() {
            routeSettings.totalTurns = parseInt(document.getElementById('totalTurnsInput').value) || 1;
            routeSettings.flagNameIda = document.getElementById('flagNameIdaInput').value || "IDA";
            routeSettings.flagNameVuelta = document.getElementById('flagNameVueltaInput').value || "VUELTA";
            if (!isTracking) trackingState.currentFlag = routeSettings.flagNameIda;
            redrawRouteLine(); // Update line colors/paths if flag names (definitions) change
            updateTrackingStatusDisplay();
        }

        function formatDateTimeForInput(date) {
            if (!date || isNaN(new Date(date).getTime())) return "";
            const d = new Date(date);
            d.setMinutes(d.getMinutes() - d.getTimezoneOffset());
            return d.toISOString().slice(0, 16);
        }

        function activateEditModeForPoint(point) {
            if (isTracking || point.pointCategory === 'waypoint') return;

            currentlyEditingPoint = point;
            document.getElementById('pointName').value = point.name;

            document.getElementById('lineEndpointTimes').style.display = 'none';
            document.getElementById('intermediateStopTime').style.display = 'none';

            if (point.pointCategory === 'lineEndpoint') {
                document.getElementById('lineEndpointTimes').style.display = 'block';
                const depTimeKey = point.isFirstEndpoint ? 'departureOutbound' : 'departureReturn';
                const arrTimeKey = point.isFirstEndpoint ? 'arrivalReturn' : 'arrivalOutbound';
                document.getElementById('pointScheduledDepartureTime').value = formatDateTimeForInput(point.times[depTimeKey]);
                document.getElementById('pointScheduledArrivalTime').value = formatDateTimeForInput(point.times[arrTimeKey]);
            } else if (point.pointCategory === 'intermediateStop') {
                document.getElementById('intermediateStopTime').style.display = 'block';
                document.getElementById('pointScheduledTimeIntermediate').value = formatDateTimeForInput(point.times.scheduledIDA);
            }

            document.getElementById('editPointControls').style.display = 'block';
            document.getElementById('pointName').focus();
            if (addingWaypointMode) toggleAddWaypointMode();
        }

        function cancelEdit() {
            currentlyEditingPoint = null;
            document.getElementById('pointName').value = "";
            document.getElementById('pointScheduledDepartureTime').value = "";
            document.getElementById('pointScheduledArrivalTime').value = "";
            document.getElementById('pointScheduledTimeIntermediate').value = "";
            document.getElementById('editPointControls').style.display = 'none';
            document.getElementById('lineEndpointTimes').style.display = 'none';
            document.getElementById('intermediateStopTime').style.display = 'none';
        }

        function updateSelectedPoint() {
            if (!currentlyEditingPoint || currentlyEditingPoint.pointCategory === 'waypoint') return;

            const newName = document.getElementById('pointName').value.trim();
            if (!newName) { alert("El nombre del punto no puede estar vacío."); return; }
            currentlyEditingPoint.name = newName;

            if (currentlyEditingPoint.pointCategory === 'lineEndpoint') {
                const depTimeValue = document.getElementById('pointScheduledDepartureTime').value;
                const arrTimeValue = document.getElementById('pointScheduledArrivalTime').value;

                if (!depTimeValue || !arrTimeValue) {
                    alert("Las Puntas de Línea deben tener horarios de salida y llegada definidos."); return;
                }
                const departureTime = new Date(depTimeValue);
                const arrivalTime = new Date(arrTimeValue);

                if (isNaN(departureTime.getTime()) || isNaN(arrivalTime.getTime())) {
                    alert("Formato de fecha/hora inválido para Punta de Línea."); return;
                }

                if (currentlyEditingPoint.isFirstEndpoint) { // P1
                    currentlyEditingPoint.times.departureOutbound = departureTime; // IDA Start
                    currentlyEditingPoint.times.arrivalReturn = arrivalTime;     // VUELTA End
                } else { // P2
                    currentlyEditingPoint.times.arrivalOutbound = arrivalTime;     // IDA End
                    currentlyEditingPoint.times.departureReturn = departureTime; // VUELTA Start
                }

            } else if (currentlyEditingPoint.pointCategory === 'intermediateStop') {
                const interTimeValue = document.getElementById('pointScheduledTimeIntermediate').value;
                currentlyEditingPoint.times.scheduledIDA = interTimeValue ? new Date(interTimeValue) : null;
                if (interTimeValue && isNaN(currentlyEditingPoint.times.scheduledIDA.getTime())) {
                     alert("Formato de fecha/hora inválido para Parada Intermedia.");
                     currentlyEditingPoint.times.scheduledIDA = null;
                     return;
                }
            }

            if (document.getElementById('autoCalcTimes').checked) {
                calculateAndApplyAllIntermediateTimes();
            }
            updateAllMarkerIconsAndLabels();
            redrawRouteLine();
            updateStopsList();
            alert(`Punto "${newName}" actualizado.`);
            cancelEdit();
        }

        function deleteSelectedPoint() {
            if (!currentlyEditingPoint || currentlyEditingPoint.pointCategory === 'waypoint') return;

            if (confirm(`¿Seguro que quieres borrar el punto "${currentlyEditingPoint.name}"?`)) {
                map.removeLayer(currentlyEditingPoint.marker);
                if (currentlyEditingPoint.radiusCircle) map.removeLayer(currentlyEditingPoint.radiusCircle);

                const originalPointCategory = currentlyEditingPoint.pointCategory;
                routePoints = routePoints.filter(p => p.id !== currentlyEditingPoint.id);

                if (originalPointCategory === 'lineEndpoint') {
                    const remainingLineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
                    if (remainingLineEndpoints.length > 0) {
                         remainingLineEndpoints.sort((a,b) => a.originalIndex - b.originalIndex);
                         remainingLineEndpoints[0].isFirstEndpoint = true;
                         if(remainingLineEndpoints.length > 1) remainingLineEndpoints[1].isFirstEndpoint = false;
                    }
                }
                routePoints.forEach((p, idx) => p.originalIndex = idx); // Re-index after deletion

                if (document.getElementById('autoCalcTimes').checked) {
                    calculateAndApplyAllIntermediateTimes();
                }
                updateAllMarkerIconsAndLabels();
                redrawRouteLine();
                updateStopsList();
                alert(`Punto "${currentlyEditingPoint.name}" borrado.`);
            }
            cancelEdit();
        }

        function updateAllMarkerIconsAndLabels() {
            const displayOrderedPoints = getSortedRoutePointsForDisplay();

            routePoints.forEach(p => {
                if (p.marker) {
                    let text = '';
                    if (p.pointCategory === 'lineEndpoint') {
                        text = p.name;
                    } else if (p.pointCategory === 'intermediateStop') {
                        const displayIdx = displayOrderedPoints.filter(dp=>dp.pointCategory === 'intermediateStop').findIndex(dp => dp.id === p.id);
                        text = (displayIdx !== -1) ? String(displayIdx + 1) : '?';
                    }
                    p.marker.setIcon(createDivIcon(text, p.pointCategory, p.isFirstEndpoint));
                }
            });
        }

        function onMapClick(e) {
            if (isTracking) { alert("Detén el seguimiento para modificar la ruta."); return; }
            let targetIsMarkerIcon = e.originalEvent.target.closest && e.originalEvent.target.closest('.leaflet-marker-icon');
            if (currentlyEditingPoint && !targetIsMarkerIcon) cancelEdit();
            if (targetIsMarkerIcon) return;

            const latlng = e.latlng;
            const pointId = generateUniqueId();

            if (addingWaypointMode) {
                const waypoint = {
                    id: pointId, lat: latlng.lat, lng: latlng.lng,
                    name: `Paso ${routePoints.filter(p => p.pointCategory === 'waypoint').length + 1}`,
                    pointCategory: 'waypoint',
                    marker: L.marker(latlng, { icon: createDivIcon(null, 'waypoint'), draggable: true }),
                    radiusCircle: null, originalIndex: routePoints.length, times: {} // Added times for consistency
                };
                map.addLayer(waypoint.marker);

                waypoint.marker.on('dragend', function(event) {
                    if (isTracking) { event.target.setLatLng(L.latLng(waypoint.lat, waypoint.lng)); return; }
                    const pos = event.target.getLatLng(); waypoint.lat = pos.lat; waypoint.lng = pos.lng;
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                });
                waypoint.marker.on('click', function(ev) {
                    L.DomEvent.stopPropagation(ev); if (isTracking) return;
                    if (confirm(`¿Borrar este punto de paso "${waypoint.name}"?`)) {
                        map.removeLayer(waypoint.marker);
                        routePoints = routePoints.filter(p => p.id !== waypoint.id);
                        routePoints.forEach((p, idx) => p.originalIndex = idx); // Re-index
                        redrawRouteLine();
                        if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                    }
                });
                routePoints.push(waypoint);
                routePoints.sort((a,b) => a.originalIndex - b.originalIndex);
                routePoints.forEach((p, idx) => p.originalIndex = idx);

                if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                redrawRouteLine();
                return;
            }

            const nameInput = document.getElementById('pointName');
            let pointNameValue = nameInput.value.trim();
            let pointCategory;
            let isFirstEp = false;
            const currentLineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');

            if (currentLineEndpoints.length < 2) {
                pointCategory = 'lineEndpoint';
                isFirstEp = (currentLineEndpoints.length === 0);
                if (!pointNameValue) pointNameValue = isFirstEp ? "Punta de Línea 1" : "Punta de Línea 2";
            } else {
                pointCategory = 'intermediateStop';
                const currentIntermediateStops = routePoints.filter(p => p.pointCategory === 'intermediateStop');
                if (!pointNameValue) pointNameValue = `Parada ${currentIntermediateStops.length + 1}`;
            }

            const newPointData = {
                id: pointId, lat: latlng.lat, lng: latlng.lng, name: pointNameValue,
                pointCategory: pointCategory, originalIndex: routePoints.length, times: {}
            };

            if (pointCategory === 'lineEndpoint') {
                newPointData.isFirstEndpoint = isFirstEp;
                newPointData.times = isFirstEp ?
                    { departureOutbound: null, arrivalReturn: null } :
                    { arrivalOutbound: null, departureReturn: null };
            } else {
                newPointData.times = { scheduledIDA: null, scheduledVUELTA: null };
            }

            const newPoint = { ...newPointData };
            routePoints.push(newPoint);
            routePoints.sort((a,b) => a.originalIndex - b.originalIndex);
            routePoints.forEach((p, idx) => p.originalIndex = idx);


            newPoint.marker = L.marker(latlng, {
                icon: createDivIcon(pointNameValue, pointCategory, isFirstEp), draggable: true
            }).addTo(map);
            newPoint.radiusCircle = L.circle(latlng, {
                radius: currentStopRadius,
                color: (pointCategory === 'lineEndpoint' ? (isFirstEp ? '#FF8C00':'#DA70D6') : '#2196F3'),
                weight: 1, opacity: 0.5,
                fillColor: (pointCategory === 'lineEndpoint' ? (isFirstEp ? '#FF8C00':'#DA70D6') : '#2196F3'), fillOpacity: 0.2
            }).addTo(map);

            newPoint.marker.on('dragend', function(event) {
                if (isTracking) {event.target.setLatLng(L.latLng(newPoint.lat, newPoint.lng)); return; }
                const pos = event.target.getLatLng(); newPoint.lat = pos.lat; newPoint.lng = pos.lng;
                if (newPoint.radiusCircle) newPoint.radiusCircle.setLatLng(pos);
                redrawRouteLine();
                if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                updateStopsList();
            });
            newPoint.marker.on('click', function(ev) { L.DomEvent.stopPropagation(ev); if (isTracking) return; activateEditModeForPoint(newPoint); });

            nameInput.value = "";
            updateAllMarkerIconsAndLabels();
            if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
            redrawRouteLine();
            updateStopsList();
        }

        function getPathPointsForPolyline(flagNameToUse) {
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
            if (lineEndpoints.length < 2) return [];

            const p1 = lineEndpoints.find(p => p.isFirstEndpoint);
            const p2 = lineEndpoints.find(p => !p.isFirstEndpoint);

            if (!p1 || !p2) return [];

            const minEndpointIndex = Math.min(p1.originalIndex, p2.originalIndex);
            const maxEndpointIndex = Math.max(p1.originalIndex, p2.originalIndex);

            // Includes intermediate stops and waypoints between P1 and P2
            const intermediatePathPoints = routePoints
                .filter(p => p.id !== p1.id && p.id !== p2.id &&
                               p.originalIndex > minEndpointIndex && p.originalIndex < maxEndpointIndex)
                .sort((a, b) => a.originalIndex - b.originalIndex);

            let polylinePoints = [];
            if (flagNameToUse === routeSettings.flagNameIda) {
                polylinePoints.push(p1);
                polylinePoints.push(...intermediatePathPoints);
                polylinePoints.push(p2);
            } else { // VUELTA flag (typically routeSettings.flagNameVuelta)
                polylinePoints.push(p2);
                polylinePoints.push(...intermediatePathPoints.slice().reverse()); // Reverse order for VUELTA
                polylinePoints.push(p1);
            }
            return polylinePoints;
        }


        function calculateAndApplyAllIntermediateTimes() {
            const autoCalc = document.getElementById('autoCalcTimes').checked;
            if (!autoCalc) {
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => stop.times.scheduledVUELTA = null);
                updateStopsList(); return;
            }

            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint').sort((a,b)=>a.originalIndex - b.originalIndex);
            if (lineEndpoints.length < 2) { updateStopsList(); return; }

            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);
            if (!p1 || !p2) { updateStopsList(); return; }

            const minEpIdx = Math.min(p1.originalIndex, p2.originalIndex);
            const maxEpIdx = Math.max(p1.originalIndex, p2.originalIndex);

            const allOtherPointsBetween = routePoints
                .filter(rp => rp.id !== p1.id && rp.id !== p2.id &&
                               rp.originalIndex > minEpIdx && rp.originalIndex < maxEpIdx)
                .sort((a,b)=>a.originalIndex-b.originalIndex);


            if (p1.times.departureOutbound && p2.times.arrivalOutbound) {
                const idaLegPath = [p1, ...allOtherPointsBetween, p2];
                distributeTimesProportionally(idaLegPath, new Date(p1.times.departureOutbound), new Date(p2.times.arrivalOutbound), 'scheduledIDA');
            } else {
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => stop.times.scheduledIDA = null);
            }

            if (p2.times.departureReturn && p1.times.arrivalReturn) {
                const vueltaLegPath = [p2, ...allOtherPointsBetween.slice().reverse(), p1];
                distributeTimesProportionally(vueltaLegPath, new Date(p2.times.departureReturn), new Date(p1.times.arrivalReturn), 'scheduledVUELTA');
            } else {
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => stop.times.scheduledVUELTA = null);
            }
            updateStopsList();
        }

        function distributeTimesProportionally(legPathPoints, legStartTimeDate, legEndTimeDate, timeKey) {
            if (!legStartTimeDate || !legEndTimeDate || legPathPoints.length < 2) return;

            const legStartMillis = legStartTimeDate.getTime();
            const legEndMillis = legEndTimeDate.getTime();
            const totalDurationMillis = legEndMillis - legStartMillis;

            // Filter only intermediate stops from the leg path for time assignment
            const intermediateStopsInLeg = legPathPoints.slice(1, -1).filter(p => p.pointCategory === 'intermediateStop');

            if (totalDurationMillis <= 0) {
                intermediateStopsInLeg.forEach(p => p.times[timeKey] = null);
                return;
            }

            let totalDistance = 0;
            const segmentDistances = [];
            // Calculate distances between all consecutive points in the leg (stops, waypoints, endpoints)
            for (let i = 0; i < legPathPoints.length - 1; i++) {
                const dist = L.latLng(legPathPoints[i].lat, legPathPoints[i].lng)
                               .distanceTo(L.latLng(legPathPoints[i+1].lat, legPathPoints[i+1].lng));
                segmentDistances.push(dist);
                totalDistance += dist;
            }

            if (totalDistance < 1.0) { // If total distance is negligible, distribute time evenly among INTERMEDIATE STOPS
                const numTimeSegments = intermediateStopsInLeg.length + 1; // Segments between start, stops, and end
                if (numTimeSegments <= 0) return; // No intermediate stops to assign time to.
                const timePerSegment = totalDurationMillis / numTimeSegments;
                let currentTime = legStartMillis;
                // Assign times only to intermediate stops in their path order
                let currentPathPointIndex = 0;
                while(currentPathPointIndex < legPathPoints.length -1 && legPathPoints[currentPathPointIndex+1].pointCategory !== 'intermediateStop') {
                    currentPathPointIndex++; // Skip initial waypoints if any
                }

                for (let i = 0; i < intermediateStopsInLeg.length; i++) {
                    currentTime += timePerSegment;
                    intermediateStopsInLeg[i].times[timeKey] = new Date(currentTime);
                }

            } else {
                let accumulatedDistance = 0;
                // Iterate through all points in the leg path to calculate proportional time for INTERMEDIATE STOPS
                for (let i = 0; i < legPathPoints.length - 1; i++) {
                    accumulatedDistance += segmentDistances[i];
                    const nextPointInPath = legPathPoints[i+1];
                    // Only assign time if the next point is an intermediate stop
                    if (nextPointInPath.pointCategory === 'intermediateStop') {
                        const proportionOfRoute = accumulatedDistance / totalDistance;
                        const timeOffsetMillis = totalDurationMillis * proportionOfRoute;
                        nextPointInPath.times[timeKey] = new Date(legStartMillis + timeOffsetMillis);
                    }
                }
            }
        }

        function clearCurrentRoute() {
            cancelEdit();
            if (addingWaypointMode) toggleAddWaypointMode();
            routePoints.forEach(p => {
                if (p.marker) map.removeLayer(p.marker);
                if (p.radiusCircle) map.removeLayer(p.radiusCircle);
            });
            routePoints = [];
            if (routeLineIda) map.removeLayer(routeLineIda); routeLineIda = null;
            if (routeLineVuelta) map.removeLayer(routeLineVuelta); routeLineVuelta = null;
            document.getElementById('pointName').value = "";
            updateStopsList(); updateAllMarkerIconsAndLabels();
            redrawRouteLine(); // Explicitly call to clear lines from map
        }

        function redrawRouteLine() {
            if (routeLineIda) { map.removeLayer(routeLineIda); routeLineIda = null; }
            if (routeLineVuelta) { map.removeLayer(routeLineVuelta); routeLineVuelta = null; }

            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
            if (lineEndpoints.length < 2) return; // Not enough EPs to draw lines

            // IDA Polyline (Blue)
            const idaPolylinePathPoints = getPathPointsForPolyline(routeSettings.flagNameIda);
            if (idaPolylinePathPoints.length > 1) {
                const idaLatlngs = idaPolylinePathPoints.map(p => L.latLng(p.lat, p.lng));
                routeLineIda = L.polyline(idaLatlngs, {color: 'blue', weight: 5}).addTo(map);
            }

            // VUELTA Polyline (Red)
            const vueltaPolylinePathPoints = getPathPointsForPolyline(routeSettings.flagNameVuelta);
            if (vueltaPolylinePathPoints.length > 1) {
                const vueltaLatlngs = vueltaPolylinePathPoints.map(p => L.latLng(p.lat, p.lng));
                routeLineVuelta = L.polyline(vueltaLatlngs, {color: 'red', weight: 5}).addTo(map);
            }
        }

        function getSortedRoutePointsForDisplay() {
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
            const intermediateStops = routePoints.filter(p => p.pointCategory === 'intermediateStop').sort((a, b) => a.originalIndex - b.originalIndex);

            const sortedDisplayPoints = [];
            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);

            if (p1) sortedDisplayPoints.push(p1);

            if (p1 && p2) {
                const minIdx = Math.min(p1.originalIndex, p2.originalIndex);
                const maxIdx = Math.max(p1.originalIndex, p2.originalIndex);
                sortedDisplayPoints.push(...intermediateStops.filter(is => is.originalIndex > minIdx && is.originalIndex < maxIdx));
            } else { // Only p1, or no endpoints defined yet, add all intermediate stops after p1 (if p1 exists) or just all if no p1
                sortedDisplayPoints.push(...intermediateStops);
            }

            if (p2 && !sortedDisplayPoints.find(sdp => sdp.id === p2.id)) {
                 // Ensure P2 is added if it exists and wasn't part of an earlier push (e.g. if p1 doesn't exist)
                if (p1) { // p1 exists, p2 should come after intermediates
                    sortedDisplayPoints.push(p2);
                } else { // no p1, p2 could be first or after intermediates
                    const p2ExistingIndex = sortedDisplayPoints.findIndex(sdp => sdp.id === p2.id);
                    if (p2ExistingIndex === -1) sortedDisplayPoints.push(p2); // Add if not there
                    // Potentially re-sort if p2 should be at start or specific place without p1.
                    // For simplicity: P1 (if any), then intermediates (filtered if P1&P2, else all), then P2 (if any and not P1)
                }
            }
             // Deduplicate and ensure originalIndex sort for those not P1/P2 initially structured.
            let finalPoints = [];
            const addedIds = new Set();
            if(p1) { finalPoints.push(p1); addedIds.add(p1.id); }

            const intermediatesToAdd = [];
            if(p1 && p2) {
                const minIdx = Math.min(p1.originalIndex, p2.originalIndex);
                const maxIdx = Math.max(p1.originalIndex, p2.originalIndex);
                intermediateStops.filter(is => is.originalIndex > minIdx && is.originalIndex < maxIdx).forEach(s => {
                    if(!addedIds.has(s.id)) { intermediatesToAdd.push(s); addedIds.add(s.id); }
                });
            } else { // Add all intermediate stops if P1/P2 pair not complete
                 intermediateStops.forEach(s => {
                    if(!addedIds.has(s.id)) { intermediatesToAdd.push(s); addedIds.add(s.id); }
                });
            }
            intermediatesToAdd.sort((a,b) => a.originalIndex - b.originalIndex);
            finalPoints.push(...intermediatesToAdd);

            if(p2 && !addedIds.has(p2.id)) { finalPoints.push(p2); addedIds.add(p2.id); }

            // Add any remaining points (e.g., waypoints or stops outside P1/P2 if structure is unusual)
            // This part might be redundant if the above logic covers all cases.
            // For display, waypoints are usually not listed.
            // routePoints.filter(rp => !addedIds.has(rp.id) && rp.pointCategory !== 'waypoint').sort((a,b) => a.originalIndex - b.originalIndex).forEach(rp => finalPoints.push(rp));

            return finalPoints;
        }


        function formatTime(dateObj, includeDate = true) {
            if (!dateObj || isNaN(new Date(dateObj).getTime())) return "N/A";
            let timeStr = new Date(dateObj).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            if (includeDate) {
                 timeStr += ` (${new Date(dateObj).toLocaleDateString('es-ES', {day:'2-digit', month:'2-digit'})})`;
            }
            return timeStr;
        }

        function updateStopsList() {
            const listDiv = document.getElementById('stopsList');
            const displayPoints = getSortedRoutePointsForDisplay();

            if (displayPoints.length === 0) { listDiv.innerHTML = "No hay puntos definidos."; return; }

            let html = "<ul style='padding-left: 10px; list-style: none;'>"; // Changed to none for custom numbering/styling
            let intermediateVisualCounter = 1;
            displayPoints.forEach((p, index) => {
                let typeText = "", timeStr = "N/A";
                let itemClass = "stop-item";
                let prefix = `${index + 1}. `;

                if (p.pointCategory === 'lineEndpoint') {
                    itemClass += " line-endpoint-highlight";
                    typeText = p.isFirstEndpoint ? "Punta de Línea 1" : "Punta de Línea 2";
                    prefix = p.isFirstEndpoint ? "P1: " : "P2: ";
                    const dep = p.isFirstEndpoint ? p.times.departureOutbound : p.times.departureReturn;
                    const arr = p.isFirstEndpoint ? p.times.arrivalReturn : p.times.arrivalOutbound;
                    timeStr = `Sal: ${formatTime(dep, false)} / Lleg: ${formatTime(arr, false)}`;
                    if (dep || arr) timeStr += ` (${formatTime(dep || arr, true).split(' ')[1] || ''})`; // Show date once
                } else if (p.pointCategory === 'intermediateStop') {
                    typeText = `Parada`;
                    prefix = `${intermediateVisualCounter++}. `;
                    timeStr = `IDA: ${formatTime(p.times.scheduledIDA, false)} / VTA: ${formatTime(p.times.scheduledVUELTA, false)}`;
                     if (p.times.scheduledIDA || p.times.scheduledVUELTA) timeStr += ` (${formatTime(p.times.scheduledIDA || p.times.scheduledVUELTA, true).split(' ')[1] || ''})`;
                }
                html += `<li class="${itemClass}" onclick="focusPointOnMap('${p.id}')"><b>${prefix}${p.name}</b> (${typeText}) - ${timeStr}</li>`;
            });
            html += "</ul>";
            listDiv.innerHTML = html;
            highlightNextStopInList();
        }

        function focusPointOnMap(pointId) {
            const point = routePoints.find(p => p.id === pointId);
            if (point && map) {
                map.setView([point.lat, point.lng], Math.max(map.getZoom(), 16));
            }
        }

        function saveRoute() {
            const routeNameInput = document.getElementById('routeName');
            if (!routeNameInput.value) { alert("Por favor, ingresa un nombre para la ruta."); return; }

            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
            if (lineEndpoints.length < 2) {
                 alert("Una ruta debe tener dos Puntas de Línea definidas."); return;
            }
            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);
            if (!p1 || !p2 ||
                !p1.times.departureOutbound || !p1.times.arrivalReturn ||
                !p2.times.arrivalOutbound || !p2.times.departureReturn) {
                alert("Ambas Puntas de Línea deben tener sus 4 horarios clave definidos (Salida IDA y Llegada VUELTA para P1; Llegada IDA y Salida VUELTA para P2).");
                return;
            }

            const savablePoints = routePoints.map(p => {
                const pointData = {
                    id: p.id, lat: p.lat, lng: p.lng, name: p.name,
                    pointCategory: p.pointCategory,
                    originalIndex: p.originalIndex,
                    times: {}
                };
                if (p.pointCategory === 'lineEndpoint') {
                    pointData.isFirstEndpoint = p.isFirstEndpoint;
                    pointData.times.departureOutbound = p.times.departureOutbound ? new Date(p.times.departureOutbound).toISOString() : null;
                    pointData.times.arrivalReturn = p.times.arrivalReturn ? new Date(p.times.arrivalReturn).toISOString() : null;
                    pointData.times.arrivalOutbound = p.times.arrivalOutbound ? new Date(p.times.arrivalOutbound).toISOString() : null;
                    pointData.times.departureReturn = p.times.departureReturn ? new Date(p.times.departureReturn).toISOString() : null;
                } else if (p.pointCategory === 'intermediateStop') {
                    pointData.times.scheduledIDA = p.times.scheduledIDA ? new Date(p.times.scheduledIDA).toISOString() : null;
                    pointData.times.scheduledVUELTA = p.times.scheduledVUELTA ? new Date(p.times.scheduledVUELTA).toISOString() : null;
                }
                return pointData;
            });

            const routeDataToSave = { points: savablePoints, settings: routeSettings };
            localStorage.setItem(CACHE_PREFIX + routeNameInput.value, JSON.stringify(routeDataToSave));
            alert(`Ruta "${routeNameInput.value}" guardada.`);
            loadSavedRoutesLists();
        }

        function loadRoute() {
            cancelEdit();
            if (addingWaypointMode) toggleAddWaypointMode();
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) { alert("Selecciona una ruta para cargar."); return; }
            const savedDataRaw = localStorage.getItem(CACHE_PREFIX + selectedRouteName);
            if (!savedDataRaw) { alert("Error al cargar la ruta."); return; }

            clearCurrentRoute();
            const loadedRouteData = JSON.parse(savedDataRaw);
            const loadedPointsData = loadedRouteData.points;
            routeSettings = loadedRouteData.settings || { totalTurns: 1, flagNameIda: "IDA", flagNameVuelta: "VUELTA"};

            document.getElementById('totalTurnsInput').value = routeSettings.totalTurns;
            document.getElementById('flagNameIdaInput').value = routeSettings.flagNameIda;
            document.getElementById('flagNameVueltaInput').value = routeSettings.flagNameVuelta;
            trackingState.currentFlag = routeSettings.flagNameIda; // Default to IDA on load

            loadedPointsData.forEach((p_data) => {
                const newPointBase = { ...p_data, times: {} };

                if (p_data.pointCategory === 'lineEndpoint') {
                    newPointBase.isFirstEndpoint = p_data.isFirstEndpoint;
                    newPointBase.times.departureOutbound = p_data.times.departureOutbound ? new Date(p_data.times.departureOutbound) : null;
                    newPointBase.times.arrivalReturn = p_data.times.arrivalReturn ? new Date(p_data.times.arrivalReturn) : null;
                    newPointBase.times.arrivalOutbound = p_data.times.arrivalOutbound ? new Date(p_data.times.arrivalOutbound) : null;
                    newPointBase.times.departureReturn = p_data.times.departureReturn ? new Date(p_data.times.departureReturn) : null;
                } else if (p_data.pointCategory === 'intermediateStop') {
                     newPointBase.times.scheduledIDA = p_data.times.scheduledIDA ? new Date(p_data.times.scheduledIDA) : null;
                     newPointBase.times.scheduledVUELTA = p_data.times.scheduledVUELTA ? new Date(p_data.times.scheduledVUELTA) : null;
                }
                // Waypoints will have times from p_data.times if saved, or empty {} if not.
                if (p_data.times) newPointBase.times = {...newPointBase.times, ...p_data.times};


                const newPoint = { ...newPointBase };
                routePoints.push(newPoint);
            });
            routePoints.sort((a,b) => a.originalIndex - b.originalIndex);
            routePoints.forEach((p, idx) => p.originalIndex = idx); // Ensure originalIndex is contiguous

            routePoints.forEach(p => {
                 p.marker = L.marker([p.lat, p.lng], {
                    icon: createDivIcon(p.name, p.pointCategory, p.isFirstEndpoint),
                    draggable: true
                }).addTo(map);
                 if (p.pointCategory !== 'waypoint') {
                    p.radiusCircle = L.circle([p.lat, p.lng], {
                        radius: currentStopRadius,
                        color: (p.pointCategory === 'lineEndpoint' ? (p.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'),
                        weight: 1, opacity: 0.5,
                        fillColor: (p.pointCategory === 'lineEndpoint' ? (p.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'), fillOpacity: 0.2
                    }).addTo(map);
                    p.marker.on('click', function(ev) {L.DomEvent.stopPropagation(ev); if(isTracking)return; activateEditModeForPoint(p); });
                 } else { // Waypoint
                    p.marker.on('click', function(ev) {
                        L.DomEvent.stopPropagation(ev); if (isTracking) return;
                        if (confirm(`¿Borrar este punto de paso "${p.name}"?`)) {
                            map.removeLayer(p.marker);
                            routePoints = routePoints.filter(rp => rp.id !== p.id);
                            routePoints.forEach((rp_idx, idx) => rp_idx.originalIndex = idx); // Re-index
                            redrawRouteLine();
                            if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                        }
                    });
                 }
                 p.marker.on('dragend', function(event){
                    if (isTracking) { event.target.setLatLng(L.latLng(p.lat, p.lng)); return; }
                    const pos = event.target.getLatLng(); p.lat = pos.lat; p.lng = pos.lng;
                    if (p.radiusCircle) p.radiusCircle.setLatLng(pos);
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                    updateStopsList();
                });
            });

            updateAllMarkerIconsAndLabels();
            updateWaypointMarkersVisibility(); // Ensure waypoints are shown correctly
            redrawRouteLine();
            updateStopsList();

            const boundsPoints = routePoints.filter(p => p.pointCategory !== 'waypoint');
            if (boundsPoints.length > 0) {
                const bounds = L.latLngBounds(boundsPoints.map(p => [p.lat, p.lng]));
                if (bounds.isValid()) map.fitBounds(bounds);
            }
            document.getElementById('routeName').value = selectedRouteName;
            alert(`Ruta "${selectedRouteName}" cargada.`);
        }

        function deleteRoute() {
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) { alert("Selecciona una ruta para borrar."); return; }
            if (confirm(`¿Estás seguro de que quieres borrar la ruta "${selectedRouteName}"?`)) {
                localStorage.removeItem(CACHE_PREFIX + selectedRouteName);
                let queue = getRouteQueue();
                queue = queue.filter(name => name !== selectedRouteName);
                saveRouteQueue(queue);
                loadSavedRoutesLists();
                alert(`Ruta "${selectedRouteName}" borrada.`);
            }
        }

        function loadSavedRoutesLists() {
            const savedRoutesSelect = document.getElementById('savedRoutes');
            const routeToQueueSelect = document.getElementById('routeToQueue');
            const currentSavedRouteValue = savedRoutesSelect.value;
            const currentQueueRouteValue = routeToQueueSelect.value;

            savedRoutesSelect.innerHTML = ""; routeToQueueSelect.innerHTML = "";
            let hasRoutes = false;
            const routeNames = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(CACHE_PREFIX)) routeNames.push(key.substring(CACHE_PREFIX.length));
            }
            routeNames.sort();
            routeNames.forEach(routeName => {
                const option = document.createElement('option');
                option.value = routeName; option.textContent = routeName;
                savedRoutesSelect.appendChild(option.cloneNode(true));
                routeToQueueSelect.appendChild(option.cloneNode(true));
                hasRoutes = true;
            });
            if (!hasRoutes) {
                 const option = document.createElement('option');
                 option.textContent = "No hay rutas guardadas"; option.disabled = true;
                 savedRoutesSelect.appendChild(option.cloneNode(true));
                 routeToQueueSelect.appendChild(option);
            } else {
                if (routeNames.includes(currentSavedRouteValue)) savedRoutesSelect.value = currentSavedRouteValue;
                else if (savedRoutesSelect.options.length > 0) savedRoutesSelect.selectedIndex = 0;

                if (routeNames.includes(currentQueueRouteValue)) routeToQueueSelect.value = currentQueueRouteValue;
                else if (routeToQueueSelect.options.length > 0) routeToQueueSelect.selectedIndex = 0;
            }
            updateRouteQueueDisplay();
        }

        function setupCurrentLegForTracking() {
            trackingState.activeLegPoints = [];
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint').sort((a,b) => a.originalIndex - b.originalIndex);
            if (lineEndpoints.length < 2) { console.error("Not enough line endpoints for tracking."); return false; }

            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);
            if (!p1 || !p2) { console.error("Cannot identify P1/P2 for tracking."); return false; }

            const minEpIdx = Math.min(p1.originalIndex, p2.originalIndex);
            const maxEpIdx = Math.max(p1.originalIndex, p2.originalIndex);

            // All points (intermediate stops AND waypoints) between P1 and P2
            const allIntermediatePathPoints = routePoints
                .filter(rp => rp.id !== p1.id && rp.id !== p2.id &&
                               rp.originalIndex > minEpIdx && rp.originalIndex < maxEpIdx)
                .sort((a,b) => a.originalIndex - b.originalIndex);

            let currentLegStartPoint, currentLegEndPoint, legScheduledStartTime, legScheduledEndTime, timeKeyForIntermediate;
            let legPathPointsOrdered = []; // Includes endpoints, intermediate stops, and waypoints for this leg

            if (trackingState.currentFlag === routeSettings.flagNameIda) {
                currentLegStartPoint = p1; currentLegEndPoint = p2;
                legScheduledStartTime = p1.times.departureOutbound; legScheduledEndTime = p2.times.arrivalOutbound;
                timeKeyForIntermediate = 'scheduledIDA';
                legPathPointsOrdered = [p1, ...allIntermediatePathPoints, p2];
            } else { // VUELTA
                currentLegStartPoint = p2; currentLegEndPoint = p1;
                legScheduledStartTime = p2.times.departureReturn; legScheduledEndTime = p1.times.arrivalReturn;
                timeKeyForIntermediate = 'scheduledVUELTA';
                legPathPointsOrdered = [p2, ...allIntermediatePathPoints.slice().reverse(), p1];
            }

            if (!legScheduledStartTime || !legScheduledEndTime) {
                 alert(`Horarios incompletos para la bandera ${trackingState.currentFlag} (Vuelta ${trackingState.currentTurn}).\nPunto Inicial: ${currentLegStartPoint.name} - Salida Programada: ${legScheduledStartTime}\nPunto Final: ${currentLegEndPoint.name} - Llegada Programada: ${legScheduledEndTime}`);
                 return false;
            }

            trackingState.activeLegPoints = legPathPointsOrdered.map(point => {
                let effTime = null;
                if (point.id === currentLegStartPoint.id) effTime = new Date(legScheduledStartTime);
                else if (point.id === currentLegEndPoint.id) effTime = new Date(legScheduledEndTime);
                else if (point.pointCategory === 'intermediateStop' && point.times[timeKeyForIntermediate]) {
                    effTime = new Date(point.times[timeKeyForIntermediate]);
                }
                // Waypoints will have effTime = null, which is fine for deviation calculation (it skips them)
                return { ...point, effectiveScheduledTime: effTime };
            });
            return true;
        }


        function startTracking() {
            if (addingWaypointMode) toggleAddWaypointMode();
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
            if (lineEndpoints.length < 2) { alert("La ruta debe tener dos Puntas de Línea definidas."); return; }
            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);
            if (!p1 || !p2 || !p1.times.departureOutbound || !p1.times.arrivalReturn || !p2.times.arrivalOutbound || !p2.times.departureReturn) {
                alert("Ambas Puntas de Línea deben tener sus 4 horarios clave definidos para iniciar el seguimiento."); return;
            }

            isTracking = true;
            trackingState.currentTurn = 1;
            trackingState.currentFlag = routeSettings.flagNameIda;
            currentSegmentStartIndex = 0;

            if (!setupCurrentLegForTracking()) {
                stopTracking(false, "Error configurando la pierna inicial del recorrido."); return;
            }

            document.getElementById('startTrackingBtn').style.display = 'none';
            document.getElementById('stopTrackingBtn').style.display = 'inline-block';
            document.getElementById('routeCreationSection').style.display = 'none';
            updateTrackingStatusDisplay();
            // redrawRouteLine(); // Already drawn, but ensures current flag colors if that logic was tied to trackingState.currentFlag

            if (navigator.geolocation) {
                trackingIntervalId = navigator.geolocation.watchPosition(
                    handlePositionUpdate, handleGeolocationError,
                    { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 }
                );
                if (trackingState.activeLegPoints.length > 0) {
                    map.setView([trackingState.activeLegPoints[0].lat, trackingState.activeLegPoints[0].lng], 16);
                }
                highlightNextStopInList();
            } else {
                alert("Geolocalización no disponible."); stopTracking(false);
            }
            updateManualNavButtons();
        }

        function stopTracking(completedNaturally = false, reason = "") {
            if (trackingIntervalId) navigator.geolocation.clearWatch(trackingIntervalId);
            trackingIntervalId = null; isTracking = false; lastKnownPosition = null;
            document.getElementById('startTrackingBtn').style.display = 'inline-block';
            document.getElementById('stopTrackingBtn').style.display = 'none';
            document.getElementById('routeCreationSection').style.display = 'block';
            if (userMarker) { map.removeLayer(userMarker); userMarker = null; }

            // trackingState.currentFlag = routeSettings.flagNameIda; // Reset for display if needed, or keep last flag
            // redrawRouteLine(); // Polylines are always visible, no need to redraw based on tracking state changes alone.
            updateStopsList(); // Clear highlights
            currentSegmentStartIndex = 0;
            updateManualNavButtons();

            if (completedNaturally) {
                document.getElementById('trackingInfoDisplay').textContent = "RUTA COMPLETADA";
                alert("Ruta completada!"); checkRouteQueue();
            } else {
                const msg = "Seguimiento detenido." + (reason ? " Razón: " + reason : "");
                console.log(msg); if (reason && reason !== "Error de geolocalización") alert(msg); // Avoid double alert
                document.getElementById('trackingInfoDisplay').textContent = "SEGUIMIENTO DETENIDO";
            }
             // Ensure the full status display section is updated correctly after stopping
            updateTrackingStatusDisplay();
            highlightNextStopInList(); // Clear highlights or show initial next stop
        }

        function updateTrackingStatusDisplay() {
            if (!isTracking) {
                // If not tracking, show status if a message like "RUTA COMPLETADA" is set, otherwise hide.
                const statusText = document.getElementById('trackingInfoDisplay').textContent;
                if (statusText === "RUTA COMPLETADA" || statusText === "SEGUIMIENTO DETENIDO") {
                     document.getElementById('statusDisplay').style.display = 'block';
                } else {
                    document.getElementById('statusDisplay').style.display = 'none';
                }
                return;
            }

            document.getElementById('statusDisplay').style.display = 'block';
            document.getElementById('trackingInfoDisplay').textContent =
                `Vuelta: ${trackingState.currentTurn}/${routeSettings.totalTurns} - Bandera: ${trackingState.currentFlag}`;
        }


        function updateManualNavButtons() {
            const manualNav = document.getElementById('manualStopNav').checked;
            const prevBtn = document.getElementById('prevStopBtn');
            const nextBtn = document.getElementById('nextStopBtn');

            if (isTracking && manualNav && trackingState.activeLegPoints.length > 0) {
                prevBtn.style.display = 'inline-block';
                nextBtn.style.display = 'inline-block';
                prevBtn.disabled = currentSegmentStartIndex === 0;
                nextBtn.disabled = currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1;
            } else {
                prevBtn.style.display = 'none'; nextBtn.style.display = 'none';
            }
        }

        function handlePositionUpdate(position) {
            lastKnownPosition = position;
            const { latitude, longitude, speed } = position.coords;
            if (!userMarker) userMarker = L.marker([latitude, longitude], { icon: createUserLocationIcon() }).addTo(map);
            else userMarker.setLatLng([latitude, longitude]);
            map.panTo([latitude, longitude], {animate: true, duration: 0.5});
            document.getElementById('speedDisplay').textContent = `Velocidad: ${(speed ? (speed * 3.6) : 0).toFixed(1)} KM/H`;

            if (currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) {
                // This means we are at or past the last point of the current leg.
                // handleEndOfLeg should be called if we just arrived. If it was already called, this is fine.
                // Or, if manual navigation put us here.
                // To prevent errors, ensure we don't try to access points beyond array bounds.
                calculateTimeDeviation(position); // Calculate deviation based on arrival at final point
                return;
            }

            const manualNav = document.getElementById('manualStopNav').checked;
            let advancedThisTick = false;

            if (!manualNav) {
                const currentTargetPoint = trackingState.activeLegPoints[currentSegmentStartIndex + 1];
                // Only advance automatically for non-waypoint targets
                if (currentTargetPoint.pointCategory !== 'waypoint') {
                    const distanceToTarget = L.latLng(latitude, longitude).distanceTo(L.latLng(currentTargetPoint.lat, currentTargetPoint.lng));
                    if (distanceToTarget < currentStopRadius) {
                        advanceToNextActivePoint(); advancedThisTick = true;
                    }
                } else {
                    // For waypoints, if auto-navigating, how to advance?
                    // Option 1: require manual advance for waypoints.
                    // Option 2: advance past waypoints if very close (e.g., < 10-20m).
                    // Current logic: manual nav or proximity to non-waypoints. Let's keep it.
                    // So, waypoints are effectively "passed through" when calculating deviation,
                    // but only non-waypoints trigger automatic advance.
                }
            }
            // Recalculate deviation based on new position, unless an advance just happened (which will recall it)
            if (!advancedThisTick && currentSegmentStartIndex < trackingState.activeLegPoints.length -1) {
                 calculateTimeDeviation(position);
            }
        }

        function advanceToNextActivePoint() {
            currentSegmentStartIndex++;
            if (currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) {
                // Reached or passed the end of the current leg's defined points
                handleEndOfLeg();
            } else {
                highlightNextStopInList(); updateManualNavButtons();
                if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition);
            }
        }


        function handleEndOfLeg() {
            // This function is called when currentSegmentStartIndex points to the last point of the leg
            // or if advanceToNextActivePoint moves past it.

            // Check if this was the end of the IDA leg
            if (trackingState.currentFlag === routeSettings.flagNameIda) {
                trackingState.currentFlag = routeSettings.flagNameVuelta; // Switch to VUELTA
            } else { // This was the end of the VUELTA leg
                trackingState.currentTurn++; // Increment turn count
                if (trackingState.currentTurn > routeSettings.totalTurns) {
                    stopTracking(true); // All turns completed
                    return;
                }
                trackingState.currentFlag = routeSettings.flagNameIda; // Switch back to IDA for new turn
            }

            currentSegmentStartIndex = 0; // Reset for the new leg
            if (!setupCurrentLegForTracking()) {
                 stopTracking(false, `Error configurando la pierna ${trackingState.currentFlag} (Vuelta ${trackingState.currentTurn}).`); return;
            }

            updateTrackingStatusDisplay();
            // redrawRouteLine(); // Polylines are static, currentFlag for tracking doesn't change their display
            highlightNextStopInList();
            updateManualNavButtons();
            if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition); // Recalc for start of new leg

            if (trackingState.activeLegPoints.length > 0) { // Center map on start of new leg
                map.setView([trackingState.activeLegPoints[0].lat, trackingState.activeLegPoints[0].lng], map.getZoom());
            }
        }

        function goToPreviousActivePoint() {
            if (!isTracking || currentSegmentStartIndex === 0) return;
            currentSegmentStartIndex--;
            highlightNextStopInList(); updateManualNavButtons();
            if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition);
        }
        function goToNextActivePoint() {
            if (!isTracking || currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) return;
            advanceToNextActivePoint(); // This will handle end of leg if necessary
        }

        function highlightNextStopInList() {
            document.querySelectorAll('#stopsList .stop-item').forEach(item => item.classList.remove('next-stop-highlight'));
            let nextStopName = "N/A";

            if (isTracking && trackingState.activeLegPoints.length > 0 &&
                currentSegmentStartIndex < trackingState.activeLegPoints.length - 1) {

                // Find the next *displayable* point in the active leg (not a waypoint)
                let displayableNextTarget = null;
                for(let i = currentSegmentStartIndex + 1; i < trackingState.activeLegPoints.length; i++){
                    if(trackingState.activeLegPoints[i].pointCategory !== 'waypoint'){
                        displayableNextTarget = trackingState.activeLegPoints[i];
                        break;
                    }
                }
                // If only waypoints left, or at the very end, target might be the final endpoint itself.
                if (!displayableNextTarget && trackingState.activeLegPoints.length > currentSegmentStartIndex + 1) {
                    displayableNextTarget = trackingState.activeLegPoints[trackingState.activeLegPoints.length -1]; // Default to actual last point if no intermediate stops found after current
                }


                if (displayableNextTarget) {
                    nextStopName = displayableNextTarget.name;
                    const displayPoints = getSortedRoutePointsForDisplay(); // These are only stops/endpoints
                    const displayIndex = displayPoints.findIndex(dp => dp.id === displayableNextTarget.id);

                    if (displayIndex !== -1) {
                        const listItems = document.querySelectorAll('#stopsList .stop-item');
                        if (listItems[displayIndex]) {
                            listItems[displayIndex].classList.add('next-stop-highlight');
                            listItems[displayIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }
                    }
                }
            } else if (!isTracking) {
                const displayPoints = getSortedRoutePointsForDisplay();
                if (displayPoints.length > 0 && displayPoints[0].pointCategory !== 'waypoint') {
                    nextStopName = displayPoints[0].name;
                }
            }
            document.getElementById('nextStopDisplay').textContent = `Próxima: ${nextStopName}`;
        }


        function calculateTimeDeviation(currentUserGeoPosition) {
            if (!isTracking || currentSegmentStartIndex >= trackingState.activeLegPoints.length -1 && trackingState.activeLegPoints.length > 0) {
                 // If at the last point of the leg, calculate deviation against its scheduled time
                const lastPoint = trackingState.activeLegPoints[trackingState.activeLegPoints.length - 1];
                if (lastPoint && lastPoint.effectiveScheduledTime) {
                    const deviationMillis = new Date(lastPoint.effectiveScheduledTime).getTime() - new Date().getTime();
                    displayDeviation(deviationMillis);
                } else {
                    document.getElementById('timeDeviation').textContent = "FIN"; // Or "N/A_T_END"
                    document.getElementById('timeDeviation').style.color = "#FFFFFF";
                }
                return;
            }
             if(trackingState.activeLegPoints.length === 0) {
                document.getElementById('timeDeviation').textContent = "N/A_LEGP";
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                return;
            }


            const pointA = trackingState.activeLegPoints[currentSegmentStartIndex];
            const pointB = trackingState.activeLegPoints[currentSegmentStartIndex + 1];

            if (!pointA || !pointB || !pointA.effectiveScheduledTime || !pointB.effectiveScheduledTime ||
                pointA.pointCategory === 'waypoint' || pointB.pointCategory === 'waypoint') {
                // If current segment involves a waypoint or missing times, can't calculate deviation for this segment
                // Try to find next segment with valid times or show N/A
                let nextValidA = pointA, nextValidB = pointB;
                let tempStartIndex = currentSegmentStartIndex;

                while(tempStartIndex < trackingState.activeLegPoints.length - 1 &&
                      (!nextValidA.effectiveScheduledTime || !nextValidB.effectiveScheduledTime || nextValidA.pointCategory === 'waypoint' || nextValidB.pointCategory === 'waypoint')) {
                    tempStartIndex++;
                    if (tempStartIndex < trackingState.activeLegPoints.length -1) {
                        nextValidA = trackingState.activeLegPoints[tempStartIndex];
                        nextValidB = trackingState.activeLegPoints[tempStartIndex + 1];
                    } else { // Reached end of leg searching
                        document.getElementById('timeDeviation').textContent = "N/A_WPT";
                        document.getElementById('timeDeviation').style.color = "#FFFFFF";
                        return;
                    }
                }
                // If loop finished and still invalid, then N/A (already handled by return above)
                // If a valid segment was found, use those points for deviation (this is complex, implies current location compared to a future segment)
                // For simplicity: if current segment involves waypoint or no time, show N/A for time.
                document.getElementById('timeDeviation').textContent = "N/A_SEG";
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                return;
            }

            const scheduledTimeA = new Date(pointA.effectiveScheduledTime);
            const scheduledTimeB = new Date(pointB.effectiveScheduledTime);
            const segmentTotalScheduledMillis = scheduledTimeB.getTime() - scheduledTimeA.getTime();

            if (segmentTotalScheduledMillis < 0 ) { // Allow zero duration for same point.
                document.getElementById('timeDeviation').textContent = "ERR_DUR";
                document.getElementById('timeDeviation').style.color = "#FFA500"; // Orange for warning
                return;
            }
             if (segmentTotalScheduledMillis === 0 && pointA.id === pointB.id) { // Coincident points (e.g. start of leg)
                const deviationMillis = scheduledTimeA.getTime() - new Date().getTime();
                displayDeviation(deviationMillis);
                return;
            }


            const latLngA = L.latLng(pointA.lat, pointA.lng);
            const latLngB = L.latLng(pointB.lat, pointB.lng);
            const currentUserLatLng = L.latLng(currentUserGeoPosition.coords.latitude, currentUserGeoPosition.coords.longitude);
            const distanceTotalSegment = latLngA.distanceTo(latLngB);
            let progressPercentage;

            if (distanceTotalSegment < 1.0) { // Segment is very short or points are coincident
                // If points are effectively same, use average of their scheduled times or time of B if user is closer to B
                 const now = new Date().getTime();
                 let expectedTimeAtCurrentPosMillis;

                 // If duration is zero, check against A or B.
                 if (segmentTotalScheduledMillis === 0) {
                     expectedTimeAtCurrentPosMillis = scheduledTimeA.getTime(); // or B, they are same
                 } else {
                     // If user is past midpoint of scheduled time, compare to B's time. Else A's time.
                    if (now > (scheduledTimeA.getTime() + segmentTotalScheduledMillis / 2)) {
                        expectedTimeAtCurrentPosMillis = scheduledTimeB.getTime();
                    } else {
                        expectedTimeAtCurrentPosMillis = scheduledTimeA.getTime();
                    }
                 }
                const deviationMillisSpecial = expectedTimeAtCurrentPosMillis - now;
                displayDeviation(deviationMillisSpecial);
                return;
            }

            // Standard progress calculation
            const distToA = currentUserLatLng.distanceTo(latLngA);
            const distToB = currentUserLatLng.distanceTo(latLngB);

            if (distToA < 10.0) progressPercentage = 0.0; // At or very near A
            else if (distToB < 10.0) progressPercentage = 1.0; // At or very near B
            // Check if user is past B along the line A-B extension
            else if ( (distToA > distanceTotalSegment) && (Math.abs(distToA - (distanceTotalSegment + distToB)) < Math.max(20, distanceTotalSegment * 0.1)) ) {
                 progressPercentage = 1.0;
            }
            // Check if user is before A along the line B-A extension
            else if ( (distToB > distanceTotalSegment) && (Math.abs(distToB - (distanceTotalSegment + distToA)) < Math.max(20, distanceTotalSegment * 0.1)) ) {
                 progressPercentage = 0.0;
            }
            else { // Projection method for user between A and B (or close to the segment)
                const dist_A_to_P_prime_on_AB = (Math.pow(distanceTotalSegment, 2) + Math.pow(distToA, 2) - Math.pow(distToB, 2)) / (2 * distanceTotalSegment);
                progressPercentage = dist_A_to_P_prime_on_AB / distanceTotalSegment;
            }
            progressPercentage = Math.max(0, Math.min(1, progressPercentage));


            const expectedTimeElapsedMillis = segmentTotalScheduledMillis * progressPercentage;
            const expectedTimeAtCurrentPosition = new Date(scheduledTimeA.getTime() + expectedTimeElapsedMillis);
            const currentTime = new Date();
            const deviationMillis = expectedTimeAtCurrentPosition.getTime() - currentTime.getTime();
            displayDeviation(deviationMillis);
        }

        function displayDeviation(deviationMillis) {
            const absMillis = Math.abs(deviationMillis);
            const totalSecondsValue = Math.floor(absMillis / 1000);
            const displaySeconds = totalSecondsValue % 60;
            const totalMinutesValue = Math.floor(totalSecondsValue / 60);
            const sign = deviationMillis >= 0 ? "+" : "-"; // Positive means ahead/early, Negative means behind/late
            const formattedDeviation = `${sign}${String(totalMinutesValue).padStart(2, '0')}:${String(displaySeconds).padStart(2, '0')}`;
            const deviationDiv = document.getElementById('timeDeviation');
            deviationDiv.textContent = formattedDeviation;

            // Color coding: Green for early, Red for late, White for on-time (e.g. +/- 1 minute)
            if (deviationMillis > 59999) deviationDiv.style.color = "#00FF00"; // More than 1 min early (Green)
            else if (deviationMillis < -59999) deviationDiv.style.color = "#FF0000"; // More than 1 min late (Red)
            else deviationDiv.style.color = "#FFFFFF"; // Within +/- 1 min (White)
        }
        function handleGeolocationError(error) {
            console.error("Error de geolocalización: ", error);
            alert(`Error de geolocalización: ${error.message}. El seguimiento puede no funcionar correctamente.`);
            if (isTracking) stopTracking(false, "Error de geolocalización");
        }

        function getRouteQueue() { const q = localStorage.getItem(ROUTE_QUEUE_CACHE_KEY); return q ? JSON.parse(q) : [];}
        function saveRouteQueue(queue) { localStorage.setItem(ROUTE_QUEUE_CACHE_KEY, JSON.stringify(queue)); updateRouteQueueDisplay();}
        function addRouteToQueue() {
            const selectedRouteName = document.getElementById('routeToQueue').value;
            if (!selectedRouteName || document.getElementById('routeToQueue').options[0]?.disabled && document.getElementById('routeToQueue').options.length === 1) {
                alert("Selecciona una ruta válida para añadir o no hay rutas guardadas."); return;
            }
            const queue = getRouteQueue(); if (queue.includes(selectedRouteName)) { alert("Ruta ya en cola."); return; }
            queue.push(selectedRouteName); saveRouteQueue(queue); alert(`Ruta "${selectedRouteName}" añadida.`);
        }
        function updateRouteQueueDisplay() {
            const queueDiv = document.getElementById('routeQueueDisplay'); const queue = getRouteQueue();
            if (queue.length === 0) { queueDiv.innerHTML = "Vacía."; }
            else { let html = "<ol style='padding-left: 20px;'>"; queue.forEach(rn => { html += `<li>${rn}</li>`; }); html += "</ol>"; queueDiv.innerHTML = html; }
        }
        function clearRouteQueue() { if (confirm("¿Limpiar toda la cola?")) saveRouteQueue([]);}
        function checkRouteQueue() {
            let queue = getRouteQueue();
            if (queue.length > 0) {
                const nextRouteName = queue.shift(); saveRouteQueue(queue);
                if (confirm(`Ruta finalizada. ¿Iniciar siguiente ruta en cola: "${nextRouteName}"?`)) {
                    const savedRoutesSelect = document.getElementById('savedRoutes');
                    // Check if the route exists in the dropdown
                    let routeExists = false;
                    for(let i=0; i<savedRoutesSelect.options.length; i++){
                        if(savedRoutesSelect.options[i].value === nextRouteName) {
                            routeExists = true; break;
                        }
                    }

                    if (routeExists) {
                        savedRoutesSelect.value = nextRouteName;
                        loadRoute(); // This loads the route data
                        // Ensure loadRoute is complete and valid before starting tracking
                        setTimeout(() => {
                            if (routePoints.filter(p=>p.pointCategory==='lineEndpoint').length >=2) {
                                startTracking();
                            } else {
                                alert(`Error al cargar la ruta "${nextRouteName}" de la cola o la ruta es inválida (faltan puntas de línea).`);
                            }
                        }, 500); // Delay to allow loadRoute to process
                    } else {
                        alert(`La ruta "${nextRouteName}" de la cola ya no existe o no pudo ser encontrada.`);
                    }
                } else {
                    alert("Siguiente ruta de la cola no iniciada.");
                }
            }
        }


        function updateGlobalStopRadiusSettings() {
            const newRadius = parseInt(document.getElementById('stopRadiusInput').value, 10);
            if (!isNaN(newRadius) && newRadius >= 10 && newRadius <= 500) {
                currentStopRadius = newRadius;
                routePoints.forEach(point => {
                    if (point.radiusCircle) point.radiusCircle.setRadius(currentStopRadius);
                });
            } else {
                alert("Radio inválido (debe estar entre 10 y 500 metros).");
                document.getElementById('stopRadiusInput').value = currentStopRadius; // Reset to valid value
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadSavedRoutesLists();
            updateStopsList();
            updateManualNavButtons();
            updateWaypointMarkersVisibility(); // Ensure waypoints visible if any loaded initially
            updateTrackingStatusDisplay(); // Set initial display state of status section
            redrawRouteLine(); // Draw initial empty or loaded route lines
        });

    </script>
</body>
</html>
