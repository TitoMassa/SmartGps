<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            overflow: hidden; /* Prevent body scroll */
            display: flex;
            flex-direction: column;
        }

        #map {
            height: 50vh; /* 50% of viewport height */
            width: 100%;
            background-color: #333; /* Placeholder color */
        }

        #controls {
            height: 50vh; /* 50% of viewport height */
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .control-section:last-child {
            border-bottom: none;
        }

        h2, h3 {
            color: #FFFFFF;
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="text"], input[type="datetime-local"], input[type="number"], select {
            width: calc(100% - 12px);
            padding: 8px;
            margin-bottom: 10px;
            background-color: #222;
            color: #FFF;
            border: 1px solid #555;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        button:hover {
            background-color: #45a049;
        }
        button.danger {
            background-color: #f44336;
        }
        button.danger:hover {
            background-color: #da190b;
        }
        button.secondary {
            background-color: #007bff;
        }
        button.secondary:hover {
            background-color: #0056b3;
        }
        button.info {
            background-color: #17a2b8;
        }
        button.info:hover {
            background-color: #117a8b;
        }
        button.active-mode-button {
            background-color: #ff9800; /* Orange to show it's active */
            color: black;
            font-weight: bold;
        }
        button.active-mode-button:hover {
            background-color: #e68a00;
        }


        #statusDisplay {
            text-align: center;
            padding: 10px;
        }
        #timeDeviation {
            font-size: 3em; /* Larger font for time deviation */
            font-weight: bold;
            margin: 10px 0;
        }
        #trackingInfoDisplay, #speedDisplay, #nextStopDisplay {
            font-size: 1.2em;
            margin: 5px 0;
        }

        .stop-item {
            background-color: #1e1e1e;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
            cursor: pointer;
        }
        .stop-item:hover {
            background-color: #2f2f2f;
        }
        .stop-item.next-stop-highlight {
            background-color: #007bff;
            font-weight: bold;
        }
        .stop-item.line-endpoint-highlight {
            border-left: 3px solid #ffc107; /* Yellow border for line endpoints */
        }


        .leaflet-div-icon {
            background: transparent;
            border: none;
            text-align: center;
            font-weight: bold;
            color: white;
        }
        .waypoint-marker-icon { 
            background-color:#888888 !important; 
            width: 10px !important; 
            height: 10px !important; 
            border-radius: 50% !important; 
            border: 1px solid #FFFFFF !important; 
            box-sizing: border-box !important;
        }


        .user-location-icon {
            background-color: #007bff !important; /* Blue dot */
            border-radius: 50%;
            width: 16px !important;
            height: 16px !important;
            border: 2px solid white;
            box-shadow: 0 0 0 2px #007bff;
        }
    </style>
</head>
<body>

    <div id="map"></div>
    <div id="controls">
        <div id="statusDisplay" style="display: none;">
            <div id="trackingInfoDisplay">Vuelta: 1/1 - Bandera: IDA</div>
            <div id="timeDeviation">00:00</div>
            <div id="speedDisplay">Velocidad: 0 KM/H</div>
            <div id="nextStopDisplay">Próxima Parada: N/A</div>
        </div>

        <div class="control-section" id="routeCreationSection">
            <h3>Crear/Modificar Ruta</h3>
            <p style="font-size: 0.8em;">
                Utiliza los botones de modo para gestionar la ruta. Para añadir puntos (Paso, Parada, Punta de Línea), activa el modo correspondiente y luego toca el mapa.
                Para editar un punto existente, tócalo directamente en el mapa. El modo "Editar Horarios" prioriza la edición de tiempos al seleccionar un punto.
            </p>
            <div id="editModeSelection" style="margin-bottom:10px; display: flex; flex-wrap: wrap;">
                <button onclick="setActiveMode('flagConfig')" id="modeFlagConfigBtn" class="secondary" style="margin-right:5px; margin-bottom:5px;">Editar Bandera</button>
                <button onclick="setActiveMode('waypoint')" id="modeWaypointBtn" class="info" style="margin-right:5px; margin-bottom:5px;">+Pto. Paso</button>
                <button onclick="setActiveMode('intermediateStop')" id="modeIntermediateStopBtn" class="info" style="margin-right:5px; margin-bottom:5px;">+Parada Inter.</button>
                <button onclick="setActiveMode('lineEndpoint')" id="modeLineEndpointBtn" class="info" style="margin-right:5px; margin-bottom:5px;">+Punta Línea</button>
                <button onclick="setActiveMode('schedule')" id="modeScheduleBtn" class="secondary" style="margin-right:5px; margin-bottom:5px;">Editar Horarios</button>
                <button onclick="setActiveMode(null)" id="modeCancelBtn" class="danger" style="display:none; margin-bottom:5px;">X Cancelar Modo</button>
            </div>
            <p id="activeModeStatus" style="font-size: 0.8em; color: #17a2b8; margin-top:0; min-height: 1.2em;"></p>
            
            <label for="pointName">Nombre Punto:</label>
            <input type="text" id="pointName" placeholder="Ej: Terminal Norte">
            
            <div id="lineEndpointTimes" style="display:none;">
                <label for="pointScheduledDepartureTime">Horario Salida Programado (de esta Punta de Línea):</label>
                <input type="datetime-local" id="pointScheduledDepartureTime">
                <label for="pointScheduledArrivalTime">Horario Llegada Programado (a esta Punta de Línea):</label>
                <input type="datetime-local" id="pointScheduledArrivalTime">
                <small style="font-size: 0.7em; display: block; margin-bottom: 5px;">
                    <b>1ra Punta de Línea:</b> Salida inicia IDA, Llegada termina VUELTA.<br>
                    <b>2da Punta de Línea:</b> Llegada termina IDA, Salida inicia VUELTA.
                </small>
            </div>
            <div id="intermediateStopTime" style="display:none;">
                <label for="pointScheduledTimeIntermediate">Horario Programado (Parada Intermedia en IDA):</label>
                <input type="datetime-local" id="pointScheduledTimeIntermediate">
                <small style="font-size: 0.7em; display: block; margin-bottom: 5px;">
                    El horario para VUELTA se calculará automáticamente si la opción está activa.
                </small>
            </div>

            <div id="editPointControls" style="display:none; margin-top:10px;">
                <button onclick="updateSelectedPoint()" class="secondary">Actualizar Punto</button>
                <button onclick="deleteSelectedPoint()" class="danger">Borrar Punto Seleccionado</button>
                <button onclick="cancelEdit()">Cancelar Edición</button>
            </div>
            <hr style="margin: 15px 0;">
            <input type="checkbox" id="autoCalcTimes" checked onchange="calculateAndApplyAllIntermediateTimes()">
            <label for="autoCalcTimes" style="display:inline;">Calcular horarios intermedios automáticamente (para IDA y VUELTA)</label>
            <br><br>
            <button onclick="clearCurrentRoute()">Limpiar Ruta Actual</button>
        </div>
        
        <div class="control-section" id="routeSettingsSection">
            <h3>Configuración de Vueltas y Banderas</h3>
            <label for="totalTurnsInput">Cantidad de Vueltas (ciclos completos IDA-VUELTA):</label>
            <input type="number" id="totalTurnsInput" value="1" min="1" onchange="updateRouteSettings()">
            <label for="flagNameIdaInput">Nombre Bandera IDA:</label>
            <input type="text" id="flagNameIdaInput" value="IDA" onchange="updateRouteSettings()">
            <label for="flagNameVueltaInput">Nombre Bandera VUELTA:</label>
            <input type="text" id="flagNameVueltaInput" value="VUELTA" onchange="updateRouteSettings()">
        </div>

        <div class="control-section">
            <h3>Configuración de Visualización</h3>
            <label for="stopRadiusInput">Radio de Paradas/Puntas (metros):</label>
            <input type="number" id="stopRadiusInput" value="50" min="10" max="500" onchange="updateGlobalStopRadiusSettings()">
        </div>

        <div class="control-section">
            <h3>Lista de Puntos (Paradas y Puntas de Línea)</h3>
            <div id="stopsList">No hay puntos definidos.</div>
        </div>
        
        <div class="control-section">
            <h3>Guardar/Cargar Rutas</h3>
            <label for="routeName">Nombre para Guardar Ruta:</label>
            <input type="text" id="routeName" placeholder="Ej: Ruta Mañana Lunes">
            <button onclick="saveRoute()">Guardar Ruta</button>
            <br><br>
            <label for="savedRoutes">Cargar Ruta:</label>
            <select id="savedRoutes"></select>
            <button onclick="loadRoute()">Cargar</button>
            <button onclick="deleteRoute()" class="danger">Borrar Seleccionada</button>
        </div>

        <div class="control-section">
            <h3>Seguimiento</h3>
            <button id="startTrackingBtn" onclick="startTracking()">Iniciar Seguimiento</button>
            <button id="stopTrackingBtn" onclick="stopTracking()" class="danger" style="display:none;">Detener Seguimiento</button>
            <br>
            <input type="checkbox" id="manualStopNav" onchange="updateManualNavButtons()">
            <label for="manualStopNav" style="display:inline;">Navegación Manual de Puntos</label>
            <button id="prevStopBtn" onclick="goToPreviousActivePoint()" style="display:none;">Anterior</button>
            <button id="nextStopBtn" onclick="goToNextActivePoint()" style="display:none;">Siguiente</button>
        </div>
        
        <div class="control-section">
            <h3>Cola de Rutas</h3>
            <label for="routeToQueue">Añadir ruta guardada a la cola:</label>
            <select id="routeToQueue"></select>
            <button onclick="addRouteToQueue()">Añadir a Cola</button>
            <h4>En Cola:</h4>
            <div id="routeQueueDisplay">Vacía.</div>
            <button onclick="clearRouteQueue()">Limpiar Cola</button>
        </div>

    </div>

    <script>
        'use strict';
        let map;
        let routePoints = []; 
        let routeLine;
        let userMarker;
        let trackingIntervalId;
        let isTracking = false;
        let currentSegmentStartIndex = 0; 
        let lastKnownPosition = null;
        let currentlyEditingPoint = null; 
        let currentStopRadius = 50; 
        
        let activePointCreationMode = null; // null | 'waypoint' | 'intermediateStop' | 'lineEndpoint'
        let timeEditingPriority = false; // true if 'schedule' mode is active

        const CACHE_PREFIX = 'smartMovePro_route_';
        const ROUTE_QUEUE_CACHE_KEY = 'smartMovePro_routeQueue';

        let routeSettings = {
            totalTurns: 1,
            flagNameIda: "IDA",
            flagNameVuelta: "VUELTA"
        };

        let trackingState = {
            currentTurn: 1,
            currentFlag: routeSettings.flagNameIda, 
            activeLegPoints: [], 
        };
        
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }
        
        function createDivIcon(text, pointCategory = '', isFirstEndpoint = false) {
            let htmlContent = '';
            let iconSize = [30,30]; 
            let iconAnchor = [15,15]; 
            let className = 'leaflet-div-icon';

            if (pointCategory === 'waypoint') {
                className += ' waypoint-marker-icon'; 
                iconSize = [12,12]; 
                iconAnchor = [6,6];
            } else if (pointCategory === 'lineEndpoint') {
                const bgColor = isFirstEndpoint ? '#FF8C00' : '#DA70D6'; 
                const P_char = text ? text.substring(0,1).toUpperCase() : (isFirstEndpoint ? 'P1' : 'P2');
                htmlContent = `<div style="background-color:${bgColor}; width: 28px; height:28px; display:flex; justify-content:center; align-items:center; border-radius: 50%; color: white; font-size:14px; font-weight:bold; border: 2px solid white;">${P_char}</div>`;
                iconSize = [32,32]; 
                iconAnchor = [16,16];
            } else { // intermediateStop
                const bgColor = '#2196F3'; 
                const displayText = text || '?';
                htmlContent = `<div style="background-color:${bgColor}; padding: 5px 8px; border-radius: 5px; color: white; font-size:12px; font-weight:bold; border: 1px solid white; min-width: 15px; text-align: center;">${displayText}</div>`;
                iconSize = [displayText.length > 1 ? 35 : 30, 30]; 
                iconAnchor = [iconSize[0]/2, 15];
            }
            
            return L.divIcon({
                className: className,
                html: htmlContent,
                iconSize: iconSize, 
                iconAnchor: iconAnchor
            });
        }
        
        function createUserLocationIcon() {
            return L.divIcon({
                className: 'user-location-icon',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        function initMap() {
            map = L.map('map').setView([-34.6037, -58.3816], 13); 
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            map.on('click', onMapClick);
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    map.setView([position.coords.latitude, position.coords.longitude], 13);
                });
            }
            document.getElementById('stopRadiusInput').value = currentStopRadius;
            updateRouteSettings();
        }

        function setActiveMode(modeName) {
            const modeButtons = {
                flagConfig: document.getElementById('modeFlagConfigBtn'),
                waypoint: document.getElementById('modeWaypointBtn'),
                intermediateStop: document.getElementById('modeIntermediateStopBtn'),
                lineEndpoint: document.getElementById('modeLineEndpointBtn'),
                schedule: document.getElementById('modeScheduleBtn')
            };
            const statusP = document.getElementById('activeModeStatus');
            const cancelBtn = document.getElementById('modeCancelBtn');

            // Reset previous mode effects
            activePointCreationMode = null;
            timeEditingPriority = false;
            Object.values(modeButtons).forEach(btn => { 
                if(btn) btn.classList.remove('active-mode-button');
            });
            cancelEdit(); 

            if (modeName === null) { 
                statusP.textContent = "Selecciona un modo o toca un punto existente para editar.";
                statusP.style.color = '#FFFFFF'; 
                cancelBtn.style.display = 'none';
                updateWaypointMarkersVisibility(false); 
                return;
            }

            if(modeButtons[modeName]) modeButtons[modeName].classList.add('active-mode-button');
            cancelBtn.style.display = 'inline-block';
            statusP.style.color = '#17a2b8';

            switch (modeName) {
                case 'flagConfig':
                    statusP.textContent = "Modo Edición de Bandera: Configure vueltas y nombres de bandera en su sección.";
                    const routeSettingsSection = document.getElementById('routeSettingsSection');
                    if(routeSettingsSection) routeSettingsSection.scrollIntoView({ behavior: 'smooth' });
                    updateWaypointMarkersVisibility(false);
                    break;
                case 'waypoint':
                    activePointCreationMode = 'waypoint';
                    statusP.textContent = "Modo 'Añadir Punto de Paso' ACTIVO. Toca el mapa para añadir. Toca un punto de paso existente para borrarlo.";
                    updateWaypointMarkersVisibility(true);
                    break;
                case 'intermediateStop':
                    activePointCreationMode = 'intermediateStop';
                    statusP.textContent = "Modo 'Añadir Parada Intermedia' ACTIVO. Toca el mapa para añadir.";
                    updateWaypointMarkersVisibility(false);
                    break;
                case 'lineEndpoint':
                    activePointCreationMode = 'lineEndpoint';
                    statusP.textContent = "Modo 'Añadir Punta de Línea' ACTIVO. Toca el mapa para añadir (máx. 2).";
                    updateWaypointMarkersVisibility(false);
                    break;
                case 'schedule':
                    timeEditingPriority = true;
                    statusP.textContent = "Modo 'Editar Horarios' ACTIVO. Toca una parada o punta de línea para editar sus horarios.";
                    updateWaypointMarkersVisibility(false);
                    break;
            }
        }
        
        function updateWaypointMarkersVisibility(showWaypointsOverride = null) {
            const show = showWaypointsOverride !== null ? showWaypointsOverride : (activePointCreationMode === 'waypoint');
            routePoints.forEach(p => {
                if (p.pointCategory === 'waypoint' && p.marker) {
                    if (show) {
                        if (!map.hasLayer(p.marker)) map.addLayer(p.marker);
                    } else {
                        if (map.hasLayer(p.marker)) map.removeLayer(p.marker);
                    }
                }
            });
        }

        function updateRouteSettings() {
            routeSettings.totalTurns = parseInt(document.getElementById('totalTurnsInput').value) || 1;
            routeSettings.flagNameIda = document.getElementById('flagNameIdaInput').value || "IDA";
            routeSettings.flagNameVuelta = document.getElementById('flagNameVueltaInput').value || "VUELTA";
            if (!isTracking) trackingState.currentFlag = routeSettings.flagNameIda;
            redrawRouteLine(); 
            updateTrackingStatusDisplay();
        }

        function formatDateTimeForInput(date) {
            if (!date || isNaN(new Date(date).getTime())) return "";
            const d = new Date(date);
            d.setMinutes(d.getMinutes() - d.getTimezoneOffset());
            return d.toISOString().slice(0, 16);
        }

        function activateEditModeForPoint(point) {
            if (isTracking) { return; }
            if (point.pointCategory === 'waypoint') {
                 if (activePointCreationMode === 'waypoint') {
                    // Deletion is handled by waypoint's own click listener when in waypoint mode
                 } else {
                    alert("Para interactuar con Puntos de Paso, active el modo '+Pto. Paso'.");
                 }
                return;
            }
            
            // If an "add" mode was active, cancel it because we are now editing a specific point.
            // This doesn't apply if 'schedule' (timeEditingPriority) mode is active, as that's for editing.
            if (activePointCreationMode !== null) {
                setActiveMode(null); // This will also call cancelEdit() internally
            } else {
                cancelEdit(); // Clear previous edit if no mode change
            }

            currentlyEditingPoint = point;
            document.getElementById('pointName').value = point.name;
            document.getElementById('pointName').readOnly = timeEditingPriority;
            
            document.getElementById('lineEndpointTimes').style.display = 'none';
            document.getElementById('intermediateStopTime').style.display = 'none';

            if (point.pointCategory === 'lineEndpoint') {
                document.getElementById('lineEndpointTimes').style.display = 'block';
                const depTimeKey = point.isFirstEndpoint ? 'departureOutbound' : 'departureReturn';
                const arrTimeKey = point.isFirstEndpoint ? 'arrivalReturn' : 'arrivalOutbound';
                document.getElementById('pointScheduledDepartureTime').value = formatDateTimeForInput(point.times[depTimeKey]);
                document.getElementById('pointScheduledArrivalTime').value = formatDateTimeForInput(point.times[arrTimeKey]);
                if(timeEditingPriority) document.getElementById('pointScheduledDepartureTime').focus();
            } else if (point.pointCategory === 'intermediateStop') {
                document.getElementById('intermediateStopTime').style.display = 'block';
                document.getElementById('pointScheduledTimeIntermediate').value = formatDateTimeForInput(point.times.scheduledIDA);
                 if(timeEditingPriority) document.getElementById('pointScheduledTimeIntermediate').focus();
            }
            
            document.getElementById('editPointControls').style.display = 'block';
            if (!timeEditingPriority) document.getElementById('pointName').focus();
        }

        function cancelEdit() {
            currentlyEditingPoint = null;
            document.getElementById('pointName').value = "";
            document.getElementById('pointName').readOnly = false;
            document.getElementById('pointScheduledDepartureTime').value = "";
            document.getElementById('pointScheduledArrivalTime').value = "";
            document.getElementById('pointScheduledTimeIntermediate').value = "";
            document.getElementById('editPointControls').style.display = 'none';
            document.getElementById('lineEndpointTimes').style.display = 'none';
            document.getElementById('intermediateStopTime').style.display = 'none';
        }

        function updateSelectedPoint() {
            if (!currentlyEditingPoint || currentlyEditingPoint.pointCategory === 'waypoint') return;

            if (!timeEditingPriority) { // Only update name if not in schedule-focused edit
                const newName = document.getElementById('pointName').value.trim();
                if (!newName) { alert("El nombre del punto no puede estar vacío."); return; }
                currentlyEditingPoint.name = newName;
            }

            if (currentlyEditingPoint.pointCategory === 'lineEndpoint') {
                const depTimeValue = document.getElementById('pointScheduledDepartureTime').value;
                const arrTimeValue = document.getElementById('pointScheduledArrivalTime').value;
                
                if (!depTimeValue || !arrTimeValue) {
                    alert("Las Puntas de Línea deben tener horarios de salida y llegada definidos."); return;
                }
                const departureTime = new Date(depTimeValue);
                const arrivalTime = new Date(arrTimeValue);

                if (isNaN(departureTime.getTime()) || isNaN(arrivalTime.getTime())) {
                    alert("Formato de fecha/hora inválido para Punta de Línea."); return;
                }
                
                if (currentlyEditingPoint.isFirstEndpoint) {
                    currentlyEditingPoint.times.departureOutbound = departureTime;
                    currentlyEditingPoint.times.arrivalReturn = arrivalTime;
                } else {
                    currentlyEditingPoint.times.arrivalOutbound = arrivalTime; 
                    currentlyEditingPoint.times.departureReturn = departureTime; 
                }

            } else if (currentlyEditingPoint.pointCategory === 'intermediateStop') {
                const interTimeValue = document.getElementById('pointScheduledTimeIntermediate').value;
                currentlyEditingPoint.times.scheduledIDA = interTimeValue ? new Date(interTimeValue) : null;
                if (interTimeValue && isNaN(currentlyEditingPoint.times.scheduledIDA.getTime())) {
                     alert("Formato de fecha/hora inválido para Parada Intermedia.");
                     currentlyEditingPoint.times.scheduledIDA = null; 
                     return;
                }
            }
            
            if (document.getElementById('autoCalcTimes').checked) {
                calculateAndApplyAllIntermediateTimes();
            }
            updateAllMarkerIconsAndLabels(); 
            redrawRouteLine();
            updateStopsList();
            alert(`Punto "${currentlyEditingPoint.name}" actualizado.`);
            cancelEdit(); // Exits edit mode for the point
        }

        function deleteSelectedPoint() {
            if (!currentlyEditingPoint || currentlyEditingPoint.pointCategory === 'waypoint') return;
        
            if (confirm(`¿Seguro que quieres borrar el punto "${currentlyEditingPoint.name}"?`)) {
                map.removeLayer(currentlyEditingPoint.marker);
                if (currentlyEditingPoint.radiusCircle) map.removeLayer(currentlyEditingPoint.radiusCircle);
                
                const originalPointCategory = currentlyEditingPoint.pointCategory;
                const pointNameToDelete = currentlyEditingPoint.name; // Save before cancelling edit
                routePoints = routePoints.filter(p => p.id !== currentlyEditingPoint.id);
                
                if (originalPointCategory === 'lineEndpoint') {
                    const remainingLineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
                    if (remainingLineEndpoints.length > 0) {
                         remainingLineEndpoints.sort((a,b) => a.originalIndex - b.originalIndex);
                         remainingLineEndpoints[0].isFirstEndpoint = true;
                         if(remainingLineEndpoints.length > 1) remainingLineEndpoints[1].isFirstEndpoint = false;
                    }
                }
        
                if (document.getElementById('autoCalcTimes').checked) {
                    calculateAndApplyAllIntermediateTimes();
                }
                updateAllMarkerIconsAndLabels();
                redrawRouteLine();
                updateStopsList();
                alert(`Punto "${pointNameToDelete}" borrado.`);
            }
            cancelEdit(); // Exits edit mode for the point
        }
        
        function updateAllMarkerIconsAndLabels() {
            const displayOrderedPoints = getSortedRoutePointsForDisplay(); 

            routePoints.forEach(p => { 
                if (p.marker) {
                    let text = '';
                    if (p.pointCategory === 'lineEndpoint') {
                        text = p.name; 
                    } else if (p.pointCategory === 'intermediateStop') {
                        const displayIdx = displayOrderedPoints.filter(dp=>dp.pointCategory === 'intermediateStop').findIndex(dp => dp.id === p.id);
                        text = (displayIdx !== -1) ? String(displayIdx + 1) : '?';
                    }
                    p.marker.setIcon(createDivIcon(text, p.pointCategory, p.isFirstEndpoint));
                }
            });
        }

        function onMapClick(e) {
            if (isTracking) { alert("Detén el seguimiento para modificar la ruta."); return; }
            
            let targetIsMarkerIcon = e.originalEvent.target.closest && e.originalEvent.target.closest('.leaflet-marker-icon');
            
            if (currentlyEditingPoint && !targetIsMarkerIcon) {
                 // If not clicking a marker while editing another point, cancel the current edit.
                 // This does not cancel the overall mode (e.g. 'add intermediate stop')
                cancelEdit();
            }
            if (targetIsMarkerIcon) return; // Marker click handled by its own listener which calls activateEditModeForPoint

            const latlng = e.latlng;
            const pointId = generateUniqueId();
            
            if (activePointCreationMode) {
                document.getElementById('pointName').value = ""; // Clear name field if user was editing then decided to add new
                let pointNameValue = ""; 
                let newPointData = {
                    id: pointId, lat: latlng.lat, lng: latlng.lng,
                    originalIndex: routePoints.length, times: {}
                };

                switch (activePointCreationMode) {
                    case 'waypoint':
                        const waypoint = {
                            id: pointId, lat: latlng.lat, lng: latlng.lng, 
                            name: `Paso ${routePoints.filter(p => p.pointCategory === 'waypoint').length + 1}`,
                            pointCategory: 'waypoint',
                            marker: L.marker(latlng, { icon: createDivIcon(null, 'waypoint'), draggable: true }),
                            radiusCircle: null, originalIndex: routePoints.length 
                        };
                        if (map.hasLayer(waypoint.marker)) map.removeLayer(waypoint.marker);
                        map.addLayer(waypoint.marker);

                        waypoint.marker.on('dragend', function(event) {
                            if (isTracking) { event.target.setLatLng(L.latLng(waypoint.lat, waypoint.lng)); return; }
                            const pos = event.target.getLatLng(); waypoint.lat = pos.lat; waypoint.lng = pos.lng;
                            redrawRouteLine();
                            if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                        });
                        waypoint.marker.on('click', function(ev) {
                            L.DomEvent.stopPropagation(ev); if (isTracking) return;
                            if (activePointCreationMode === 'waypoint') { // Only deletable in waypoint mode
                                if (confirm(`¿Borrar este punto de paso "${waypoint.name}"?`)) {
                                    map.removeLayer(waypoint.marker);
                                    routePoints = routePoints.filter(p => p.id !== waypoint.id);
                                    redrawRouteLine();
                                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                                }
                            } else {
                                alert("Para borrar Puntos de Paso, active el modo '+Pto. Paso'.");
                            }
                        });
                        routePoints.push(waypoint);
                        if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes(); 
                        redrawRouteLine();
                        return; 

                    case 'intermediateStop':
                        newPointData.name = `Parada ${routePoints.filter(p => p.pointCategory === 'intermediateStop').length + 1}`;
                        newPointData.pointCategory = 'intermediateStop';
                        newPointData.times = { scheduledIDA: null, scheduledVUELTA: null };
                        break;

                    case 'lineEndpoint':
                        const currentLineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
                        if (currentLineEndpoints.length >= 2) {
                            alert("Ya existen dos Puntas de Línea. No se pueden añadir más.");
                            return;
                        }
                        const isFirstEp = (currentLineEndpoints.length === 0);
                        newPointData.name = isFirstEp ? "Punta de Línea 1" : "Punta de Línea 2";
                        newPointData.pointCategory = 'lineEndpoint';
                        newPointData.isFirstEndpoint = isFirstEp;
                        newPointData.times = isFirstEp ? 
                            { departureOutbound: null, arrivalReturn: null } : 
                            { arrivalOutbound: null, departureReturn: null };
                        break;
                    default: return; // Should not happen
                }
                
                const newPoint = { ...newPointData };
                routePoints.push(newPoint);
                routePoints.sort((a,b) => a.originalIndex - b.originalIndex); 
                routePoints.forEach((p, idx) => p.originalIndex = idx);

                newPoint.marker = L.marker(latlng, { 
                    icon: createDivIcon(newPoint.name, newPoint.pointCategory, newPoint.isFirstEndpoint), draggable: true 
                }).addTo(map);
                newPoint.radiusCircle = L.circle(latlng, {
                    radius: currentStopRadius, 
                    color: (newPoint.pointCategory === 'lineEndpoint' ? (newPoint.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'), 
                    weight: 1, opacity: 0.5, 
                    fillColor: (newPoint.pointCategory === 'lineEndpoint' ? (newPoint.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'), fillOpacity: 0.2
                }).addTo(map);

                newPoint.marker.on('dragend', function(event) {
                    if (isTracking) {event.target.setLatLng(L.latLng(newPoint.lat, newPoint.lng)); return; }
                    const pos = event.target.getLatLng(); newPoint.lat = pos.lat; newPoint.lng = pos.lng;
                    if (newPoint.radiusCircle) newPoint.radiusCircle.setLatLng(pos);
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                    updateStopsList(); 
                });
                newPoint.marker.on('click', function(ev) { L.DomEvent.stopPropagation(ev); if (isTracking) return; activateEditModeForPoint(newPoint); });
                
                updateAllMarkerIconsAndLabels();
                if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                redrawRouteLine();
                updateStopsList();
                // Optionally, activate edit mode for the newly added point:
                // activateEditModeForPoint(newPoint); 
                // For now, keep the "add" mode pure. User can click the new point to edit.
            } else if (timeEditingPriority) {
                // In 'schedule' mode, map click itself does nothing unless it's on a marker.
                // Status message already guides the user.
            }
        }
        
        function getPathPointsForPolyline(flagNameToUse) {
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint').sort((a,b) => a.originalIndex - b.originalIndex);
            if (lineEndpoints.length < 2) return routePoints.filter(p => p.pointCategory !== 'waypoint'); 

            const p1 = lineEndpoints.find(p => p.isFirstEndpoint);
            const p2 = lineEndpoints.find(p => !p.isFirstEndpoint);
            if (!p1 || !p2) return routePoints.filter(p => p.pointCategory !== 'waypoint');

            const allOtherPoints = routePoints.filter(p => p.id !== p1.id && p.id !== p2.id)
                                           .sort((a, b) => a.originalIndex - b.originalIndex);
            
            let polylinePoints = [];
            if (flagNameToUse === routeSettings.flagNameIda) {
                polylinePoints.push(p1);
                polylinePoints.push(...allOtherPoints.filter(ip => ip.originalIndex > p1.originalIndex && ip.originalIndex < p2.originalIndex));
                polylinePoints.push(p2);
            } else { 
                polylinePoints.push(p2);
                polylinePoints.push(...allOtherPoints.filter(ip => ip.originalIndex > p1.originalIndex && ip.originalIndex < p2.originalIndex).reverse());
                polylinePoints.push(p1);
            }
            return polylinePoints;
        }

        function calculateAndApplyAllIntermediateTimes() {
            const autoCalc = document.getElementById('autoCalcTimes').checked;
            if (!autoCalc) { 
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => stop.times.scheduledVUELTA = null);
                updateStopsList(); return; 
            }

            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint').sort((a,b)=>a.originalIndex - b.originalIndex);
            if (lineEndpoints.length < 2) { updateStopsList(); return; }
            
            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);
            if (!p1 || !p2) { updateStopsList(); return; }

            const allOtherPoints = routePoints.filter(rp => rp.id !== p1.id && rp.id !== p2.id).sort((a,b)=>a.originalIndex-b.originalIndex);
            
            if (p1.times.departureOutbound && p2.times.arrivalOutbound) {
                const idaLegPath = [p1, ...allOtherPoints.filter(pt => pt.originalIndex > p1.originalIndex && pt.originalIndex < p2.originalIndex), p2];
                distributeTimesProportionally(idaLegPath, new Date(p1.times.departureOutbound), new Date(p2.times.arrivalOutbound), 'scheduledIDA');
            } else {
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => stop.times.scheduledIDA = null);
            }

            if (p2.times.departureReturn && p1.times.arrivalReturn) {
                const vueltaLegPath = [p2, ...allOtherPoints.filter(pt => pt.originalIndex > p1.originalIndex && pt.originalIndex < p2.originalIndex).reverse(), p1];
                distributeTimesProportionally(vueltaLegPath, new Date(p2.times.departureReturn), new Date(p1.times.arrivalReturn), 'scheduledVUELTA');
            } else {
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => stop.times.scheduledVUELTA = null);
            }
            updateStopsList();
        }

        function distributeTimesProportionally(legPathPoints, legStartTimeDate, legEndTimeDate, timeKey) {
            if (!legStartTimeDate || !legEndTimeDate || legPathPoints.length < 2) return;
            
            const legStartMillis = legStartTimeDate.getTime();
            const legEndMillis = legEndTimeDate.getTime();
            const totalDurationMillis = legEndMillis - legStartMillis;

            const intermediateStopsInLeg = legPathPoints.slice(1, -1).filter(p => p.pointCategory === 'intermediateStop');
            if (totalDurationMillis <= 0) {
                intermediateStopsInLeg.forEach(p => p.times[timeKey] = null);
                return;
            }

            let totalDistance = 0;
            const segmentDistances = [];
            for (let i = 0; i < legPathPoints.length - 1; i++) {
                const dist = L.latLng(legPathPoints[i].lat, legPathPoints[i].lng)
                               .distanceTo(L.latLng(legPathPoints[i+1].lat, legPathPoints[i+1].lng));
                segmentDistances.push(dist);
                totalDistance += dist;
            }

            if (totalDistance < 1.0) { 
                const numTimeSegments = intermediateStopsInLeg.length + 1;
                if (numTimeSegments <= 0) return;
                const timePerSegment = totalDurationMillis / numTimeSegments;
                let currentTime = legStartMillis;
                legPathPoints.slice(1, -1).forEach(p => { 
                    if (p.pointCategory === 'intermediateStop') {
                       currentTime += timePerSegment; 
                       p.times[timeKey] = new Date(currentTime);
                    }
                });
            } else {
                let accumulatedDistance = 0;
                for (let i = 0; i < legPathPoints.length - 1; i++) {
                    accumulatedDistance += segmentDistances[i];
                    const nextPointInPath = legPathPoints[i+1];
                    if (nextPointInPath.pointCategory === 'intermediateStop') {
                        const proportionOfRoute = accumulatedDistance / totalDistance;
                        const timeOffsetMillis = totalDurationMillis * proportionOfRoute;
                        nextPointInPath.times[timeKey] = new Date(legStartMillis + timeOffsetMillis);
                    }
                }
            }
        }
        
        function clearCurrentRoute() {
            setActiveMode(null); // Clear any active mode
            routePoints.forEach(p => {
                if (p.marker) map.removeLayer(p.marker);
                if (p.radiusCircle) map.removeLayer(p.radiusCircle);
            });
            routePoints = [];
            if (routeLine) map.removeLayer(routeLine); routeLine = null;
            document.getElementById('pointName').value = "";
            updateStopsList(); updateAllMarkerIconsAndLabels(); 
        }

        function redrawRouteLine() {
            if (routeLine) map.removeLayer(routeLine); routeLine = null;
            
            const polylinePathPoints = getPathPointsForPolyline(trackingState.currentFlag); 
            if (polylinePathPoints.length > 1) {
                const latlngs = polylinePathPoints.map(p => [p.lat, p.lng]);
                const color = (trackingState.currentFlag === routeSettings.flagNameIda) ? 'blue' : 'red';
                routeLine = L.polyline(latlngs, {color: color, weight: 5}).addTo(map);
            }
        }
        
        function getSortedRoutePointsForDisplay() { 
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint').sort((a,b) => a.originalIndex - b.originalIndex);
            const intermediateStops = routePoints.filter(p => p.pointCategory === 'intermediateStop').sort((a,b) => a.originalIndex - b.originalIndex);
            
            const sortedDisplayPoints = [];
            if (lineEndpoints.length > 0) {
                const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
                if (p1) sortedDisplayPoints.push(p1);
            }
            
            const p1Index = (lineEndpoints.length > 0 && lineEndpoints.find(ep => ep.isFirstEndpoint)) ? lineEndpoints.find(ep => ep.isFirstEndpoint).originalIndex : -1;
            const p2Index = (lineEndpoints.length > 1 && lineEndpoints.find(ep => !ep.isFirstEndpoint)) ? lineEndpoints.find(ep => !ep.isFirstEndpoint).originalIndex : (p1Index !== -1 ? Infinity : -Infinity) ;


            if (p1Index < p2Index) { 
                 sortedDisplayPoints.push(...intermediateStops.filter(is => is.originalIndex > p1Index && is.originalIndex < p2Index));
            } else { 
                 sortedDisplayPoints.push(...intermediateStops.filter(is => is.originalIndex > p2Index && is.originalIndex < p1Index));
            }


            if (lineEndpoints.length > 0) { 
                const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);
                if (p2 && !sortedDisplayPoints.find(sdp => sdp.id === p2.id)) sortedDisplayPoints.push(p2);
            }
            
            const stopsNotInOrder = intermediateStops.filter(is => !sortedDisplayPoints.find(sdp => sdp.id === is.id));
            sortedDisplayPoints.push(...stopsNotInOrder);

            return sortedDisplayPoints.filter((item, pos, self) => self.findIndex(s => s.id === item.id) === pos);
        }

        function formatTime(dateObj, includeDate = true) { 
            if (!dateObj || isNaN(new Date(dateObj).getTime())) return "N/A";
            let timeStr = new Date(dateObj).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            if (includeDate) {
                 timeStr += ` (${new Date(dateObj).toLocaleDateString('es-ES', {day:'2-digit', month:'2-digit'})})`;
            }
            return timeStr;
        }
        
        function updateStopsList() {
            const listDiv = document.getElementById('stopsList');
            const displayPoints = getSortedRoutePointsForDisplay(); 

            if (displayPoints.length === 0) { listDiv.innerHTML = "No hay puntos definidos."; return; }

            let html = "<ul style='padding-left: 10px; list-style: decimal;'>";
            let intermediateVisualCounter = 1; 
            displayPoints.forEach((p) => { 
                let typeText = "", timeStr = "N/A";
                let itemClass = "stop-item";

                if (p.pointCategory === 'lineEndpoint') {
                    itemClass += " line-endpoint-highlight";
                    typeText = p.isFirstEndpoint ? "Punta de Línea 1" : "Punta de Línea 2";
                    const dep = p.isFirstEndpoint ? p.times.departureOutbound : p.times.departureReturn;
                    const arr = p.isFirstEndpoint ? p.times.arrivalReturn : p.times.arrivalOutbound;
                    timeStr = `Sal: ${formatTime(dep, false)} / Lleg: ${formatTime(arr, false)}`;
                    if (dep) timeStr += ` (${new Date(dep).toLocaleDateString('es-ES',{day:'2-digit',month:'2-digit'})})`;
                } else if (p.pointCategory === 'intermediateStop') {
                    typeText = `Parada Inter. ${intermediateVisualCounter++}`;
                    timeStr = `IDA: ${formatTime(p.times.scheduledIDA, false)} / VTA: ${formatTime(p.times.scheduledVUELTA, false)}`;
                    if (p.times.scheduledIDA) timeStr += ` (${new Date(p.times.scheduledIDA).toLocaleDateString('es-ES',{day:'2-digit',month:'2-digit'})})`;
                }
                html += `<li class="${itemClass}" onclick="focusPointOnMap('${p.id}')"><b>${p.name}</b> (${typeText}) - ${timeStr}</li>`;
            });
            html += "</ul>";
            listDiv.innerHTML = html;
            highlightNextStopInList(); 
        }

        function focusPointOnMap(pointId) {
            const point = routePoints.find(p => p.id === pointId);
            if (point && map) {
                map.setView([point.lat, point.lng], Math.max(map.getZoom(), 16));
                 // Optionally, activate edit mode for this point
                 // activateEditModeForPoint(point); // This might be too aggressive
            }
        }

        function saveRoute() {
            setActiveMode(null); // Ensure no edit mode is active when saving
            const routeNameInput = document.getElementById('routeName');
            if (!routeNameInput.value) { alert("Por favor, ingresa un nombre para la ruta."); return; }
            
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
            if (lineEndpoints.length < 2) {
                 alert("Una ruta debe tener dos Puntas de Línea definidas."); return;
            }
            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);
            if (!p1 || !p2 || 
                !p1.times.departureOutbound || !p1.times.arrivalReturn ||
                !p2.times.arrivalOutbound || !p2.times.departureReturn) {
                alert("Ambas Puntas de Línea deben tener sus 4 horarios clave definidos.");
                return;
            }

            const savablePoints = routePoints.map(p => {
                const pointData = { 
                    id: p.id, lat: p.lat, lng: p.lng, name: p.name, 
                    pointCategory: p.pointCategory,
                    originalIndex: p.originalIndex,
                    times: {} 
                };
                if (p.pointCategory === 'lineEndpoint') {
                    pointData.isFirstEndpoint = p.isFirstEndpoint;
                    if (p.isFirstEndpoint) {
                        pointData.times.departureOutbound = p.times.departureOutbound ? new Date(p.times.departureOutbound).toISOString() : null;
                        pointData.times.arrivalReturn = p.times.arrivalReturn ? new Date(p.times.arrivalReturn).toISOString() : null;
                    } else {
                        pointData.times.arrivalOutbound = p.times.arrivalOutbound ? new Date(p.times.arrivalOutbound).toISOString() : null;
                        pointData.times.departureReturn = p.times.departureReturn ? new Date(p.times.departureReturn).toISOString() : null;
                    }
                } else if (p.pointCategory === 'intermediateStop') {
                    pointData.times.scheduledIDA = p.times.scheduledIDA ? new Date(p.times.scheduledIDA).toISOString() : null;
                    pointData.times.scheduledVUELTA = p.times.scheduledVUELTA ? new Date(p.times.scheduledVUELTA).toISOString() : null;
                }
                return pointData;
            });
            
            const routeDataToSave = { points: savablePoints, settings: routeSettings };
            localStorage.setItem(CACHE_PREFIX + routeNameInput.value, JSON.stringify(routeDataToSave));
            alert(`Ruta "${routeNameInput.value}" guardada.`);
            loadSavedRoutesLists();
        }

        function loadRoute() {
            setActiveMode(null); // Ensure no edit mode is active
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) { alert("Selecciona una ruta para cargar."); return; }
            const savedDataRaw = localStorage.getItem(CACHE_PREFIX + selectedRouteName);
            if (!savedDataRaw) { alert("Error al cargar la ruta."); return; }

            clearCurrentRoute(); 
            const loadedRouteData = JSON.parse(savedDataRaw);
            const loadedPointsData = loadedRouteData.points;
            routeSettings = loadedRouteData.settings || { totalTurns: 1, flagNameIda: "IDA", flagNameVuelta: "VUELTA"};
            
            document.getElementById('totalTurnsInput').value = routeSettings.totalTurns;
            document.getElementById('flagNameIdaInput').value = routeSettings.flagNameIda;
            document.getElementById('flagNameVueltaInput').value = routeSettings.flagNameVuelta;
            trackingState.currentFlag = routeSettings.flagNameIda;

            loadedPointsData.forEach((p_data) => {
                const newPointBase = { ...p_data, times: {} }; 

                if (p_data.pointCategory === 'lineEndpoint') {
                    newPointBase.isFirstEndpoint = p_data.isFirstEndpoint; 
                    if (p_data.isFirstEndpoint) { 
                        newPointBase.times.departureOutbound = p_data.times.departureOutbound ? new Date(p_data.times.departureOutbound) : null;
                        newPointBase.times.arrivalReturn = p_data.times.arrivalReturn ? new Date(p_data.times.arrivalReturn) : null;
                    } else { 
                        newPointBase.times.arrivalOutbound = p_data.times.arrivalOutbound ? new Date(p_data.times.arrivalOutbound) : null;
                        newPointBase.times.departureReturn = p_data.times.departureReturn ? new Date(p_data.times.departureReturn) : null;
                    }
                } else if (p_data.pointCategory === 'intermediateStop') {
                     newPointBase.times.scheduledIDA = p_data.times.scheduledIDA ? new Date(p_data.times.scheduledIDA) : null;
                     newPointBase.times.scheduledVUELTA = p_data.times.scheduledVUELTA ? new Date(p_data.times.scheduledVUELTA) : null;
                }

                const newPoint = { ...newPointBase }; 
                routePoints.push(newPoint);
            });
            routePoints.sort((a,b) => a.originalIndex - b.originalIndex);

            routePoints.forEach(p => {
                 p.marker = L.marker([p.lat, p.lng], { 
                    icon: createDivIcon(p.name, p.pointCategory, p.isFirstEndpoint), 
                    draggable: true 
                }).addTo(map);
                 if (p.pointCategory !== 'waypoint') {
                    p.radiusCircle = L.circle([p.lat, p.lng], {
                        radius: currentStopRadius, 
                        color: (p.pointCategory === 'lineEndpoint' ? (p.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'), 
                        weight: 1, opacity: 0.5, 
                        fillColor: (p.pointCategory === 'lineEndpoint' ? (p.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'), fillOpacity: 0.2
                    }).addTo(map);
                    p.marker.on('click', function(ev) {L.DomEvent.stopPropagation(ev); if(isTracking)return; activateEditModeForPoint(p); });
                 } else { // Waypoint
                    p.marker.on('click', function(ev) {
                        L.DomEvent.stopPropagation(ev); if (isTracking) return;
                        if (activePointCreationMode === 'waypoint') { // Only deletable if in waypoint mode
                            if (confirm(`¿Borrar este punto de paso "${p.name}"?`)) {
                                map.removeLayer(p.marker);
                                routePoints = routePoints.filter(rp => rp.id !== p.id);
                                redrawRouteLine();
                                if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                            }
                        } else {
                             alert("Para borrar Puntos de Paso, active el modo '+Pto. Paso'.");
                        }
                    });
                 }
                 p.marker.on('dragend', function(event){
                    if (isTracking) { event.target.setLatLng(L.latLng(p.lat, p.lng)); return; }
                    const pos = event.target.getLatLng(); p.lat = pos.lat; p.lng = pos.lng;
                    if (p.radiusCircle) p.radiusCircle.setLatLng(pos);
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                    updateStopsList();
                });
            });
            
            updateAllMarkerIconsAndLabels(); 
            updateWaypointMarkersVisibility(false); // Waypoints generally hidden unless in their mode
            redrawRouteLine();
            updateStopsList();

            const boundsPoints = routePoints.filter(p => p.pointCategory !== 'waypoint');
            if (boundsPoints.length > 0) {
                const bounds = L.latLngBounds(boundsPoints.map(p => [p.lat, p.lng]));
                if (bounds.isValid()) map.fitBounds(bounds);
            }
            document.getElementById('routeName').value = selectedRouteName;
            alert(`Ruta "${selectedRouteName}" cargada.`);
        }

        function deleteRoute() {
            setActiveMode(null);
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) { alert("Selecciona una ruta para borrar."); return; }
            if (confirm(`¿Estás seguro de que quieres borrar la ruta "${selectedRouteName}"?`)) {
                localStorage.removeItem(CACHE_PREFIX + selectedRouteName);
                let queue = getRouteQueue();
                queue = queue.filter(name => name !== selectedRouteName);
                saveRouteQueue(queue);
                loadSavedRoutesLists(); 
                alert(`Ruta "${selectedRouteName}" borrada.`);
            }
        }

        function loadSavedRoutesLists() { 
            const savedRoutesSelect = document.getElementById('savedRoutes');
            const routeToQueueSelect = document.getElementById('routeToQueue');
            const currentSavedRouteValue = savedRoutesSelect.value;
            const currentQueueRouteValue = routeToQueueSelect.value;

            savedRoutesSelect.innerHTML = ""; routeToQueueSelect.innerHTML = "";
            let hasRoutes = false;
            const routeNames = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(CACHE_PREFIX)) routeNames.push(key.substring(CACHE_PREFIX.length));
            }
            routeNames.sort(); 
            routeNames.forEach(routeName => {
                const option = document.createElement('option');
                option.value = routeName; option.textContent = routeName;
                savedRoutesSelect.appendChild(option.cloneNode(true));
                routeToQueueSelect.appendChild(option.cloneNode(true));
                hasRoutes = true;
            });
            if (!hasRoutes) {
                 const option = document.createElement('option');
                 option.textContent = "No hay rutas guardadas"; option.disabled = true;
                 savedRoutesSelect.appendChild(option.cloneNode(true));
                 routeToQueueSelect.appendChild(option);
            } else {
                if (routeNames.includes(currentSavedRouteValue)) savedRoutesSelect.value = currentSavedRouteValue;
                if (routeNames.includes(currentQueueRouteValue)) routeToQueueSelect.value = currentQueueRouteValue;
            }
            updateRouteQueueDisplay();
        }
        
        function setupCurrentLegForTracking() {
            trackingState.activeLegPoints = [];
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint').sort((a,b) => a.originalIndex - b.originalIndex);
            if (lineEndpoints.length < 2) { console.error("Not enough line endpoints."); return false; }

            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);
            if (!p1 || !p2) { console.error("Cannot identify P1/P2."); return false; }
            
            const allOtherPoints = routePoints.filter(rp => rp.id !== p1.id && rp.id !== p2.id).sort((a,b) => a.originalIndex - b.originalIndex);
            
            let currentLegStartPoint, currentLegEndPoint, legScheduledStartTime, legScheduledEndTime, timeKeyForIntermediate;
            let intermediatePathPoints = []; 

            if (trackingState.currentFlag === routeSettings.flagNameIda) {
                currentLegStartPoint = p1; currentLegEndPoint = p2;
                legScheduledStartTime = p1.times.departureOutbound; legScheduledEndTime = p2.times.arrivalOutbound;
                timeKeyForIntermediate = 'scheduledIDA';
                intermediatePathPoints = allOtherPoints.filter(ip => ip.originalIndex > p1.originalIndex && ip.originalIndex < p2.originalIndex);
            } else { 
                currentLegStartPoint = p2; currentLegEndPoint = p1;
                legScheduledStartTime = p2.times.departureReturn; legScheduledEndTime = p1.times.arrivalReturn;
                timeKeyForIntermediate = 'scheduledVUELTA';
                intermediatePathPoints = allOtherPoints.filter(ip => ip.originalIndex > p1.originalIndex && ip.originalIndex < p2.originalIndex).reverse();
            }

            if (!legScheduledStartTime || !legScheduledEndTime) {
                 alert(`Horarios incompletos para ${trackingState.currentFlag} (Vuelta ${trackingState.currentTurn}).`); return false;
            }
            
            trackingState.activeLegPoints.push({ ...currentLegStartPoint, effectiveScheduledTime: new Date(legScheduledStartTime) });
            intermediatePathPoints.forEach(ip => {
                let effTime = null;
                if (ip.pointCategory === 'intermediateStop' && ip.times[timeKeyForIntermediate]) {
                    effTime = new Date(ip.times[timeKeyForIntermediate]);
                }
                trackingState.activeLegPoints.push({ ...ip, effectiveScheduledTime: effTime });
            });
            trackingState.activeLegPoints.push({ ...currentLegEndPoint, effectiveScheduledTime: new Date(legScheduledEndTime) });
            return true;
        }

        function startTracking() {
            setActiveMode(null); // Clear any edit/add modes
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
            if (lineEndpoints.length < 2) { alert("La ruta debe tener dos Puntas de Línea."); return; }
            
            isTracking = true;
            trackingState.currentTurn = 1;
            trackingState.currentFlag = routeSettings.flagNameIda;
            currentSegmentStartIndex = 0; 
            
            if (!setupCurrentLegForTracking()) {
                stopTracking(false, "Error configurando pierna inicial."); return;
            }
            
            document.getElementById('startTrackingBtn').style.display = 'none';
            document.getElementById('stopTrackingBtn').style.display = 'inline-block';
            document.getElementById('routeCreationSection').style.display = 'none'; 
            updateTrackingStatusDisplay();
            redrawRouteLine(); 
            updateWaypointMarkersVisibility(false); // Hide waypoints not part of current leg logic during tracking for clarity

            if (navigator.geolocation) {
                trackingIntervalId = navigator.geolocation.watchPosition(
                    handlePositionUpdate, handleGeolocationError,
                    { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 } 
                );
                if (trackingState.activeLegPoints.length > 0) {
                    map.setView([trackingState.activeLegPoints[0].lat, trackingState.activeLegPoints[0].lng], 16); 
                }
                highlightNextStopInList(); 
            } else {
                alert("Geolocalización no disponible."); stopTracking(false); 
            }
            updateManualNavButtons();
        }

        function stopTracking(completedNaturally = false, reason = "") {
            if (trackingIntervalId) navigator.geolocation.clearWatch(trackingIntervalId);
            trackingIntervalId = null; isTracking = false; lastKnownPosition = null;
            document.getElementById('startTrackingBtn').style.display = 'inline-block';
            document.getElementById('stopTrackingBtn').style.display = 'none';
            document.getElementById('routeCreationSection').style.display = 'block'; 
            if (userMarker) { map.removeLayer(userMarker); userMarker = null; }
            
            trackingState.currentFlag = routeSettings.flagNameIda; 
            redrawRouteLine(); updateStopsList(); 
            currentSegmentStartIndex = 0; 
            updateManualNavButtons();
            setActiveMode(null); // Reset any creation modes that might have been implicitly active
            updateWaypointMarkersVisibility(false); // Ensure waypoints are hidden after tracking unless mode is re-activated


            if (completedNaturally) {
                document.getElementById('trackingInfoDisplay').textContent = "RUTA COMPLETADA";
                alert("Ruta completada!"); checkRouteQueue();
            } else {
                const msg = "Seguimiento detenido." + (reason ? " Razón: " + reason : "");
                console.log(msg); if (reason) alert(msg);
                document.getElementById('trackingInfoDisplay').textContent = "SEGUIMIENTO DETENIDO";
            }
        }
        
        function updateTrackingStatusDisplay() {
            if (!isTracking && document.getElementById('statusDisplay').style.display !== 'none') {
            } else if (!isTracking) {
                document.getElementById('statusDisplay').style.display = 'none';
                return;
            }

            document.getElementById('statusDisplay').style.display = 'block';
            document.getElementById('trackingInfoDisplay').textContent = 
                `Vuelta: ${trackingState.currentTurn}/${routeSettings.totalTurns} - Bandera: ${trackingState.currentFlag}`;
        }

        function updateManualNavButtons() {
            const manualNav = document.getElementById('manualStopNav').checked;
            const prevBtn = document.getElementById('prevStopBtn');
            const nextBtn = document.getElementById('nextStopBtn');
            
            if (isTracking && manualNav && trackingState.activeLegPoints.length > 0) {
                prevBtn.style.display = 'inline-block';
                nextBtn.style.display = 'inline-block';
                prevBtn.disabled = currentSegmentStartIndex === 0;
                nextBtn.disabled = currentSegmentStartIndex >= trackingState.activeLegPoints.length - 2; 
            } else {
                prevBtn.style.display = 'none'; nextBtn.style.display = 'none';
            }
        }

        function handlePositionUpdate(position) {
            lastKnownPosition = position;
            const { latitude, longitude, speed } = position.coords;
            if (!userMarker) userMarker = L.marker([latitude, longitude], { icon: createUserLocationIcon() }).addTo(map);
            else userMarker.setLatLng([latitude, longitude]);
            map.panTo([latitude, longitude], {animate: true, duration: 0.5}); 
            document.getElementById('speedDisplay').textContent = `Velocidad: ${(speed ? (speed * 3.6) : 0).toFixed(1)} KM/H`;

            if (currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) {
                return; 
            }
            
            const manualNav = document.getElementById('manualStopNav').checked;
            let advancedThisTick = false;

            if (!manualNav) {
                const currentTargetPoint = trackingState.activeLegPoints[currentSegmentStartIndex + 1];
                if (currentTargetPoint.pointCategory !== 'waypoint') { 
                    const distanceToTarget = L.latLng(latitude, longitude).distanceTo(L.latLng(currentTargetPoint.lat, currentTargetPoint.lng));
                    if (distanceToTarget < currentStopRadius) {
                        advanceToNextActivePoint(); advancedThisTick = true;
                    }
                } else { // Handle auto-advance for waypoints if desired (currently waypoints don't auto-advance)
                    // To auto-advance waypoints, add distance check here similar to stops.
                    // For now, waypoints are only advanced manually or if they are the very next point and a stop is reached.
                }
            }
            if (!advancedThisTick && currentSegmentStartIndex < trackingState.activeLegPoints.length -1) { 
                 calculateTimeDeviation(position);
            }
        }
        
        function advanceToNextActivePoint() { 
            currentSegmentStartIndex++;
            if (currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) { 
                handleEndOfLeg();
            } else {
                highlightNextStopInList(); updateManualNavButtons();
                if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition);
            }
        }

        function handleEndOfLeg() {
            if (trackingState.currentFlag === routeSettings.flagNameIda) {
                trackingState.currentFlag = routeSettings.flagNameVuelta;
            } else {
                trackingState.currentTurn++;
                if (trackingState.currentTurn > routeSettings.totalTurns) {
                    stopTracking(true); return;
                }
                trackingState.currentFlag = routeSettings.flagNameIda;
            }

            currentSegmentStartIndex = 0;
            if (!setupCurrentLegForTracking()) {
                 stopTracking(false, `Error configurando pierna ${trackingState.currentFlag} (Vuelta ${trackingState.currentTurn}).`); return;
            }
            updateTrackingStatusDisplay(); redrawRouteLine(); highlightNextStopInList();
            updateManualNavButtons(); if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition);
            
            if (trackingState.activeLegPoints.length > 0) {
                map.setView([trackingState.activeLegPoints[0].lat, trackingState.activeLegPoints[0].lng], map.getZoom()); 
            }
        }
        
        function goToPreviousActivePoint() {
            if (!isTracking || currentSegmentStartIndex === 0) return;
            currentSegmentStartIndex--;
            highlightNextStopInList(); updateManualNavButtons();
            if (lastKnownPosition) calculateTimeDeviation(lastKnownPosition);
        }
        function goToNextActivePoint() { 
            if (!isTracking || currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) return;
            advanceToNextActivePoint();
        }

        function highlightNextStopInList() {
            document.querySelectorAll('#stopsList .stop-item').forEach(item => item.classList.remove('next-stop-highlight'));
            let nextStopName = "N/A";

            if (isTracking && trackingState.activeLegPoints.length > 0 && 
                currentSegmentStartIndex < trackingState.activeLegPoints.length - 1) {
                
                let displayableNextTarget = null;
                for(let i = currentSegmentStartIndex + 1; i < trackingState.activeLegPoints.length; i++){
                    if(trackingState.activeLegPoints[i].pointCategory !== 'waypoint'){
                        displayableNextTarget = trackingState.activeLegPoints[i];
                        break;
                    }
                }
                if (!displayableNextTarget && trackingState.activeLegPoints.length > currentSegmentStartIndex +1 ) { // If only waypoints left, show next waypoint
                     displayableNextTarget = trackingState.activeLegPoints[currentSegmentStartIndex + 1];
                }


                if(displayableNextTarget) {
                    nextStopName = displayableNextTarget.name;
                    const displayPoints = getSortedRoutePointsForDisplay(); // This list only contains stops/endpoints
                    const displayIndex = displayPoints.findIndex(dp => dp.id === displayableNextTarget.id);
                    if (displayIndex !== -1 && document.querySelectorAll('#stopsList .stop-item')[displayIndex]) {
                        document.querySelectorAll('#stopsList .stop-item')[displayIndex].classList.add('next-stop-highlight');
                    }
                }
            } else if (!isTracking) {
                const displayPoints = getSortedRoutePointsForDisplay();
                if (displayPoints.length > 0 && displayPoints[0].pointCategory !== 'waypoint') {
                     nextStopName = displayPoints[0].name;
                }
            }
            document.getElementById('nextStopDisplay').textContent = `Próxima: ${nextStopName}`;
        }

        function calculateTimeDeviation(currentUserGeoPosition) { 
            if (!isTracking || currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) {
                document.getElementById('timeDeviation').textContent = "00:00";
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                return;
            }

            const pointA = trackingState.activeLegPoints[currentSegmentStartIndex];
            const pointB = trackingState.activeLegPoints[currentSegmentStartIndex + 1];

            if (!pointA || !pointB || !pointA.effectiveScheduledTime || !pointB.effectiveScheduledTime ||
                pointA.pointCategory === 'waypoint' || pointB.pointCategory === 'waypoint') { 
                document.getElementById('timeDeviation').textContent = "N/A_T";
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                return;
            }
            const scheduledTimeA = new Date(pointA.effectiveScheduledTime);
            const scheduledTimeB = new Date(pointB.effectiveScheduledTime);
            const segmentTotalScheduledMillis = scheduledTimeB.getTime() - scheduledTimeA.getTime();

            if (segmentTotalScheduledMillis <= 0 && !(scheduledTimeA.getTime() === scheduledTimeB.getTime() && pointA.id === pointB.id) ) { 
                document.getElementById('timeDeviation').textContent = "ERR_DUR";
                document.getElementById('timeDeviation').style.color = "#FFA500";
                return;
            }

            const latLngA = L.latLng(pointA.lat, pointA.lng);
            const latLngB = L.latLng(pointB.lat, pointB.lng);
            const currentUserLatLng = L.latLng(currentUserGeoPosition.coords.latitude, currentUserGeoPosition.coords.longitude);
            const distanceTotalSegment = latLngA.distanceTo(latLngB);
            let progressPercentage;

            if (distanceTotalSegment < 1.0) { 
                progressPercentage = 0; 
                 const now = new Date();
                let expectedTimeAtCurrentPosMillis;
                if (now.getTime() > (scheduledTimeA.getTime() + segmentTotalScheduledMillis / 2)) {
                    expectedTimeAtCurrentPosMillis = scheduledTimeB.getTime();
                } else {
                    expectedTimeAtCurrentPosMillis = scheduledTimeA.getTime();
                }
                const deviationMillisSpecial = expectedTimeAtCurrentPosMillis - now.getTime();
                displayDeviation(deviationMillisSpecial);
                return;
            }
            
            const distToA = currentUserLatLng.distanceTo(latLngA); 
            const distToB = currentUserLatLng.distanceTo(latLngB); 
            if (distToA < 10.0) progressPercentage = 0.0; 
            else if (distToB < 10.0) progressPercentage = 1.0; 
            else if (Math.abs(distToA - (distanceTotalSegment + distToB)) < 20.0 && distToA > distanceTotalSegment) progressPercentage = 1.0; 
            else if (Math.abs(distToB - (distanceTotalSegment + distToA)) < 20.0 && distToB > distanceTotalSegment) progressPercentage = 0.0; 
            else { 
                const dist_A_to_P_prime_on_AB = (Math.pow(distanceTotalSegment, 2) + Math.pow(distToA, 2) - Math.pow(distToB, 2)) / (2 * distanceTotalSegment);
                progressPercentage = dist_A_to_P_prime_on_AB / distanceTotalSegment;
            }
            progressPercentage = Math.max(0, Math.min(1, progressPercentage)); 

            const expectedTimeElapsedMillis = segmentTotalScheduledMillis * progressPercentage;
            const expectedTimeAtCurrentPosition = new Date(scheduledTimeA.getTime() + expectedTimeElapsedMillis);
            const currentTime = new Date();
            const deviationMillis = expectedTimeAtCurrentPosition.getTime() - currentTime.getTime();
            displayDeviation(deviationMillis);
        }

        function displayDeviation(deviationMillis) { 
            const absMillis = Math.abs(deviationMillis);
            const totalSecondsValue = Math.floor(absMillis / 1000);
            const displaySeconds = totalSecondsValue % 60;
            const totalMinutesValue = Math.floor(totalSecondsValue / 60);
            const sign = deviationMillis >= 0 ? "+" : "-";
            const formattedDeviation = `${sign}${String(totalMinutesValue).padStart(2, '0')}:${String(displaySeconds).padStart(2, '0')}`;
            const deviationDiv = document.getElementById('timeDeviation');
            deviationDiv.textContent = formattedDeviation;
            if (deviationMillis >= -59999 && deviationMillis <= 59999) deviationDiv.style.color = "#FFFFFF"; 
            else if (deviationMillis > 59999) deviationDiv.style.color = "#00FF00"; 
            else deviationDiv.style.color = "#FF0000"; 
        }
        function handleGeolocationError(error) { 
            console.error("Error de geolocalización: ", error);
            alert(`Error de geolocalización: ${error.message}.`);
            if (isTracking) stopTracking(false, "Error de geolocalización"); 
        }

        function getRouteQueue() { const q = localStorage.getItem(ROUTE_QUEUE_CACHE_KEY); return q ? JSON.parse(q) : [];}
        function saveRouteQueue(queue) { localStorage.setItem(ROUTE_QUEUE_CACHE_KEY, JSON.stringify(queue)); updateRouteQueueDisplay();}
        function addRouteToQueue() { 
            const selectedRouteName = document.getElementById('routeToQueue').value;
            if (!selectedRouteName || document.getElementById('routeToQueue').options[0]?.disabled) { 
                alert("Selecciona una ruta válida para añadir."); return;
            }
            const queue = getRouteQueue(); if (queue.includes(selectedRouteName)) { alert("Ruta ya en cola."); return; }
            queue.push(selectedRouteName); saveRouteQueue(queue); alert(`Ruta "${selectedRouteName}" añadida.`);
        }
        function updateRouteQueueDisplay() { 
            const queueDiv = document.getElementById('routeQueueDisplay'); const queue = getRouteQueue();
            if (queue.length === 0) { queueDiv.innerHTML = "Vacía."; } 
            else { let html = "<ol>"; queue.forEach(rn => { html += `<li>${rn}</li>`; }); html += "</ol>"; queueDiv.innerHTML = html; }
        }
        function clearRouteQueue() { if (confirm("¿Limpiar toda la cola?")) saveRouteQueue([]);}
        function checkRouteQueue() { 
            let queue = getRouteQueue();
            if (queue.length > 0) {
                const nextRouteName = queue.shift(); saveRouteQueue(queue); 
                if (confirm(`Ruta finalizada. ¿Iniciar siguiente: "${nextRouteName}"?`)) {
                    const savedRoutesSelect = document.getElementById('savedRoutes');
                    if (Array.from(savedRoutesSelect.options).some(opt => opt.value === nextRouteName)) {
                        savedRoutesSelect.value = nextRouteName; loadRoute(); 
                        setTimeout(() => { if (routePoints.filter(p=>p.pointCategory==='lineEndpoint').length >=2) startTracking(); else alert("Error al cargar ruta de cola o es inválida."); }, 500); 
                    } else alert(`Ruta "${nextRouteName}" no encontrada.`);
                } else alert("Siguiente ruta no iniciada.");
            }
        }

        function updateGlobalStopRadiusSettings() { 
            const newRadius = parseInt(document.getElementById('stopRadiusInput').value, 10);
            if (!isNaN(newRadius) && newRadius >= 10 && newRadius <= 500) {
                currentStopRadius = newRadius;
                routePoints.forEach(point => {
                    if (point.radiusCircle) point.radiusCircle.setRadius(currentStopRadius);
                });
            } else {
                alert("Radio inválido (10-500m).");
                document.getElementById('stopRadiusInput').value = currentStopRadius;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initMap(); 
            loadSavedRoutesLists(); 
            updateStopsList(); 
            updateManualNavButtons(); 
            setActiveMode(null); // Initialize with no active mode and set default status message
            updateTrackingStatusDisplay();
        });

    </script>
</body>
</html>
