<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        /* --- Estilos Generales --- */
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; background-color: #f4f4f4; font-size: 14px; /* Base para móvil */ }
        body { display: flex; flex-direction: column; }
        header { background-color: #333; color: white; padding: 8px 15px; text-align: center; flex-shrink: 0; font-size: 1.1em; }
        main { display: flex; flex-direction: column; flex: 1; overflow: hidden; padding: 5px; }
        button { cursor: pointer; }
        button:disabled { cursor: not-allowed; background-color: #cccccc !important; color: #666 !important; }
        input[readonly] { background-color: #e9e9e9 !important; }

        /* --- Mapa --- */
        #map-container { height: 40vh; /* Reducido para más controles */ display: flex; flex-direction: column; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 10px; flex-shrink: 0; }
        #map-header { padding: 8px; background-color: #eee; border-bottom: 1px solid #ccc; border-radius: 8px 8px 0 0; font-weight: bold; font-size: 0.9em; text-align: center; flex-shrink: 0; }
        #map { flex: 1; border-radius: 0 0 8px 8px; cursor: crosshair; }
        .leaflet-control-zoom { transform: scale(1.1); transform-origin: top left; }

        /* --- Controles --- */
        #controls { flex: 1; display: flex; flex-direction: column; gap: 10px; padding: 10px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow-y: auto; width: auto; }
        .control-section { border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 10px; }
        .control-section:last-child { border-bottom: none; margin-bottom: 0; }
        .control-section h3 { margin-top: 0; margin-bottom: 8px; font-size: 1em; color: #333; }

        /* --- Estado y GPS --- */
        #status-display { padding: 10px; border-radius: 5px; text-align: center; font-size: 1.2em; /* Ajustado */ font-weight: bold; line-height: 1.3; min-height: 3.5em; display: flex; flex-direction: column; justify-content: center; }
        #status-display .status-info { font-size: 0.8em; font-weight: normal; color: #333; margin-bottom: 4px;}
        #status-display .status-time { font-size: 1.3em; font-weight: bold; }
        #status-display.on-time { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        #status-display.late { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        #status-display.early { background-color: #cce5ff; color: #004085; border: 1px solid #b8daff; }
        #status-display.idle { background-color: #e2e3e5; color: #383d41; border: 1px solid #d6d8db; font-size: 1em; justify-content: center; }
        #gps-status { font-size: 0.75em; text-align: center; color: #666; margin-top: 5px; padding: 0; }
        #tracking-controls { display: flex; gap: 10px; margin-top: 5px;}
        #tracking-controls button { flex: 1; padding: 8px 5px; font-size: 0.9em; } /* Botones Iniciar/Detener */
        #stopTrackingBtn { background-color: #dc3545; }
        #stopTrackingBtn:hover { background-color: #c82333; }


        /* --- Modo Avance --- */
        #navigation-mode-controls { display: flex; align-items: center; gap: 15px; margin-top: 5px; flex-wrap: wrap; }
        #navigation-mode-controls label { display: flex; align-items: center; font-size: 0.85em; gap: 5px; }
        #manual-buttons { display: flex; gap: 10px; flex-grow: 1; }
        #manual-buttons button { flex: 1; margin-bottom: 0; background-color: #6c757d; padding: 6px 5px; font-size: 0.85em; }
        #manual-buttons button:hover { background-color: #5a6268; }

        /* --- Formulario Añadir/Editar Parada --- */
        #add-edit-stop-form label { display: block; margin-bottom: 3px; font-weight: bold; font-size: 0.85em; }
        #add-edit-stop-form .coord-inputs { display: flex; gap: 5px; margin-bottom: 8px; }
        #add-edit-stop-form .coord-inputs input { flex: 1; }
        #add-edit-stop-form .time-inputs { display: flex; gap: 10px; margin-bottom: 8px; }
        #add-edit-stop-form .time-inputs > div { flex: 1; }
        #add-edit-stop-form input, #add-edit-stop-form button { width: 100%; padding: 8px 10px; margin-bottom: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9em; }
        #add-edit-stop-form button { background-color: #007bff; color: white; border: none; }
        #add-edit-stop-form button:hover { background-color: #0056b3; }
        #addEditStopBtn.update-mode { background-color: #ffc107; color: #333; } /* Botón actualizar */
        #addEditStopBtn.update-mode:hover { background-color: #e0a800; }
        #cancelEditBtn { background-color: #6c757d; display: none; } /* Oculto por defecto */
        #cancelEditBtn:hover { background-color: #5a6268; }
        body.editing-stop #cancelEditBtn { display: block; } /* Mostrar al editar */

        /* --- Gestión Rutas (Lista y botones) --- */
        #route-management label { font-weight: bold; font-size: 0.85em; }
        #route-indicator { font-size: 0.8em; color: #555; margin-bottom: 5px; text-align: center; font-weight: bold; }
        #stops-list { list-style: none; padding: 0; margin: 5px 0 0 0; max-height: 110px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px; }
        #stops-list li { padding: 6px 8px; border-bottom: 1px solid #eee; font-size: 0.8em; display: flex; justify-content: space-between; align-items: center; gap: 5px; cursor: default; /* Cambia cursor al pasar por encima si no se rastrea */ }
        #stops-list li:last-child { border-bottom: none; }
        /* Permitir click en item de lista solo si no se está rastreando */
        body:not(.tracking-active) #stops-list li:not(.editing) { cursor: pointer; }
        body:not(.tracking-active) #stops-list li:not(.editing):hover { background-color: #f0f0f0; }
        #stops-list li.editing { background-color: #fff3cd !important; font-weight: bold; } /* Resaltado al editar */
        #stops-list li.active-stop { background-color: #e0e8ff; font-weight: bold; } /* Resaltado al seguir */
        #stops-list li .stop-details { flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        #stops-list li .stop-times { font-size: 0.9em; color: #555; text-align: right; white-space: nowrap; }
        #stops-list li .stop-actions button { background-color: #dc3545; color: white; border: none; padding: 2px 5px; border-radius: 3px; font-size: 0.75em; flex-shrink: 0; margin-left: 5px; }
        #stops-list li .stop-actions button:hover { background-color: #c82333; }
        body.tracking-active #stops-list li .stop-actions button { display: none; } /* Ocultar X durante tracking */

        #route-crud-buttons, #route-finish-button { display: flex; gap: 10px; margin-top: 10px; }
        #route-crud-buttons button, #route-finish-button button { flex: 1; padding: 8px 5px; font-size: 0.9em; }
        #finishRouteBtn { background-color: #28a745; }
        #finishRouteBtn:hover { background-color: #218838; }
        #saveRoutesBtn { background-color: #17a2b8; }
        #saveRoutesBtn:hover { background-color: #138496; }
        #loadRoutesBtn { background-color: #ffc107; color: #333;}
        #loadRoutesBtn:hover { background-color: #e0a800; }
        #clearAllBtn { background-color: #dc3545; }
        #clearAllBtn:hover { background-color: #c82333; }

    </style>
</head>
<body class=""> <!-- Clases 'tracking-active', 'editing-stop' se gestionan con JS -->

    <header><h1>Smart Move Pro</h1></header>

    <main>
        <div id="map-container">
            <div id="map-header">Toca el mapa para fijar ubicación</div>
            <div id="map"></div>
        </div>

        <div id="controls">
            <!-- Sección Estado y Control de Seguimiento -->
            <div id="status-section" class="control-section">
                <h3>Estado Actual</h3>
                <div id="status-display" class="idle">
                    <span class="status-info">Carga o crea rutas</span>
                    <span class="status-time">--:--</span>
                </div>
                <div id="tracking-controls">
                    <button id="startTrackingBtn" disabled>Iniciar Seguimiento</button>
                    <button id="stopTrackingBtn" disabled>Detener Seguimiento</button> <!-- NUEVO -->
                </div>
                 <p id="gps-status">GPS: Esperando señal...</p>
            </div>

            <!-- Sección Modo de Avance -->
            <div id="navigation-mode" class="control-section">
                <h3>Modo de Avance (Durante Seguimiento)</h3>
                <div id="navigation-mode-controls">
                    <label for="manualModeCheckbox"><input type="checkbox" id="manualModeCheckbox" disabled> Manual</label>
                    <div id="manual-buttons">
                        <button id="prevBtn" disabled> < Ant </button>
                        <button id="nextBtn" disabled> Sig > </button>
                    </div>
                </div>
            </div>

            <!-- Sección Añadir/Editar Parada -->
            <div id="add-edit-stop-form" class="control-section">
                <h3 id="add-stop-title">Añadir Parada (Ruta 1)</h3>
                 <input type="hidden" id="editingStopId" value=""> <!-- Campo oculto para ID en edición -->
                <label for="stop-lat">Ubicación (Lat/Lng):</label>
                <div class="coord-inputs">
                    <input type="number" id="stop-lat" step="any" placeholder="Toca mapa" readonly>
                    <input type="number" id="stop-lng" step="any" placeholder="Toca mapa" readonly>
                </div>
                <label for="stop-name">Nombre Parada:</label>
                <input type="text" id="stop-name" placeholder="Ej: Parada Centro">
                <div class="time-inputs">
                    <div><label for="stop-time">Llegada (HH:MM):</label><input type="time" id="stop-time"></div>
                    <div><label for="stop-departure-time">Salida (HH:MM):</label><input type="time" id="stop-departure-time"></div>
                </div>
                <button id="addEditStopBtn">Añadir Parada</button>
                <button id="cancelEditBtn">Cancelar Edición</button> <!-- Oculto por defecto -->
            </div>

            <!-- Sección Gestión de Rutas -->
            <div id="route-management" class="control-section">
                <h3 id="route-list-title">Editando Ruta 1</h3>
                <div id="route-indicator">Total Rutas: 0</div>
                <ul id="stops-list"></ul>
                 <div id="route-finish-button">
                    <button id="finishRouteBtn" disabled>Finalizar Ruta Actual / Crear Siguiente</button>
                </div>
                 <div id="route-crud-buttons">
                     <button id="saveRoutesBtn">Guardar Rutas</button>
                     <button id="loadRoutesBtn">Cargar Rutas</button>
                     <button id="clearAllBtn">Borrar Todo</button>
                 </div>
            </div>
        </div>
    </main>

    <script>
        // --- Constantes y Variables Globales ---
        const LOCAL_STORAGE_KEY = 'smartMoveProRoutes';
        const R = 6371; // Radio Tierra km
        const ARRIVAL_THRESHOLD_METERS = 50; // Distancia para detectar llegada
        const ON_TIME_THRESHOLD_SECONDS = 30; // Umbral para considerar 'a horario'

        let map;
        let routes = [[]]; // Array de rutas, cada ruta es array de paradas
        let currentLocationMarker = null;
        let stopMarkers = {}; // { stopId: marker }
        let currentRouteIndex = -1; // Índice de RUTA en seguimiento
        let currentStopIndex = -1; // Índice de PRÓXIMA PARADA en seguimiento
        let currentRouteBeingBuiltIndex = 0; // Índice de RUTA en edición/creación
        let editingStopId = null; // ID de la parada en edición
        let watchId = null; // ID del watcher GPS
        let lastKnownPosition = null;
        let arrivalMarker = null; // Marcador visual temporal llegada
        let currentStatusInfo = { phase: 'idle', text: 'Carga o crea rutas' };
        let isManualMode = false; // Modo avance manual

        // --- Elementos del DOM (Cache) ---
        const DOMElements = {
            stopNameInput: document.getElementById('stop-name'),
            stopTimeInput: document.getElementById('stop-time'),
            stopDepartureTimeInput: document.getElementById('stop-departure-time'),
            stopLatInput: document.getElementById('stop-lat'),
            stopLngInput: document.getElementById('stop-lng'),
            addEditStopBtn: document.getElementById('addEditStopBtn'),
            cancelEditBtn: document.getElementById('cancelEditBtn'),
            editingStopIdInput: document.getElementById('editingStopId'),
            finishRouteBtn: document.getElementById('finishRouteBtn'),
            stopsList: document.getElementById('stops-list'),
            startTrackingBtn: document.getElementById('startTrackingBtn'),
            stopTrackingBtn: document.getElementById('stopTrackingBtn'), // NUEVO
            statusDisplay: document.getElementById('status-display'),
            statusInfoSpan: document.querySelector('#status-display .status-info'),
            statusTimeSpan: document.querySelector('#status-display .status-time'),
            gpsStatus: document.getElementById('gps-status'),
            addStopTitle: document.getElementById('add-stop-title'),
            routeListTitle: document.getElementById('route-list-title'),
            routeIndicator: document.getElementById('route-indicator'),
            manualModeCheckbox: document.getElementById('manualModeCheckbox'),
            prevBtn: document.getElementById('prevBtn'),
            nextBtn: document.getElementById('nextBtn'),
            saveRoutesBtn: document.getElementById('saveRoutesBtn'), // NUEVO
            loadRoutesBtn: document.getElementById('loadRoutesBtn'), // NUEVO
            clearAllBtn: document.getElementById('clearAllBtn') // NUEVO
        };

        // --- Inicialización Aplicación ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeMap();
            loadRoutesFromLocalStorage(); // Carga rutas al inicio
            bindEventListeners();
            updateUIBasedOnState(); // Estado inicial UI

            navigator.geolocation.getCurrentPosition(
                (pos) => { map.setView([pos.coords.latitude, pos.coords.longitude], 14); updateGPSStatus(`Precisión: ${pos.coords.accuracy.toFixed(0)}m`); },
                () => { map.setView([-34.6037, -58.3816], 12); updateGPSStatus("GPS inicial no disponible."); },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        });

        function initializeMap() {
             map = L.map('map', { zoomControl: true }).setView([-34.6037, -58.3816], 12);
             map.zoomControl.setPosition('bottomright');
             L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OSM', maxZoom: 19 }).addTo(map);
             map.on('click', handleMapClick);
        }

        function bindEventListeners() {
            DOMElements.addEditStopBtn.addEventListener('click', handleAddOrUpdateStop);
            DOMElements.cancelEditBtn.addEventListener('click', cancelEditMode);
            DOMElements.finishRouteBtn.addEventListener('click', finishCurrentRoute);
            DOMElements.startTrackingBtn.addEventListener('click', startRouteTracking);
            DOMElements.stopTrackingBtn.addEventListener('click', () => stopTracking('manual')); // NUEVO Listener
            DOMElements.manualModeCheckbox.addEventListener('change', toggleManualMode);
            DOMElements.prevBtn.addEventListener('click', goToPreviousStopOrRoute);
            DOMElements.nextBtn.addEventListener('click', goToNextStopOrRoute);
            DOMElements.saveRoutesBtn.addEventListener('click', saveRoutesToLocalStorage); // NUEVO Listener
            DOMElements.loadRoutesBtn.addEventListener('click', handleLoadRoutesClick); // NUEVO Listener
            DOMElements.clearAllBtn.addEventListener('click', handleClearAllClick); // NUEVO Listener
            // Listener para seleccionar parada para editar (delegación de eventos)
            DOMElements.stopsList.addEventListener('click', handleStopListClick);
        }

        // --- Lógica Guardar/Cargar Rutas ---
        function saveRoutesToLocalStorage() {
            try {
                // Filtrar rutas vacías antes de guardar (opcional, pero bueno)
                const routesToSave = routes.filter(route => route && route.length > 0);
                if (routesToSave.length === 0) {
                     alert("No hay rutas con paradas para guardar.");
                     return;
                }
                const routesJSON = JSON.stringify(routesToSave);
                localStorage.setItem(LOCAL_STORAGE_KEY, routesJSON);
                alert(`Rutas guardadas (${routesToSave.length} ruta(s)).`);
                console.log("Rutas guardadas en localStorage.");
            } catch (error) {
                console.error("Error al guardar rutas:", error);
                alert("Error al guardar rutas. Revisa la consola para detalles.");
            }
        }

        function loadRoutesFromLocalStorage() {
            const routesJSON = localStorage.getItem(LOCAL_STORAGE_KEY);
            let loadedSuccessfully = false;
            if (routesJSON) {
                try {
                    const parsedRoutes = JSON.parse(routesJSON);
                    // Validación básica de la estructura cargada
                    if (Array.isArray(parsedRoutes) && parsedRoutes.every(route => Array.isArray(route))) {
                        routes = parsedRoutes;
                        // Si la última ruta cargada no está vacía, añadir una nueva vacía para seguir editando
                        if (routes.length > 0 && routes[routes.length - 1].length > 0) {
                             routes.push([]);
                        } else if (routes.length === 0) {
                             routes = [[]]; // Asegurar que siempre haya al menos una ruta vacía si no se cargó nada
                        }
                        currentRouteBeingBuiltIndex = routes.length - 1; // Apuntar a la última (posiblemente nueva vacía)
                        console.log(`Rutas cargadas desde localStorage (${parsedRoutes.length} ruta(s) encontradas).`);
                         loadedSuccessfully = true;
                    } else {
                        console.error("Datos de rutas en localStorage tienen formato inválido.");
                        routes = [[]]; // Resetear a estado inicial si hay error
                        currentRouteBeingBuiltIndex = 0;
                    }
                } catch (error) {
                    console.error("Error al parsear rutas desde localStorage:", error);
                    routes = [[]]; // Resetear a estado inicial si hay error
                    currentRouteBeingBuiltIndex = 0;
                }
            } else {
                console.log("No se encontraron rutas guardadas en localStorage.");
                routes = [[]]; // Estado inicial si no hay nada guardado
                currentRouteBeingBuiltIndex = 0;
            }
            // Renderizar marcadores y UI después de cargar
            removeAllStopMarkers();
            routes.forEach(route => route.forEach(addStopMarker));
            renderStopsList();
            updateUIBasedOnState();
            return loadedSuccessfully; // Indica si se cargó algo
        }

        function handleLoadRoutesClick() {
            if (currentRouteIndex !== -1) {
                 alert("Detén el seguimiento actual antes de cargar rutas.");
                 return;
            }
            if (confirm("¿Cargar rutas guardadas? Esto reemplazará las rutas actuales no guardadas.")) {
                if (loadRoutesFromLocalStorage()) {
                    alert("Rutas cargadas.");
                } else {
                     alert("No se encontraron rutas guardadas o hubo un error al cargar.");
                }
            }
        }

        function handleClearAllClick() {
             if (currentRouteIndex !== -1) {
                 alert("Detén el seguimiento actual antes de borrar todo.");
                 return;
            }
             if (confirm("¿Estás seguro de que quieres borrar TODAS las rutas y paradas actuales? Esta acción no se puede deshacer.")) {
                  routes = [[]]; // Resetear a una única ruta vacía
                  currentRouteBeingBuiltIndex = 0;
                  editingStopId = null; // Cancelar edición si la había
                  removeAllStopMarkers();
                  renderStopsList();
                  updateUIBasedOnState();
                  // Opcional: Limpiar también localStorage
                  // localStorage.removeItem(LOCAL_STORAGE_KEY);
                  // alert("Todas las rutas borradas.");
                  console.log("Todas las rutas borradas.");
             }
        }


        // --- Lógica Añadir/Editar/Cancelar Parada ---
        function handleAddOrUpdateStop() {
            if (editingStopId) {
                updateStop(); // Llama a la función de actualizar
            } else {
                addStop(); // Llama a la función de añadir
            }
        }

        function addStop() {
            // ... (validaciones como antes) ...
             const arrivalTime = DOMElements.stopTimeInput.value;
             const departureTime = DOMElements.stopDepartureTimeInput.value;
             const lat = parseFloat(DOMElements.stopLatInput.value);
             const lng = parseFloat(DOMElements.stopLngInput.value);
             if (!arrivalTime || !departureTime || isNaN(lat) || isNaN(lng)) { alert("Completa ubicación (mapa), hora de llegada y hora de salida."); return; }
             const arrivalDate = parseTimeString(arrivalTime); const departureDate = parseTimeString(departureTime);
             if (!arrivalDate || !departureDate || departureDate < arrivalDate) { alert("La hora de salida debe ser igual o posterior a la hora de llegada."); return; }

            const name = DOMElements.stopNameInput.value.trim() || `Parada (${lat.toFixed(3)})`;
            const stopId = Date.now();
            const newStop = { id: stopId, name, time: arrivalTime, departureTime: departureTime, lat, lng };

            if (!routes[currentRouteBeingBuiltIndex]) routes[currentRouteBeingBuiltIndex] = [];
            routes[currentRouteBeingBuiltIndex].push(newStop);
            routes[currentRouteBeingBuiltIndex].sort((a, b) => a.time.localeCompare(b.time)); // Siempre ordenar por hora llegada

            addStopMarker(newStop);
            clearAddEditStopForm();
            renderStopsList();
            updateUIBasedOnState();
        }

        function updateStop() {
            const routeToEdit = routes[currentRouteBeingBuiltIndex];
            const stopIndex = routeToEdit.findIndex(s => s.id === editingStopId);
            if (stopIndex === -1) {
                 console.error("No se encontró la parada a editar.");
                 cancelEditMode();
                 return;
            }

             // ... (validaciones como en addStop) ...
             const arrivalTime = DOMElements.stopTimeInput.value;
             const departureTime = DOMElements.stopDepartureTimeInput.value;
             const lat = parseFloat(DOMElements.stopLatInput.value);
             const lng = parseFloat(DOMElements.stopLngInput.value);
             if (!arrivalTime || !departureTime || isNaN(lat) || isNaN(lng)) { alert("Completa todos los campos para actualizar."); return; }
             const arrivalDate = parseTimeString(arrivalTime); const departureDate = parseTimeString(departureTime);
             if (!arrivalDate || !departureDate || departureDate < arrivalDate) { alert("La hora de salida debe ser igual o posterior a la hora de llegada."); return; }

            const updatedName = DOMElements.stopNameInput.value.trim() || `Parada (${lat.toFixed(3)})`;

             // Actualizar datos de la parada
            const stopToUpdate = routeToEdit[stopIndex];
            stopToUpdate.name = updatedName;
            stopToUpdate.time = arrivalTime;
            stopToUpdate.departureTime = departureTime;
            stopToUpdate.lat = lat;
            stopToUpdate.lng = lng;

            // Actualizar marcador en mapa (ubicación y popup)
             if (stopMarkers[editingStopId]) {
                 stopMarkers[editingStopId].setLatLng([lat, lng]);
                 const routeNum = currentRouteBeingBuiltIndex + 1;
                 stopMarkers[editingStopId].setPopupContent(`<b>${updatedName}</b><br>(Ruta ${routeNum})<br>Lleg: ${arrivalTime} / Sal: ${departureTime}`);
             }

             // Reordenar la ruta actual por hora y salir del modo edición
            routeToEdit.sort((a, b) => a.time.localeCompare(b.time));
            cancelEditMode(); // Limpia form, resetea botones, etc.
            renderStopsList(); // Re-renderizar lista con datos actualizados
            updateUIBasedOnState();
            console.log("Parada actualizada:", editingStopId);
        }

        function handleStopListClick(event) {
            // No permitir selección si se está rastreando o ya se está editando
             if (currentRouteIndex !== -1 || editingStopId) return;

             // Encontrar el elemento <li> clickeado
            const listItem = event.target.closest('li');
            if (!listItem || !listItem.dataset.stopId) return; // No se clickeó un item válido

            const stopIdToEdit = parseInt(listItem.dataset.stopId, 10);
            enterEditMode(stopIdToEdit);
        }

        function enterEditMode(stopId) {
             const route = routes[currentRouteBeingBuiltIndex];
             const stopToEdit = route.find(s => s.id === stopId);
             if (!stopToEdit) return;

             editingStopId = stopId;
             DOMElements.editingStopIdInput.value = stopId; // Guardar en input oculto (aunque no se use, buena práctica)

             // Poblar formulario
             DOMElements.stopNameInput.value = stopToEdit.name;
             DOMElements.stopTimeInput.value = stopToEdit.time;
             DOMElements.stopDepartureTimeInput.value = stopToEdit.departureTime;
             DOMElements.stopLatInput.value = stopToEdit.lat.toFixed(6);
             DOMElements.stopLngInput.value = stopToEdit.lng.toFixed(6);

             // Cambiar UI a modo edición
             DOMElements.addEditStopBtn.textContent = "Actualizar Parada";
             DOMElements.addEditStopBtn.classList.add('update-mode');
             DOMElements.cancelEditBtn.style.display = 'block';
             document.body.classList.add('editing-stop'); // Clase para CSS (ej. resaltar item)

              // Resaltar item en la lista
             document.querySelectorAll('#stops-list li').forEach(li => li.classList.remove('editing'));
             const listItem = DOMElements.stopsList.querySelector(`li[data-stop-id="${stopId}"]`);
             if (listItem) listItem.classList.add('editing');

             console.log("Editando parada:", stopId);
        }

        function cancelEditMode() {
             editingStopId = null;
             DOMElements.editingStopIdInput.value = "";
             clearAddEditStopForm(); // Limpia campos del formulario

             // Resetear UI
             DOMElements.addEditStopBtn.textContent = "Añadir Parada";
             DOMElements.addEditStopBtn.classList.remove('update-mode');
             DOMElements.cancelEditBtn.style.display = 'none';
             document.body.classList.remove('editing-stop');
             document.querySelectorAll('#stops-list li').forEach(li => li.classList.remove('editing'));
             console.log("Edición cancelada.");
        }

        function clearAddEditStopForm() {
             DOMElements.stopNameInput.value = '';
             DOMElements.stopTimeInput.value = '';
             DOMElements.stopDepartureTimeInput.value = '';
             DOMElements.stopLatInput.value = '';
             DOMElements.stopLngInput.value = '';
        }

        // --- Lógica de Finalizar Ruta ---
        function finishCurrentRoute() {
             if (currentRouteIndex !== -1 || editingStopId) return;
             const currentRoute = routes[currentRouteBeingBuiltIndex];
             if (!currentRoute || currentRoute.length === 0) { alert("Añade paradas antes de finalizar."); return; }
             currentRouteBeingBuiltIndex++;
             // Solo añadir array vacío si realmente no existe ya uno en ese índice
             if (currentRouteBeingBuiltIndex >= routes.length) {
                 routes.push([]);
             }
             renderStopsList(); // Mostrará la nueva ruta (vacía)
             updateUIBasedOnState(); // Actualizará títulos, etc.
        }

        // --- Manejo Click en Mapa ---
        function handleMapClick(e) {
             const lat = e.latlng.lat.toFixed(6);
             const lng = e.latlng.lng.toFixed(6);
             DOMElements.stopLatInput.value = lat;
             DOMElements.stopLngInput.value = lng;

             // Feedback visual (como antes)
             if (arrivalMarker) map.removeLayer(arrivalMarker);
             arrivalMarker = L.circleMarker(e.latlng, { radius: 6, color: '#ff4136', fillOpacity: 0.7, weight: 1 }).addTo(map);
             setTimeout(() => { if (arrivalMarker && map.hasLayer(arrivalMarker)) map.removeLayer(arrivalMarker); arrivalMarker = null; }, 1000);

             // Si estamos editando, el cambio de coords ya se refleja en los inputs.
             // Si estamos añadiendo, también. No se necesita lógica extra aquí.
        }

        // --- Actualización UI General ---
        function updateUIBasedOnState() {
            const isTracking = currentRouteIndex !== -1;
            const isEditing = editingStopId !== null;
            const currentBuildRoute = routes[currentRouteBeingBuiltIndex];
            const totalRoutesWithStops = routes.filter(r => r && r.length > 0).length;
            const buildRouteNum = currentRouteBeingBuiltIndex + 1;

            // Títulos y indicador
            DOMElements.addStopTitle.textContent = isEditing ? `Editando Parada (Ruta ${buildRouteNum})` : `Añadir Parada (Ruta ${buildRouteNum})`;
            DOMElements.routeListTitle.textContent = isTracking ? `Siguiendo Ruta ${currentRouteIndex + 1}` : `Editando Ruta ${buildRouteNum}`;
            DOMElements.routeIndicator.textContent = `Total Rutas Guardadas (con paradas): ${totalRoutesWithStops}`;

            // Clases de estado Body
            document.body.classList.toggle('tracking-active', isTracking);
            document.body.classList.toggle('editing-stop', isEditing);

            // Botones CRUD Rutas/Paradas
            DOMElements.addEditStopBtn.disabled = isTracking; // No añadir/actualizar durante tracking
            DOMElements.finishRouteBtn.disabled = isTracking || isEditing || !currentBuildRoute || currentBuildRoute.length === 0;
            DOMElements.saveRoutesBtn.disabled = isTracking || isEditing;
            DOMElements.loadRoutesBtn.disabled = isTracking || isEditing;
            DOMElements.clearAllBtn.disabled = isTracking || isEditing;

            // Formulario de parada
             DOMElements.stopNameInput.readOnly = isTracking;
             DOMElements.stopTimeInput.readOnly = isTracking;
             DOMElements.stopDepartureTimeInput.readOnly = isTracking;

            // Botones Tracking
             DOMElements.startTrackingBtn.disabled = isTracking || isEditing || totalRoutesWithStops === 0;
             DOMElements.stopTrackingBtn.disabled = !isTracking; // Solo habilitado durante tracking

            // Controles de Navegación Manual
             DOMElements.manualModeCheckbox.disabled = !isTracking;
             DOMElements.prevBtn.disabled = !isTracking || !isManualMode;
             DOMElements.nextBtn.disabled = !isTracking || !isManualMode;
             if (isTracking && isManualMode) {
                  // Habilitar/deshabilitar botones prev/next en extremos
                 DOMElements.prevBtn.disabled = (currentRouteIndex === 0 && currentStopIndex === 0);
                 const lastRouteIdx = routes.findIndex((r, idx) => idx > currentRouteIndex && r.length > 0) === -1 ? currentRouteIndex : routes.length - 1; // Encuentra el índice de la última ruta válida a seguir
                 const lastValidRoute = routes[lastRouteIdx];
                  // Deshabilitar si estamos apuntando a la última parada de la última ruta válida
                 DOMElements.nextBtn.disabled = (currentRouteIndex === lastRouteIdx && currentStopIndex === lastValidRoute.length); // Ojo: currentStopIndex apunta a la *próxima* a llegar
             }
        }

        // --- Lógica Modo Manual ---
        function toggleManualMode() { /* ... sin cambios ... */
            isManualMode = DOMElements.manualModeCheckbox.checked; console.log("Modo Manual:", isManualMode); updateUIBasedOnState();
        }
        function goToPreviousStopOrRoute() { /* ... sin cambios ... */
             if (!isManualMode || currentRouteIndex === -1) return; console.log("Navegación Manual: Anterior"); currentStopIndex--;
             if (currentStopIndex < 0) { currentRouteIndex--; if (currentRouteIndex < 0) { console.log("Ya estás en la primera parada."); currentRouteIndex = 0; currentStopIndex = 0; } else { currentStopIndex = routes[currentRouteIndex].length - 1; console.log(`Cambiando a Ruta ${currentRouteIndex + 1}, Parada ${currentStopIndex + 1}`); } }
             else { console.log(`Retrocediendo a Parada ${currentStopIndex + 1}`); }
             renderStopsList(); updateUIBasedOnState(); updateStatusForCurrentTarget();
        }
        function goToNextStopOrRoute() { /* ... sin cambios ... */
            if (!isManualMode || currentRouteIndex === -1) return; console.log("Navegación Manual: Siguiente"); advanceStopOrRoute();
        }
        function updateStatusForCurrentTarget() { /* ... sin cambios ... */
             if (currentRouteIndex === -1 || currentStopIndex === -1) return; const currentRoute = routes[currentRouteIndex]; if (!currentRoute || currentStopIndex >= currentRoute.length) return;
             const targetStop = currentRoute[currentStopIndex]; const previousStop = (currentStopIndex > 0) ? currentRoute[currentStopIndex - 1] : null;
             let infoText = `(Manual) Hacia ${targetStop.name}`;
             updateStatusDisplayContent("idle", infoText, "--:--");
        }

        // --- Lógica Seguimiento (Start, Stop, HandleUpdate) ---
        function startRouteTracking() { /* ... sin cambios ... */
             const validRoutes = routes.filter(r => r && r.length > 0);
             if (validRoutes.length === 0) { alert("Crea o carga al menos una ruta con paradas."); return; }
             if (watchId) return;
             // Revalidar tiempos salida (importante si se cargaron rutas)
             for (let r = 0; r < routes.length; r++) { if (!routes[r] || routes[r].length === 0) continue; for (let s = 0; s < routes[r].length; s++) { if (!routes[r][s].departureTime) { alert(`Error: Parada "${routes[r][s].name}" (Ruta ${r+1}) no tiene hora de salida.`); return; } } }

             // Usar solo las rutas válidas para el seguimiento
             const activeTrackingRoutes = routes.filter(r => r && r.length > 0);
             if (activeTrackingRoutes.length === 0) { alert("No hay rutas válidas para iniciar."); return; }
             // Sobrescribir 'routes' temporalmente o usar una variable separada? Mejor usar 'routes' pero filtrar al avanzar.

             currentRouteIndex = 0; // Empezar siempre desde la primera ruta válida
             // Encontrar la primera ruta con paradas
             while(currentRouteIndex < routes.length && (!routes[currentRouteIndex] || routes[currentRouteIndex].length === 0)) {
                  currentRouteIndex++;
             }
             if (currentRouteIndex >= routes.length) { alert("Error: No se encontraron rutas válidas."); return; } // No debería pasar por chequeo anterior

             currentStopIndex = 0;
             isManualMode = DOMElements.manualModeCheckbox.checked;
             currentStatusInfo = { phase: 'approaching_first', text: `Hacia ${routes[currentRouteIndex][0].name}` };
             console.log(`Iniciando seguimiento. Ruta ${currentRouteIndex + 1}, Hacia parada ${currentStopIndex + 1}. Modo Manual: ${isManualMode}`);
             renderStopsList(); updateUIBasedOnState(); updateStatusDisplayContent("idle", "Iniciando GPS...", "--:--");

             if (navigator.geolocation) {
                  const options = { enableHighAccuracy: true, timeout: 15000, maximumAge: 3000 };
                  watchId = navigator.geolocation.watchPosition(handleLocationUpdate, handleLocationError, options);
                  updateGPSStatus("Activado, buscando señal...");
             } else { alert("Geolocalización no soportada."); stopTracking("error_gps"); }
        }
        function stopTracking(reason = "detenido") { /* ... sin cambios ... */
             if (watchId) { navigator.geolocation.clearWatch(watchId); watchId = null; } const wasTracking = currentRouteIndex !== -1;
             currentRouteIndex = -1; currentStopIndex = -1; lastKnownPosition = null; isManualMode = false; DOMElements.manualModeCheckbox.checked = false;
             currentStatusInfo = { phase: 'idle', text: `Seguimiento ${reason}` };
             if (currentLocationMarker) { map.removeLayer(currentLocationMarker); currentLocationMarker = null; }
             let finalText = `Seguimiento ${reason}.`; if (reason === "completed") finalText = "¡Ruta(s) completada(s)!"; else if (reason === "error_gps") finalText = "Error: GPS no disponible."; else if (reason === "error_data") finalText = "Error en datos de ruta.";
             updateStatusDisplayContent("idle", finalText, "--:--"); updateGPSStatus("GPS desactivado."); if (wasTracking) renderStopsList(); updateUIBasedOnState(); console.log("Seguimiento detenido:", reason);
        }
        function handleLocationUpdate(position) { /* ... sin cambios en la lógica principal de cálculo, solo en la condición de avance automático ... */
            lastKnownPosition = position; const now = new Date(); const { latitude, longitude, accuracy } = position.coords; updateGPSStatus(`Activo | Precisión: ${accuracy.toFixed(0)}m`);
            const userLatLng = [latitude, longitude]; if (!currentLocationMarker) { currentLocationMarker = L.circleMarker(userLatLng, { radius: 7, fillColor: "#007bff", color: "#ffffff", weight: 2, opacity: 1, fillOpacity: 0.9 }).addTo(map).bindPopup("Ubicación actual"); } else { currentLocationMarker.setLatLng(userLatLng); }
            if (currentRouteIndex === -1) { /* ya detenido */ return; } // Salir si ya no está activo
            if (currentRouteIndex >= routes.length || !routes[currentRouteIndex] || routes[currentRouteIndex].length === 0) { console.warn("handleLocationUpdate sin ruta activa válida."); stopTracking("estado inválido"); return; }
            const currentRoute = routes[currentRouteIndex];
            if (currentStopIndex < 0 || currentStopIndex >= currentRoute.length) { console.warn("handleLocationUpdate sin parada destino válida."); stopTracking("estado inválido"); return; }
            const nextStop = currentRoute[currentStopIndex]; const previousStop = (currentStopIndex > 0) ? currentRoute[currentStopIndex - 1] : null;
            let timeDifferenceMs = 0; let statusText = ""; let calculationPhase = "idle";
            const distanceToNextStopM = calculateDistance(latitude, longitude, nextStop.lat, nextStop.lng) * 1000;
            let distanceToPreviousStopM = Infinity; if (previousStop) { distanceToPreviousStopM = calculateDistance(latitude, longitude, previousStop.lat, previousStop.lng) * 1000; }
            // --- Determinar Fase y Calcular Diferencia (sin cambios) ---
            if (previousStop && distanceToPreviousStopM < ARRIVAL_THRESHOLD_METERS) { calculationPhase = 'at_stop'; statusText = `En ${previousStop.name}, Sal: ${previousStop.departureTime}`; const schedDep = parseTimeString(previousStop.departureTime); if (schedDep) { timeDifferenceMs = now.getTime() - schedDep.getTime(); } }
            else if (!previousStop) { calculationPhase = 'approaching_first'; statusText = `Hacia ${nextStop.name}`; const schedArr = parseTimeString(nextStop.time); if (schedArr) { timeDifferenceMs = now.getTime() - schedArr.getTime(); } }
            else { calculationPhase = 'en_route'; statusText = `Hacia ${nextStop.name}`; const schedDepPrev = parseTimeString(previousStop.departureTime); const schedArrNext = parseTimeString(nextStop.time); if (schedDepPrev && schedArrNext && schedArrNext > schedDepPrev) { const schedSegDur = schedArrNext.getTime() - schedDepPrev.getTime(); const totSegDist = calculateDistance(previousStop.lat, previousStop.lng, nextStop.lat, nextStop.lng); let distTrav = calculateDistance(previousStop.lat, previousStop.lng, latitude, longitude); let ratio = 0; if (totSegDist > 0.001) { distTrav = Math.max(0, Math.min(distTrav, totSegDist)); ratio = distTrav / totSegDist; } else if (distTrav > 0) { ratio = 1; } const schedTElapsed = ratio * schedSegDur; const actTElapsed = now.getTime() - schedDepPrev.getTime(); timeDifferenceMs = actTElapsed - schedTElapsed; } }
            currentStatusInfo = { phase: calculationPhase, text: statusText }; updateStatusDisplayWithDifference(timeDifferenceMs, currentStatusInfo);
            // --- Lógica de AVANCE AUTOMÁTICO (Modificada) ---
            if (!isManualMode && distanceToNextStopM < ARRIVAL_THRESHOLD_METERS) { console.log(`(Auto) Llegada detectada a ${nextStop.name}. Avanzando...`); advanceStopOrRoute(); }
        }

        // --- Funciones Avance Parada/Ruta (advanceStopOrRoute, advanceRoute) ---
        // (Sin cambios funcionales mayores, solo ajusta el índice de ruta para saltar vacías)
        function advanceStopOrRoute() {
             if (currentRouteIndex === -1) return; // Check por si acaso
             const currentRoute = routes[currentRouteIndex];
             if (!currentRoute || currentStopIndex >= currentRoute.length) { console.error("advanceStopOrRoute: Estado inválido."); return; }
             const arrivedStop = currentRoute[currentStopIndex];
             if (stopMarkers[arrivedStop.id]) { stopMarkers[arrivedStop.id].setOpacity(0.6); }
             if (arrivalMarker) map.removeLayer(arrivalMarker);
             arrivalMarker = L.circleMarker([arrivedStop.lat, arrivedStop.lng], { radius: 10, color: '#2ECC40', fillColor: '#2ECC40', fillOpacity: 0.4, weight: 1 }).addTo(map);
             setTimeout(() => { if (arrivalMarker && map.hasLayer(arrivalMarker)) map.removeLayer(arrivalMarker); arrivalMarker = null; }, 2000);
             currentStopIndex++;
             if (currentStopIndex >= currentRoute.length) { console.log(`Fin de Ruta ${currentRouteIndex + 1}. Buscando siguiente...`); advanceRoute(); }
             else {
                 const nextUpcomingStop = currentRoute[currentStopIndex];
                 console.log(`Avanzando. Próxima parada: ${currentStopIndex + 1} (${nextUpcomingStop.name})`);
                 currentStatusInfo = { phase: 'at_stop', text: `En ${arrivedStop.name}, Salida: ${arrivedStop.departureTime}` };
                 updateStatusDisplayContent('idle', currentStatusInfo.text + "<br>Calculando...", "--:--");
                 renderStopsList(); updateUIBasedOnState();
             }
        }
        function advanceRoute() {
              let nextValidRouteIndex = currentRouteIndex + 1;
              // Buscar la siguiente ruta que NO esté vacía
              while (nextValidRouteIndex < routes.length && (!routes[nextValidRouteIndex] || routes[nextValidRouteIndex].length === 0)) {
                   nextValidRouteIndex++;
              }

              if (nextValidRouteIndex >= routes.length) { // No hay más rutas válidas
                  console.log("¡Todas las rutas completadas!"); stopTracking("completed");
              } else { // Encontró una ruta válida siguiente
                  currentRouteIndex = nextValidRouteIndex;
                  currentStopIndex = 0;
                  const firstStopNextRoute = routes[currentRouteIndex][currentStopIndex];
                  console.log(`Cambiando a Ruta ${currentRouteIndex + 1}. Próxima: ${firstStopNextRoute.name}`);
                  currentStatusInfo = { phase: 'approaching_first', text: `Iniciando Ruta ${currentRouteIndex + 1}: Hacia ${firstStopNextRoute.name}` };
                  updateStatusDisplayContent('idle', currentStatusInfo.text + "<br>Calculando...", "--:--");
                  renderStopsList(); updateUIBasedOnState();
              }
         }

        // --- Error GPS, Display Status, Utilidades (calculateDistance, deg2rad, parseTimeString) ---
        // (Sin cambios respecto a la versión anterior)
        function handleLocationError(error) { console.warn("Error GPS:", error); let message = "Error GPS: "; let shouldStop = false; switch(error.code) { case error.PERMISSION_DENIED: message += "Permiso denegado."; shouldStop = true; break; case error.POSITION_UNAVAILABLE: message += "Señal no disponible."; break; case error.TIMEOUT: message += "Timeout."; break; default: message += "Desconocido."; break; } updateGPSStatus(message); if (shouldStop) { stopTracking("error_gps"); } }
        function updateStatusDisplayWithDifference(differenceMs, statusInfo) { const totalSecondsRaw = differenceMs / 1000; const absoluteTotalSeconds = Math.abs(totalSecondsRaw); const minutes = Math.floor(absoluteTotalSeconds / 60); const seconds = Math.floor(absoluteTotalSeconds % 60); const formattedMagnitude = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; let timeString; let statusClass; if (differenceMs >= 0) { timeString = `-${formattedMagnitude}`; if (differenceMs <= ON_TIME_THRESHOLD_SECONDS * 1000) { statusClass = "on-time"; } else { statusClass = "late"; } } else { timeString = `+${formattedMagnitude}`; if (Math.abs(differenceMs) <= ON_TIME_THRESHOLD_SECONDS * 1000) { statusClass = "on-time"; } else { statusClass = "early"; } } if (differenceMs === 0) { timeString = "-00:00"; statusClass = "on-time"; } updateStatusDisplayContent(statusClass, statusInfo.text, timeString); }
        function updateStatusDisplayContent(className, infoText, timeText) { DOMElements.statusDisplay.className = `status-display ${className}`; if (DOMElements.statusInfoSpan) DOMElements.statusInfoSpan.innerHTML = infoText; if (DOMElements.statusTimeSpan) DOMElements.statusTimeSpan.textContent = timeText; }
        function updateGPSStatus(text) { DOMElements.gpsStatus.textContent = `GPS: ${text}`; }
        function calculateDistance(lat1, lon1, lat2, lon2) { if (lat1 == lat2 && lon1 == lon2) return 0; const dLat = deg2rad(lat2 - lat1); const dLon = deg2rad(lon2 - lon1); const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2); const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c; }
        function deg2rad(deg) { return deg * (Math.PI / 180); }
        function parseTimeString(timeString) { try { if (!timeString || typeof timeString !== 'string' || !timeString.includes(':')) return null; const [hours, minutes] = timeString.split(':').map(Number); if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) return null; const date = new Date(); date.setHours(hours, minutes, 0, 0); return date; } catch (e) { console.error("Error parsing time:", timeString, e); return null; } }
        function removeAllStopMarkers() { for (const id in stopMarkers) { if (map.hasLayer(stopMarkers[id])) { map.removeLayer(stopMarkers[id]); } } stopMarkers = {}; }


    </script>

</body>
</html>
