<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            overflow: hidden; /* Prevent body scroll */
            display: flex;
            flex-direction: column;
        }

        #map {
            height: 50vh; /* 50% of viewport height */
            width: 100%;
            background-color: #333; /* Placeholder color */
        }

        #controls {
            height: 50vh; /* 50% of viewport height */
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .control-section:last-child {
            border-bottom: none;
        }

        h2, h3 {
            color: #FFFFFF;
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="text"], input[type="datetime-local"], select {
            width: calc(100% - 12px);
            padding: 8px;
            margin-bottom: 10px;
            background-color: #222;
            color: #FFF;
            border: 1px solid #555;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        button:hover {
            background-color: #45a049;
        }
        button.danger {
            background-color: #f44336;
        }
        button.danger:hover {
            background-color: #da190b;
        }
        button.secondary {
            background-color: #007bff;
        }
        button.secondary:hover {
            background-color: #0056b3;
        }


        #statusDisplay {
            text-align: center;
            padding: 10px;
        }
        #timeDeviation {
            font-size: 3em; /* Larger font for time deviation */
            font-weight: bold;
            margin: 10px 0;
        }
        #speedDisplay, #nextStopDisplay {
            font-size: 1.2em;
            margin: 5px 0;
        }

        .stop-item {
            background-color: #1e1e1e;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .stop-item.next-stop-highlight {
            background-color: #007bff;
            font-weight: bold;
        }

        .leaflet-div-icon {
            background: transparent;
            border: none;
            text-align: center;
            font-weight: bold;
            color: white;
        }

        .custom-marker-content {
            padding: 5px 8px;
            border-radius: 50%;
            color: white;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid white;
        }
        
        .user-location-icon {
            background-color: #007bff !important; /* Blue dot */
            border-radius: 50%;
            width: 16px !important;
            height: 16px !important;
            border: 2px solid white;
            box-shadow: 0 0 0 2px #007bff;
        }
    </style>
</head>
<body>

    <div id="map"></div>
    <div id="controls">
        <div id="statusDisplay" style="display: none;">
            <div id="timeDeviation">00:00</div>
            <div id="speedDisplay">Velocidad: 0 KM/H</div>
            <div id="nextStopDisplay">Próxima Parada: N/A</div>
        </div>

        <div class="control-section" id="routeCreationSection">
            <h3>Crear/Modificar Ruta</h3>
            <p style="font-size: 0.8em;">Toca el mapa para agregar paradas: Inicio -> Fin -> Intermedias.</p>
            <label for="pointName">Nombre Parada:</label>
            <input type="text" id="pointName" placeholder="Ej: Estación Central">
            
            <label for="pointTime">Horario Programado (DD/MM/AAAA HH:MM):</label>
            <input type="datetime-local" id="pointTime">

            <input type="checkbox" id="autoCalcTimes" checked>
            <label for="autoCalcTimes" style="display:inline;">Calcular horarios intermedios automáticamente</label>
            <br><br>
            <button onclick="clearCurrentRoute()">Limpiar Ruta Actual</button>
        </div>

        <div class="control-section">
            <h3>Lista de Paradas</h3>
            <div id="stopsList">No hay paradas.</div>
        </div>
        
        <div class="control-section">
            <h3>Guardar/Cargar Rutas</h3>
            <label for="routeName">Nombre para Guardar Ruta:</label>
            <input type="text" id="routeName" placeholder="Ej: Ruta Mañana Lunes">
            <button onclick="saveRoute()">Guardar Ruta</button>
            <br><br>
            <label for="savedRoutes">Cargar Ruta:</label>
            <select id="savedRoutes"></select>
            <button onclick="loadRoute()">Cargar</button>
            <button onclick="deleteRoute()" class="danger">Borrar Seleccionada</button>
        </div>

        <div class="control-section">
            <h3>Seguimiento</h3>
            <button id="startTrackingBtn" onclick="startTracking()">Iniciar Seguimiento</button>
            <button id="stopTrackingBtn" onclick="stopTracking()" class="danger" style="display:none;">Detener Seguimiento</button>
            <br>
            <input type="checkbox" id="manualStopNav">
            <label for="manualStopNav" style="display:inline;">Navegación Manual de Paradas</label>
            <button id="prevStopBtn" onclick="goToPreviousStop()" style="display:none;">Anterior</button>
            <button id="nextStopBtn" onclick="goToNextStop()" style="display:none;">Siguiente</button>
        </div>
        
        <div class="control-section">
            <h3>Cola de Rutas</h3>
            <label for="routeToQueue">Añadir ruta guardada a la cola:</label>
            <select id="routeToQueue"></select>
            <button onclick="addRouteToQueue()">Añadir a Cola</button>
            <h4>En Cola:</h4>
            <div id="routeQueueDisplay">Vacía.</div>
            <button onclick="clearRouteQueue()">Limpiar Cola</button>
        </div>

    </div>

    <script>
        let map;
        let routePoints = []; // {lat, lng, name, type, scheduledTime, marker, originalIndex}
        let routeLine;
        let userMarker;
        let trackingIntervalId;
        let isTracking = false;
        let currentSegmentStartIndex = 0; // Index in routePoints for the start of the current segment
        let lastKnownPosition = null;

        const CACHE_PREFIX = 'smartMovePro_route_';
        const ROUTE_QUEUE_CACHE_KEY = 'smartMovePro_routeQueue';

        // --- Leaflet Icon Helpers ---
        function createDivIcon(text, bgColor = null, type = '') {
            let randomColor = bgColor || `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;
            if (type === 'start') randomColor = bgColor || `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;
            else if (type === 'end') randomColor = bgColor || `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;
            else if (type === 'intermediate') randomColor = bgColor || `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;
            
            // Use specific colors if desired, or keep random
            if (type === 'start' && !bgColor) randomColor = '#4CAF50'; // Green for Start
            if (type === 'end' && !bgColor) randomColor = '#f44336';   // Red for End
            if (type === 'intermediate' && !bgColor) randomColor = '#2196F3'; // Blue for Intermediate

            return L.divIcon({
                className: 'leaflet-div-icon',
                html: `<div style="background-color:${randomColor}; padding: 5px 8px; border-radius: 50%; color: white; font-size:14px; font-weight:bold; border: 1px solid white;">${text}</div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });
        }

        function createUserLocationIcon() {
            return L.divIcon({
                className: 'user-location-icon',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        // --- Map Initialization ---
        function initMap() {
            map = L.map('map').setView([-34.6037, -58.3816], 13); // Default to Buenos Aires
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            map.on('click', onMapClick);

            // Attempt to get user's current location to center map
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    map.setView([position.coords.latitude, position.coords.longitude], 13);
                }, () => {
                    console.warn("Error getting current location. Using default.");
                });
            }
        }

        // --- Route Creation Logic ---
        function onMapClick(e) {
            if (isTracking) {
                alert("Detén el seguimiento para modificar la ruta.");
                return;
            }

            const nameInput = document.getElementById('pointName');
            const timeInput = document.getElementById('pointTime');
            const latlng = e.latlng;

            let type;
            let requiredTime = true;
            let pointText;

            if (routePoints.length === 0) {
                type = 'start';
                pointText = 'I';
                if (!nameInput.value) nameInput.value = "Inicio";
            } else if (routePoints.length === 1 || (routePoints.length > 1 && routePoints.find(p => p.type === 'end'))) {
                // Adding intermediate points if end exists, or if only start exists (meaning next is end)
                // To add intermediate, user must first define start and end.
                // Let's adjust: first two points are start and end. Subsequent are intermediate.
                const endPointIndex = routePoints.findIndex(p => p.type === 'end');
                if (endPointIndex !== -1) { // End point exists, add intermediate before it
                    type = 'intermediate';
                    pointText = routePoints.filter(p=>p.type === 'intermediate').length + 1;
                     if (!nameInput.value) nameInput.value = `Parada ${pointText}`;
                    requiredTime = false; // Optional for intermediate
                } else { // No end point yet, this is the end point
                    type = 'end';
                    pointText = 'F';
                    if (!nameInput.value) nameInput.value = "Final";
                }
            } else { // This case should be for adding intermediate after start, before end is explicitly set
                 alert("Define el punto Final antes de agregar paradas intermedias, o mueve el punto Final si ya existe.");
                 return; // Simplified logic: Start -> End -> Intermediates
            }


            if (requiredTime && !timeInput.value) {
                alert(`El horario es obligatorio para el punto de ${type === 'start' ? 'Inicio' : 'Fin'}.`);
                return;
            }

            const scheduledTime = timeInput.value ? new Date(timeInput.value) : null;
            if (requiredTime && scheduledTime && isNaN(scheduledTime.getTime())) {
                alert("Formato de fecha/hora inválido.");
                return;
            }
            
            // If adding intermediate and end exists, insert before end.
            let insertionIndex = routePoints.length;
            if (type === 'intermediate') {
                const endIdx = routePoints.findIndex(p => p.type === 'end');
                if (endIdx !== -1) insertionIndex = endIdx;
            }


            const newPoint = {
                lat: latlng.lat,
                lng: latlng.lng,
                name: nameInput.value || `Punto ${routePoints.length + 1}`,
                type: type,
                scheduledTime: scheduledTime,
                marker: L.marker(latlng, { 
                    icon: createDivIcon(pointText, null, type), 
                    draggable: true 
                }).addTo(map),
                originalIndex: routePoints.length // To help re-number intermediates if one is dragged
            };

            newPoint.marker.on('dragend', function(event) {
                if (isTracking) {
                    event.target.setLatLng(L.latLng(newPoint.lat, newPoint.lng)); // Prevent dragging during tracking
                    alert("Detén el seguimiento para modificar la ruta.");
                    return;
                }
                const marker = event.target;
                const position = marker.getLatLng();
                const point = routePoints.find(p => p.marker === marker);
                if (point) {
                    point.lat = position.lat;
                    point.lng = position.lng;
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) {
                        calculateAndApplyIntermediateTimes();
                    }
                    updateStopsList();
                }
            });
            
            if (type === 'intermediate') {
                routePoints.splice(insertionIndex, 0, newPoint);
                // Re-number intermediate markers if one was inserted
                let intermediateCounter = 1;
                routePoints.forEach(p => {
                    if (p.type === 'intermediate') {
                        p.marker.setIcon(createDivIcon(intermediateCounter++, null, 'intermediate'));
                    }
                });
            } else {
                 routePoints.push(newPoint);
            }


            // Clear inputs for next point
            nameInput.value = "";
            // timeInput.value = ""; // Don't clear time, user might want sequential times

            if (document.getElementById('autoCalcTimes').checked) {
                calculateAndApplyIntermediateTimes();
            }
            redrawRouteLine();
            updateStopsList();
        }

        function calculateAndApplyIntermediateTimes() {
            const startPoint = routePoints.find(p => p.type === 'start');
            const endPoint = routePoints.find(p => p.type === 'end');

            if (!startPoint || !endPoint || !startPoint.scheduledTime || !endPoint.scheduledTime) {
                // console.log("Inicio o Fin sin horario para cálculo automático.");
                return;
            }

            const intermediatePoints = routePoints.filter(p => p.type === 'intermediate');
            if (intermediatePoints.length === 0) return;

            const totalDurationMillis = endPoint.scheduledTime.getTime() - startPoint.scheduledTime.getTime();
            if (totalDurationMillis <= 0) {
                console.warn("Duración total no positiva, no se pueden calcular tiempos intermedios.");
                return;
            }
            
            // Calculate total distance considering all points in order
            let totalRouteDistance = 0;
            let currentPath = [startPoint, ...intermediatePoints, endPoint];
            for (let i = 0; i < currentPath.length - 1; i++) {
                totalRouteDistance += L.latLng(currentPath[i].lat, currentPath[i].lng)
                                    .distanceTo(L.latLng(currentPath[i+1].lat, currentPath[i+1].lng));
            }

            if (totalRouteDistance === 0) return; // Avoid division by zero

            let accumulatedDistance = 0;
            let lastTimePoint = startPoint;

            intermediatePoints.forEach((point, index) => {
                // Distance from lastTimePoint (start or previous intermediate) to current intermediate point
                let segmentDistance = 0;
                let segmentPath = [];
                if (index === 0) { // First intermediate, path from start
                    segmentPath = [startPoint, point];
                } else { // Path from previous intermediate
                    segmentPath = [intermediatePoints[index-1], point];
                }
                segmentDistance = L.latLng(segmentPath[0].lat, segmentPath[0].lng)
                                .distanceTo(L.latLng(segmentPath[1].lat, segmentPath[1].lng));
                
                accumulatedDistance += segmentDistance;
                const proportionOfRoute = accumulatedDistance / totalRouteDistance;
                const timeOffsetMillis = totalDurationMillis * proportionOfRoute;
                
                point.scheduledTime = new Date(startPoint.scheduledTime.getTime() + timeOffsetMillis);
                lastTimePoint = point; 
            });
            updateStopsList();
        }
        
        function clearCurrentRoute() {
            routePoints.forEach(p => map.removeLayer(p.marker));
            routePoints = [];
            if (routeLine) map.removeLayer(routeLine);
            routeLine = null;
            document.getElementById('pointName').value = "";
            document.getElementById('pointTime').value = "";
            updateStopsList();
            console.log("Ruta actual limpiada.");
        }

        function redrawRouteLine() {
            if (routeLine) {
                map.removeLayer(routeLine);
            }
            if (routePoints.length > 1) {
                // Ensure points are in logical order: start, intermediates, end
                const sortedPoints = [];
                const start = routePoints.find(p => p.type === 'start');
                const end = routePoints.find(p => p.type === 'end');
                const intermediates = routePoints.filter(p => p.type === 'intermediate')
                                        .sort((a,b) => a.originalIndex - b.originalIndex); // Maintain insertion order

                if (start) sortedPoints.push(start);
                sortedPoints.push(...intermediates);
                if (end) sortedPoints.push(end);
                
                const latlngs = sortedPoints.map(p => [p.lat, p.lng]);
                routeLine = L.polyline(latlngs, {color: 'blue'}).addTo(map);
            }
        }

        function formatTime(date) {
            if (!date || isNaN(date.getTime())) return "N/A";
            return date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }) + 
                   ` (${date.toLocaleDateString('es-ES')})`;
        }
        
        function updateStopsList() {
            const listDiv = document.getElementById('stopsList');
            if (routePoints.length === 0) {
                listDiv.innerHTML = "No hay paradas.";
                return;
            }

            // Sort points for display: Start, Intermediates (by originalIndex), End
            const displayOrderPoints = [];
            const start = routePoints.find(p => p.type === 'start');
            const end = routePoints.find(p => p.type === 'end');
            const intermediates = routePoints.filter(p => p.type === 'intermediate')
                                    .sort((a,b) => a.originalIndex - b.originalIndex); 
                                    // Sorting by originalIndex might not be perfect if items are added out of geographical sequence
                                    // but it's a start for now. A better sort would be by scheduledTime if all available.
                                    // Or, simply maintain the order they are in routePoints after insertions.

            let currentDisplayPoints = [];
            if(start) currentDisplayPoints.push(start);
            
            // Re-sort intermediates based on their actual position between start and end if they exist
            // For simplicity, we'll assume routePoints is already in a somewhat logical order
            // due to the insertion logic.
            currentDisplayPoints.push(...routePoints.filter(p => p.type === 'intermediate'));

            if(end && currentDisplayPoints.indexOf(end) === -1) currentDisplayPoints.push(end);


            let html = "<ul>";
            currentDisplayPoints.forEach((p, index) => {
                let typeText = "";
                switch(p.type) {
                    case 'start': typeText = "Inicio"; break;
                    case 'intermediate': 
                        // Find its true intermediate index
                        let intermediateVisualIndex = currentDisplayPoints.filter(pt => pt.type === 'intermediate' && currentDisplayPoints.indexOf(pt) <= index).length;
                        typeText = `Intermedia ${intermediateVisualIndex}`; 
                        break;
                    case 'end': typeText = "Fin"; break;
                }
                const timeStr = p.scheduledTime ? formatTime(new Date(p.scheduledTime)) : "Sin horario";
                const itemClass = (isTracking && index === currentSegmentStartIndex + 1) ? "stop-item next-stop-highlight" : "stop-item";
                html += `<li class="${itemClass}"><b>${p.name}</b> (${typeText}) - ${timeStr}</li>`;
            });
            html += "</ul>";
            listDiv.innerHTML = html;
        }

        // --- Persistence (localStorage) ---
        function saveRoute() {
            const routeNameInput = document.getElementById('routeName');
            if (!routeNameInput.value) {
                alert("Por favor, ingresa un nombre para la ruta.");
                return;
            }
            if (routePoints.length < 2) {
                alert("Una ruta debe tener al menos un punto de inicio y fin.");
                return;
            }
            // Sanitize routePoints for saving (remove Leaflet marker objects)
            const savablePoints = routePoints.map(p => ({
                lat: p.lat, lng: p.lng, name: p.name, type: p.type, 
                scheduledTime: p.scheduledTime ? p.scheduledTime.toISOString() : null,
                originalIndex: p.originalIndex
            }));

            localStorage.setItem(CACHE_PREFIX + routeNameInput.value, JSON.stringify(savablePoints));
            alert(`Ruta "${routeNameInput.value}" guardada.`);
            loadSavedRoutesLists();
            routeNameInput.value = ""; // Clear after saving
        }

        function loadRoute() {
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) {
                alert("Selecciona una ruta para cargar.");
                return;
            }
            const savedData = localStorage.getItem(CACHE_PREFIX + selectedRouteName);
            if (!savedData) {
                alert("Error al cargar la ruta.");
                return;
            }

            clearCurrentRoute(); // Clear existing route from map and memory
            const loadedPoints = JSON.parse(savedData);
            
            loadedPoints.forEach((p_data, index) => {
                let pointText;
                 let intermediateCounter = 1;
                if (p_data.type === 'start') pointText = 'I';
                else if (p_data.type === 'end') pointText = 'F';
                else {
                    pointText = routePoints.filter(rp => rp.type === 'intermediate').length + 1;
                }


                const newPoint = {
                    ...p_data,
                    scheduledTime: p_data.scheduledTime ? new Date(p_data.scheduledTime) : null,
                    marker: L.marker([p_data.lat, p_data.lng], { 
                        icon: createDivIcon(pointText, null, p_data.type),
                        draggable: true 
                    }).addTo(map)
                };
                newPoint.marker.on('dragend', function(event){
                    if (isTracking) {
                        event.target.setLatLng(L.latLng(newPoint.lat, newPoint.lng));
                        return;
                    }
                    const marker = event.target;
                    const position = marker.getLatLng();
                    const point = routePoints.find(p => p.marker === marker);
                    if (point) {
                        point.lat = position.lat;
                        point.lng = position.lng;
                        redrawRouteLine();
                         if (document.getElementById('autoCalcTimes').checked) {
                            calculateAndApplyIntermediateTimes();
                        }
                        updateStopsList();
                    }
                });
                routePoints.push(newPoint);
            });

            redrawRouteLine();
            updateStopsList();
            map.fitBounds(routeLine.getBounds());
            document.getElementById('routeName').value = selectedRouteName; // Pre-fill for potential re-save
            alert(`Ruta "${selectedRouteName}" cargada.`);
        }

        function deleteRoute() {
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) {
                alert("Selecciona una ruta para borrar.");
                return;
            }
            if (confirm(`¿Estás seguro de que quieres borrar la ruta "${selectedRouteName}"?`)) {
                localStorage.removeItem(CACHE_PREFIX + selectedRouteName);
                // Also remove from queue if it's there
                let queue = getRouteQueue();
                queue = queue.filter(name => name !== selectedRouteName);
                saveRouteQueue(queue);

                loadSavedRoutesLists();
                alert(`Ruta "${selectedRouteName}" borrada.`);
            }
        }

        function loadSavedRoutesLists() { // Plural: for both dropdowns
            const savedRoutesSelect = document.getElementById('savedRoutes');
            const routeToQueueSelect = document.getElementById('routeToQueue');
            savedRoutesSelect.innerHTML = ""; // Clear existing options
            routeToQueueSelect.innerHTML = "";

            let hasRoutes = false;
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(CACHE_PREFIX)) {
                    const routeName = key.substring(CACHE_PREFIX.length);
                    const option = document.createElement('option');
                    option.value = routeName;
                    option.textContent = routeName;
                    savedRoutesSelect.appendChild(option.cloneNode(true));
                    routeToQueueSelect.appendChild(option);
                    hasRoutes = true;
                }
            }
            if (!hasRoutes) {
                 const option = document.createElement('option');
                 option.textContent = "No hay rutas guardadas";
                 option.disabled = true;
                 savedRoutesSelect.appendChild(option.cloneNode(true));
                 routeToQueueSelect.appendChild(option);
            }
            updateRouteQueueDisplay();
        }


        // --- Real-Time Tracking ---
        function startTracking() {
            if (routePoints.length < 2) {
                alert("Crea o carga una ruta con al menos inicio y fin para comenzar el seguimiento.");
                return;
            }
            if (!routePoints.find(p => p.type === 'start')?.scheduledTime || !routePoints.find(p => p.type === 'end')?.scheduledTime) {
                alert("La ruta debe tener horarios definidos para el inicio y el fin para el seguimiento.");
                return;
            }

            isTracking = true;
            currentSegmentStartIndex = 0; // Start from the first point (index 0) towards the second (index 1)
            document.getElementById('startTrackingBtn').style.display = 'none';
            document.getElementById('stopTrackingBtn').style.display = 'inline-block';
            document.getElementById('statusDisplay').style.display = 'block';
            document.getElementById('routeCreationSection').style.display = 'none'; // Hide creation tools

            // Sort routePoints for tracking: Start, Intermediates (by originalIndex or time), End
            // This ensures segments are processed in the intended travel order.
            const startPt = routePoints.find(p => p.type === 'start');
            const endPt = routePoints.find(p => p.type === 'end');
            const intermediatePts = routePoints.filter(p => p.type === 'intermediate')
                                        .sort((a, b) => (a.scheduledTime && b.scheduledTime) ? a.scheduledTime - b.scheduledTime : a.originalIndex - b.originalIndex);
            
            routePoints = [startPt, ...intermediatePts, endPt].filter(p => p); // Filter out undefined if start/end missing (though checked above)


            if (navigator.geolocation) {
                trackingIntervalId = navigator.geolocation.watchPosition(
                    handlePositionUpdate,
                    handleGeolocationError,
                    { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 }
                );
                map.setView(map.getCenter(), 16); // Zoom in a bit
                highlightNextStopInList();
            } else {
                alert("La geolocalización no está disponible en tu navegador.");
                stopTracking(); // Revert UI
            }
             updateManualNavButtons();
        }

        function stopTracking(completedNaturally = false) {
            if (trackingIntervalId) {
                navigator.geolocation.clearWatch(trackingIntervalId);
                trackingIntervalId = null;
            }
            isTracking = false;
            lastKnownPosition = null;
            document.getElementById('startTrackingBtn').style.display = 'inline-block';
            document.getElementById('stopTrackingBtn').style.display = 'none';
            document.getElementById('statusDisplay').style.display = 'none';
            document.getElementById('routeCreationSection').style.display = 'block'; // Show creation tools
            
            if (userMarker) {
                map.removeLayer(userMarker);
                userMarker = null;
            }
            document.getElementById('timeDeviation').textContent = "00:00";
            document.getElementById('timeDeviation').style.color = "#FFFFFF";
            document.getElementById('speedDisplay').textContent = "Velocidad: 0 KM/H";
            document.getElementById('nextStopDisplay').textContent = "Próxima Parada: N/A";
            
            currentSegmentStartIndex = 0; // Reset for next tracking session
            highlightNextStopInList(); // Will clear highlight or show first stop
            updateManualNavButtons();

            if (completedNaturally) {
                alert("Ruta completada!");
                checkRouteQueue();
            } else {
                console.log("Seguimiento detenido manualmente.");
            }
        }
        
        function updateManualNavButtons() {
            const manualNav = document.getElementById('manualStopNav').checked;
            const prevBtn = document.getElementById('prevStopBtn');
            const nextBtn = document.getElementById('nextStopBtn');

            if (isTracking && manualNav) {
                prevBtn.style.display = 'inline-block';
                nextBtn.style.display = 'inline-block';
                prevBtn.disabled = currentSegmentStartIndex === 0;
                nextBtn.disabled = currentSegmentStartIndex >= routePoints.length - 2;
            } else {
                prevBtn.style.display = 'none';
                nextBtn.style.display = 'none';
            }
        }

        document.getElementById('manualStopNav').addEventListener('change', updateManualNavButtons);


        function handlePositionUpdate(position) {
            lastKnownPosition = position;
            const { latitude, longitude, speed } = position.coords;
            const userLatLng = L.latLng(latitude, longitude);

            if (!userMarker) {
                userMarker = L.marker(userLatLng, { icon: createUserLocationIcon() }).addTo(map);
            } else {
                userMarker.setLatLng(userLatLng);
            }
            map.panTo(userLatLng); // Optionally keep user centered

            const speedKmh = speed ? (speed * 3.6).toFixed(1) : 0;
            document.getElementById('speedDisplay').textContent = `Velocidad: ${speedKmh} KM/H`;

            // Stop Detection & Advancement
            if (currentSegmentStartIndex < routePoints.length - 1) {
                const nextStop = routePoints[currentSegmentStartIndex + 1];
                const distanceToNextStop = userLatLng.distanceTo(L.latLng(nextStop.lat, nextStop.lng));
                
                const manualNav = document.getElementById('manualStopNav').checked;

                if (!manualNav) {
                    // Automatic detection logic
                    const detectionRadius = 50; // meters
                    if (distanceToNextStop < detectionRadius) {
                        advanceToNextStop();
                    } else {
                        // Check if user has significantly passed the next stop and is closer to a subsequent one
                        // This is a simple "skip" logic
                        if (currentSegmentStartIndex < routePoints.length - 2) {
                            const stopAfterNext = routePoints[currentSegmentStartIndex + 2];
                            const distanceToStopAfterNext = userLatLng.distanceTo(L.latLng(stopAfterNext.lat, stopAfterNext.lng));
                            if (distanceToStopAfterNext < distanceToNextStop && distanceToStopAfterNext < detectionRadius * 2) { // If closer to N+2 than N+1 and within a reasonable range
                                console.log(`Saltando ${nextStop.name}, más cerca de ${stopAfterNext.name}`);
                                advanceToNextStop(); // This will make currentSegmentStartIndex point to nextStop, then next call will check stopAfterNext
                                // Potentially call advanceToNextStop() again if needed, or refine logic
                            }
                        }
                    }
                }
                // Time Deviation Calculation (even if stop not reached yet)
                calculateTimeDeviation(position);
            } else { // Reached final destination or beyond
                // This state should ideally be caught by advanceToNextStop
                document.getElementById('nextStopDisplay').textContent = "Ruta Completada";
                document.getElementById('timeDeviation').textContent = "00:00"; // Or final deviation
                document.getElementById('timeDeviation').style.color = "#FFFFFF";

            }
        }

        function advanceToNextStop() {
            currentSegmentStartIndex++;
            if (currentSegmentStartIndex >= routePoints.length - 1) {
                // Reached or passed the destination
                stopTracking(true); // completedNaturally = true
            } else {
                highlightNextStopInList();
                updateManualNavButtons();
                // Immediately recalculate deviation for the new segment
                if (lastKnownPosition) calculateTimeDeviation(L.latLng(lastKnownPosition.coords.latitude, lastKnownPosition.coords.longitude));
            }
        }
        
        function goToPreviousStop() {
            if (currentSegmentStartIndex > 0) {
                currentSegmentStartIndex--;
                highlightNextStopInList();
                updateManualNavButtons();
                if (lastKnownPosition) calculateTimeDeviation(L.latLng(lastKnownPosition.coords.latitude, lastKnownPosition.coords.longitude));
            }
        }
        function goToNextStop() { // Manual next
             if (currentSegmentStartIndex < routePoints.length - 2) { // -2 because segment is between index and index+1
                advanceToNextStop(); // Use the same logic
            } else if (currentSegmentStartIndex === routePoints.length - 2) { // If at the segment before last
                advanceToNextStop(); // This will move to the last point and trigger route completion
            }
        }


        function highlightNextStopInList() {
            const stops = document.querySelectorAll('#stopsList .stop-item');
            stops.forEach(stop => stop.classList.remove('next-stop-highlight'));

            if (isTracking && currentSegmentStartIndex < routePoints.length - 1) {
                const nextStop = routePoints[currentSegmentStartIndex + 1];
                document.getElementById('nextStopDisplay').textContent = `Próxima: ${nextStop.name}`;
                
                // Find the corresponding list item to highlight
                // This is a bit tricky because the list is re-rendered. We need a stable way to identify.
                // For now, rely on the index mapping directly, assuming routePoints used for tracking is same as for list.
                 if(stops[currentSegmentStartIndex + 1]) {
                    stops[currentSegmentStartIndex + 1].classList.add('next-stop-highlight');
                 }

            } else if (!isTracking && routePoints.length > 0) {
                 document.getElementById('nextStopDisplay').textContent = `Próxima: ${routePoints[0].name}`;
                 if(stops[0]) stops[0].classList.add('next-stop-highlight'); // Highlight first stop if not tracking
            }
             else {
                document.getElementById('nextStopDisplay').textContent = "Próxima Parada: N/A";
            }
            updateStopsList(); // Re-render list to apply class based on currentSegmentStartIndex
        }

        function calculateTimeDeviation(currentUserGeoPosition) { // currentUserGeoPosition is the raw geolocation object
            if (currentSegmentStartIndex >= routePoints.length - 1) return; 

            const pointA = routePoints[currentSegmentStartIndex];
            const pointB = routePoints[currentSegmentStartIndex + 1];

            if (!pointA.scheduledTime || !pointB.scheduledTime) {
                document.getElementById('timeDeviation').textContent = "N/A";
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                return;
            }

            const scheduledTimeA = new Date(pointA.scheduledTime);
            const scheduledTimeB = new Date(pointB.scheduledTime);
            const segmentTotalScheduledMillis = scheduledTimeB.getTime() - scheduledTimeA.getTime();

            if (segmentTotalScheduledMillis <= 0) {
                 document.getElementById('timeDeviation').textContent = "ERR_DUR"; // Error Duration
                 document.getElementById('timeDeviation').style.color = "#FFA500"; 
                return;
            }

            const latLngA = L.latLng(pointA.lat, pointA.lng);
            const latLngB = L.latLng(pointB.lat, pointB.lng);
            const currentUserLatLng = L.latLng(currentUserGeoPosition.coords.latitude, currentUserGeoPosition.coords.longitude);

            const distanceTotalSegment = latLngA.distanceTo(latLngB); 
            
            if (distanceTotalSegment < 1) { // Segment too short, effectively at the point
                const now = new Date();
                // If very close to A or B, deviation is simply diff with that point's time
                // This logic could be refined, but for now, base on A.
                let deviationMillis;
                if (now.getTime() < scheduledTimeA.getTime()) { // Before start of segment
                    deviationMillis = scheduledTimeA.getTime() - now.getTime(); // Positive, ahead of A
                } else if (now.getTime() > scheduledTimeB.getTime()) { // After end of segment
                     deviationMillis = scheduledTimeB.getTime() - now.getTime(); // Negative, behind B
                } else { // Within scheduled time of the (zero-length) segment
                    // Consider "on time" or base on proximity to A's or B's time
                    deviationMillis = scheduledTimeA.getTime() - now.getTime(); 
                }
                displayDeviation(deviationMillis);
                return;
            }

            // More robust progress calculation using relative positions
            // This is a simplified geometric approach suitable for LatLng without full vector projection
            // It handles cases where the user might be "before" A or "after" B along the line.
            
            // Distances from current position to segment endpoints
            const distToA = currentUserLatLng.distanceTo(latLngA);
            const distToB = currentUserLatLng.distanceTo(latLngB);

            let progressPercentage;

            // Check if current position is (roughly) "beyond" B relative to A
            // If distToA > distanceTotalSegment AND distToB < distToA:
            // This means user is further from A than B is from A, and also closer to B than to A.
            // This implies user is likely past B or very close to B on the "far side" from A.
            if (distToA > distanceTotalSegment && distToB < distToA && (distToA > distToB + distanceTotalSegment - 10) ) { // -10 for some tolerance
                 progressPercentage = 1.0;
            }
            // Check if current position is (roughly) "before" A relative to B
            // If distToB > distanceTotalSegment AND distToA < distToB:
            // This means user is further from B than A is from B, and also closer to A than to B.
            // This implies user is likely before A or very close to A on the "far side" from B.
            else if (distToB > distanceTotalSegment && distToA < distToB && (distToB > distToA + distanceTotalSegment - 10) ) {
                 progressPercentage = 0.0;
            }
            else {
                // General case: Use the ratio of distances along the path A-Current-B.
                // This inherently handles being off the direct line segment AB.
                // If on segment AB, then distToA + distToB approx equals distanceTotalSegment.
                // progress = distToA / distanceTotalSegment would be fine.
                //
                // Using (distToA / (distToA + distToB)) for progress:
                // If at A: 0 / (0 + d_AB) = 0.
                // If at B: d_AB / (d_AB + 0) = 1.
                // If halfway on segment: (d_AB/2) / (d_AB/2 + d_AB/2) = 0.5. This is good.
                //
                // This provides a stable progress value even if slightly off-route.
                // However, it doesn't perfectly project onto the line segment AB if far off.
                // For true projection, vector math is needed. Let's use a robust clamping
                // of the original distance-from-A method, but first check if we are
                // clearly "outside" the segment along its line.

                // A common way to get projected progress 't':
                // Convert to a local 2D Cartesian system or use a library function if available.
                // Since we don't have that easily, we'll stick to a refined distance-based logic.
                // The critical case is being collinear but outside the segment.

                // Let's use an approach based on comparing sum of partial distances to total.
                // If (distToA + distToB) is very close to distanceTotalSegment, user is on or near the line.
                // In this case, progress = distToA / distanceTotalSegment is good.
                const sumDistances = distToA + distToB;
                if (Math.abs(sumDistances - distanceTotalSegment) < distanceTotalSegment * 0.1 || distanceTotalSegment < 200 ) { // If fairly collinear or short segment
                    // Closer to being on the line segment
                    // If distToA + distanceTotalSegment is very close to distToB, user is "before" A.
                    if (Math.abs(distToA + distanceTotalSegment - distToB) < 20 ) { // 20m tolerance
                         progressPercentage = 0;
                    } 
                    // If distToB + distanceTotalSegment is very close to distToA, user is "after" B.
                    else if (Math.abs(distToB + distanceTotalSegment - distToA) < 20 ) { // 20m tolerance
                         progressPercentage = 1;
                    }
                    else {
                         progressPercentage = distToA / distanceTotalSegment;
                    }
                } else {
                    // User is significantly off the direct line segment.
                    // Here, using distToA / distanceTotalSegment might be misleadingly large or small.
                    // A safer bet might be to use the ratio distToA / (distToA + distToB),
                    // which represents progress along the path A-Current-B.
                    progressPercentage = distToA / (distToA + distToB);
                }
            }

            // Clamp progress strictly between 0 and 1.
            progressPercentage = Math.max(0, Math.min(1, progressPercentage));

            const expectedTimeElapsedMillis = segmentTotalScheduledMillis * progressPercentage;
            const expectedTimeAtCurrentPosition = new Date(scheduledTimeA.getTime() + expectedTimeElapsedMillis);

            const currentTime = new Date();
            const deviationMillis = expectedTimeAtCurrentPosition.getTime() - currentTime.getTime(); 

            displayDeviation(deviationMillis);
        }

        function displayDeviation(deviationMillis) {
            const absMillis = Math.abs(deviationMillis);
            const seconds = Math.floor((absMillis / 1000) % 60);
            const minutes = Math.floor((absMillis / (1000 * 60)) % 60);
            // const hours = Math.floor((absMillis / (1000 * 60 * 60)) % 24); // Not showing hours for brevity

            const sign = deviationMillis >= 0 ? "+" : "-";
            // const formattedDeviation = `${sign}${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            const formattedDeviation = `${sign}${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;


            const deviationDiv = document.getElementById('timeDeviation');
            deviationDiv.textContent = formattedDeviation;
            if (deviationMillis === 0) {
                 deviationDiv.style.color = "#FFFFFF"; // White for on-time
            } else if (deviationMillis > 0) { // Adelantado
                deviationDiv.style.color = "#00FF00"; // Green
            } else { // Atrasado
                deviationDiv.style.color = "#FF0000"; // Red
            }
        }

        function handleGeolocationError(error) {
            console.error("Error de geolocalización: ", error);
            alert(`Error de geolocalización: ${error.message}. El seguimiento puede no funcionar.`);
            // Optionally stop tracking if critical
            // stopTracking(); 
        }

        // --- Route Queue Logic ---
        function getRouteQueue() {
            const storedQueue = localStorage.getItem(ROUTE_QUEUE_CACHE_KEY);
            return storedQueue ? JSON.parse(storedQueue) : [];
        }

        function saveRouteQueue(queue) {
            localStorage.setItem(ROUTE_QUEUE_CACHE_KEY, JSON.stringify(queue));
            updateRouteQueueDisplay();
        }

        function addRouteToQueue() {
            const selectedRouteName = document.getElementById('routeToQueue').value;
            if (!selectedRouteName || selectedRouteName === "No hay rutas guardadas") {
                alert("Selecciona una ruta válida para añadir a la cola.");
                return;
            }
            const queue = getRouteQueue();
            if (queue.includes(selectedRouteName)) {
                alert(`La ruta "${selectedRouteName}" ya está en la cola.`);
                return;
            }
            queue.push(selectedRouteName);
            saveRouteQueue(queue);
            alert(`Ruta "${selectedRouteName}" añadida a la cola.`);
        }

        function updateRouteQueueDisplay() {
            const queueDiv = document.getElementById('routeQueueDisplay');
            const queue = getRouteQueue();
            if (queue.length === 0) {
                queueDiv.innerHTML = "Vacía.";
            } else {
                let html = "<ol>";
                queue.forEach(routeName => {
                    html += `<li>${routeName}</li>`;
                });
                html += "</ol>";
                queueDiv.innerHTML = html;
            }
        }
        
        function clearRouteQueue() {
            if (confirm("¿Limpiar toda la cola de rutas?")) {
                 saveRouteQueue([]);
            }
        }

        function checkRouteQueue() {
            let queue = getRouteQueue();
            if (queue.length > 0) {
                const nextRouteName = queue.shift(); // Get and remove first route
                saveRouteQueue(queue); // Update stored queue

                if (confirm(`La ruta actual ha finalizado. ¿Iniciar la siguiente ruta en cola: "${nextRouteName}"?`)) {
                    document.getElementById('savedRoutes').value = nextRouteName; // Select it in the dropdown
                    loadRoute(); // Load it
                    // Small delay to ensure route is loaded before starting tracking
                    setTimeout(() => {
                        if (routePoints.length > 1) startTracking();
                        else alert("Error al cargar la siguiente ruta de la cola.")
                    }, 500);
                } else {
                    alert("Siguiente ruta de la cola no iniciada. Puedes iniciarla manualmente.");
                }
            } else {
                console.log("Cola de rutas vacía.");
            }
        }


        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadSavedRoutesLists(); // Load saved routes into dropdowns and queue display
            updateStopsList();
            updateManualNavButtons();

            // Center map on user if geolocation available
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => map.setView([position.coords.latitude, position.coords.longitude], 13),
                    () => console.warn("Could not get initial location.")
                );
            }
        });

    </script>
</body>
</html>
