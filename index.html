<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Move Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: Arial, sans-serif;
            background-color: #000000;
            color: #FFFFFF;
            overflow: hidden; /* Prevent body scroll */
            display: flex;
            flex-direction: column;
        }

        #map {
            height: 50vh; /* 50% of viewport height */
            width: 100%;
            background-color: #333; /* Placeholder color */
        }

        #controls {
            height: 50vh; /* 50% of viewport height */
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .control-section:last-child {
            border-bottom: none;
        }

        h2, h3 {
            color: #FFFFFF;
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="text"], input[type="datetime-local"], input[type="number"], select {
            width: calc(100% - 12px);
            padding: 8px;
            margin-bottom: 10px;
            background-color: #222;
            color: #FFF;
            border: 1px solid #555;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        button:hover {
            background-color: #45a049;
        }
        button.danger {
            background-color: #f44336;
        }
        button.danger:hover {
            background-color: #da190b;
        }
        button.secondary {
            background-color: #007bff;
        }
        button.secondary:hover {
            background-color: #0056b3;
        }
        button.info {
            background-color: #17a2b8;
        }
        button.info:hover {
            background-color: #117a8b;
        }
        button.active-mode-button {
            background-color: #ff9800; /* Orange to show it's active */
            color: black;
            font-weight: bold;
        }
        button.active-mode-button:hover {
            background-color: #e68a00;
        }


        #statusDisplay {
            text-align: center;
            padding: 10px;
        }
        #timeDeviation {
            font-size: 3em; /* Larger font for time deviation */
            font-weight: bold;
            margin: 10px 0;
        }
        #trackingInfoDisplay, #speedDisplay, #nextStopDisplay {
            font-size: 1.2em;
            margin: 5px 0;
        }

        .stop-item {
            background-color: #1e1e1e;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9em;
            cursor: pointer;
        }
        .stop-item:hover {
            background-color: #2f2f2f;
        }
        .stop-item.next-stop-highlight {
            background-color: #007bff;
            font-weight: bold;
        }
        .stop-item.line-endpoint-highlight {
            border-left: 3px solid #ffc107; /* Yellow border for line endpoints */
        }


        .leaflet-div-icon {
            background: transparent;
            border: none;
            text-align: center;
            font-weight: bold;
            color: white;
        }
        .waypoint-marker-icon { 
            background-color:#888888 !important; 
            width: 10px !important; 
            height: 10px !important; 
            border-radius: 50% !important; 
            border: 1px solid #FFFFFF !important; 
            box-sizing: border-box !important;
        }


        .user-location-icon {
            background-color: #007bff !important; /* Blue dot */
            border-radius: 50%;
            width: 16px !important;
            height: 16px !important;
            border: 2px solid white;
            box-shadow: 0 0 0 2px #007bff;
        }
    </style>
</head>
<body>

    <div id="map"></div>
    <div id="controls">
        <div id="statusDisplay" style="display: none;">
            <div id="trackingInfoDisplay">Vuelta: 1/1 - Bandera: IDA</div>
            <div id="timeDeviation">00:00</div>
            <div id="speedDisplay">Velocidad: 0 KM/H</div>
            <div id="nextStopDisplay">Próxima Parada: N/A</div>
        </div>

        <div class="control-section" id="routeCreationSection">
            <h3>Crear/Modificar Ruta</h3>
            <p style="font-size: 0.8em;">
                Utiliza los botones de modo para gestionar la ruta. Para añadir puntos (Paso, Parada, Punta de Línea), activa el modo correspondiente y luego toca el mapa.
                Para editar un punto existente, tócalo directamente en el mapa. El modo "Editar Horarios" prioriza la edición de tiempos al seleccionar un punto.
                Usa "Vista Trazado" para cambiar entre la visualización de la bandera IDA (azul) y VUELTA (roja).
            </p>
            <div id="editModeSelection" style="margin-bottom:10px; display: flex; flex-wrap: wrap;">
                <button onclick="setActiveMode('flagConfig')" id="modeFlagConfigBtn" class="secondary" style="margin-right:5px; margin-bottom:5px;">Editar Bandera</button>
                <button onclick="setActiveMode('waypoint')" id="modeWaypointBtn" class="info" style="margin-right:5px; margin-bottom:5px;">+Pto. Paso</button>
                <button onclick="setActiveMode('intermediateStop')" id="modeIntermediateStopBtn" class="info" style="margin-right:5px; margin-bottom:5px;">+Parada Inter.</button>
                <button onclick="setActiveMode('lineEndpoint')" id="modeLineEndpointBtn" class="info" style="margin-right:5px; margin-bottom:5px;">+Punta Línea</button>
                <button onclick="setActiveMode('schedule')" id="modeScheduleBtn" class="secondary" style="margin-right:5px; margin-bottom:5px;">Editar Horarios</button>
                <button onclick="toggleEditingFlagView()" id="toggleEditingFlagViewBtn" class="secondary" style="margin-right:5px; margin-bottom:5px;">Vista Trazado: IDA</button>
                <button onclick="setActiveMode(null)" id="modeCancelBtn" class="danger" style="display:none; margin-bottom:5px;">X Cancelar Modo</button>
            </div>
            <p id="activeModeStatus" style="font-size: 0.8em; color: #17a2b8; margin-top:0; min-height: 1.2em;"></p>
            
            <label for="pointName">Nombre Punto:</label>
            <input type="text" id="pointName" placeholder="Ej: Terminal Norte">
            
            <div id="lineEndpointTimes" style="display:none;">
                <label for="pointScheduledDepartureTime">Horario Salida Programado (de esta Punta de Línea):</label>
                <input type="datetime-local" id="pointScheduledDepartureTime">
                <label for="pointScheduledArrivalTime">Horario Llegada Programado (a esta Punta de Línea):</label>
                <input type="datetime-local" id="pointScheduledArrivalTime">
                <small style="font-size: 0.7em; display: block; margin-bottom: 5px;">
                    <b>1ra Punta de Línea (P1):</b> Salida inicia IDA, Llegada termina VUELTA.<br>
                    <b>2da Punta de Línea (P2):</b> Llegada termina IDA, Salida inicia VUELTA.
                </small>
            </div>
            <div id="intermediateStopTime" style="display:none;">
                <label for="pointScheduledTimeIntermediate">Horario Programado (Parada Intermedia en IDA):</label>
                <input type="datetime-local" id="pointScheduledTimeIntermediate">
                <small style="font-size: 0.7em; display: block; margin-bottom: 5px;">
                    El horario para VUELTA se calculará automáticamente si la opción está activa y la ruta es un simple ida y vuelta. Para rutas con caminos de vuelta distintos, configurar P2 y los puntos siguientes.
                </small>
            </div>

            <div id="editPointControls" style="display:none; margin-top:10px;">
                <button onclick="updateSelectedPoint()" class="secondary">Actualizar Punto</button>
                <button onclick="deleteSelectedPoint()" class="danger">Borrar Punto Seleccionado</button>
                <button onclick="cancelEdit()">Cancelar Edición</button>
            </div>
            <hr style="margin: 15px 0;">
            <input type="checkbox" id="autoCalcTimes" checked onchange="calculateAndApplyAllIntermediateTimes()">
            <label for="autoCalcTimes" style="display:inline;">Calcular horarios intermedios automáticamente (para IDA y VUELTA, si aplica)</label>
            <br><br>
            <button onclick="clearCurrentRoute()">Limpiar Ruta Actual</button>
        </div>
        
        <div class="control-section" id="routeSettingsSection">
            <h3>Configuración de Vueltas y Banderas</h3>
            <label for="totalTurnsInput">Cantidad de Vueltas (ciclos completos IDA-VUELTA):</label>
            <input type="number" id="totalTurnsInput" value="1" min="1" onchange="updateRouteSettings()">
            <label for="flagNameIdaInput">Nombre Bandera IDA:</label>
            <input type="text" id="flagNameIdaInput" value="IDA" onchange="updateRouteSettings()">
            <label for="flagNameVueltaInput">Nombre Bandera VUELTA:</label>
            <input type="text" id="flagNameVueltaInput" value="VUELTA" onchange="updateRouteSettings()">
        </div>

        <div class="control-section">
            <h3>Configuración de Visualización</h3>
            <label for="stopRadiusInput">Radio de Paradas/Puntas (metros):</label>
            <input type="number" id="stopRadiusInput" value="50" min="10" max="500" onchange="updateGlobalStopRadiusSettings()">
        </div>

        <div class="control-section">
            <h3>Lista de Puntos (Paradas y Puntas de Línea)</h3>
            <div id="stopsList">No hay puntos definidos.</div>
        </div>
        
        <div class="control-section">
            <h3>Guardar/Cargar Rutas</h3>
            <label for="routeName">Nombre para Guardar Ruta:</label>
            <input type="text" id="routeName" placeholder="Ej: Ruta Mañana Lunes">
            <button onclick="saveRoute()">Guardar Ruta</button>
            <br><br>
            <label for="savedRoutes">Cargar Ruta:</label>
            <select id="savedRoutes"></select>
            <button onclick="loadRoute()">Cargar</button>
            <button onclick="deleteRoute()" class="danger">Borrar Seleccionada</button>
        </div>

        <div class="control-section">
            <h3>Seguimiento</h3>
            <button id="startTrackingBtn" onclick="startTracking()">Iniciar Seguimiento</button>
            <button id="stopTrackingBtn" onclick="stopTracking()" class="danger" style="display:none;">Detener Seguimiento</button>
            <br>
            <input type="checkbox" id="manualStopNav" onchange="updateManualNavButtons()">
            <label for="manualStopNav" style="display:inline;">Navegación Manual de Puntos</label>
            <button id="prevStopBtn" onclick="goToPreviousActivePoint()" style="display:none;">Anterior</button>
            <button id="nextStopBtn" onclick="goToNextActivePoint()" style="display:none;">Siguiente</button>
        </div>
        
        <div class="control-section">
            <h3>Cola de Rutas</h3>
            <label for="routeToQueue">Añadir ruta guardada a la cola:</label>
            <select id="routeToQueue"></select>
            <button onclick="addRouteToQueue()">Añadir a Cola</button>
            <h4>En Cola:</h4>
            <div id="routeQueueDisplay">Vacía.</div>
            <button onclick="clearRouteQueue()">Limpiar Cola</button>
        </div>

    </div>

    <script>
        'use strict';
        let map;
        let routePoints = []; 
        let routeLine;
        let userMarker;
        let trackingIntervalId;
        let isTracking = false;
        let currentSegmentStartIndex = 0; 
        let lastKnownPosition = null;
        let currentlyEditingPoint = null; 
        let currentStopRadius = 50; 
        
        let activePointCreationMode = null; // null | 'waypoint' | 'intermediateStop' | 'lineEndpoint'
        let timeEditingPriority = false; // true if 'schedule' mode is active

        const CACHE_PREFIX = 'smartMovePro_route_';
        const ROUTE_QUEUE_CACHE_KEY = 'smartMovePro_routeQueue';

        let routeSettings = {
            totalTurns: 1,
            flagNameIda: "IDA",
            flagNameVuelta: "VUELTA"
        };
        
        let currentEditingFlagView = routeSettings.flagNameIda; // For route creation polyline view

        let trackingState = {
            currentTurn: 1,
            currentFlag: routeSettings.flagNameIda, 
            activeLegPoints: [], 
        };
        
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }
        
        function createDivIcon(text, pointCategory = '', isFirstEndpoint = false) {
            let htmlContent = '';
            let iconSize = [30,30]; 
            let iconAnchor = [15,15]; 
            let className = 'leaflet-div-icon';

            if (pointCategory === 'waypoint') {
                className += ' waypoint-marker-icon'; 
                iconSize = [12,12]; 
                iconAnchor = [6,6];
            } else if (pointCategory === 'lineEndpoint') {
                const bgColor = isFirstEndpoint ? '#FF8C00' : '#DA70D6'; 
                const P_char = text ? text.substring(0,1).toUpperCase() : (isFirstEndpoint ? 'P1' : 'P2');
                htmlContent = `<div style="background-color:${bgColor}; width: 28px; height:28px; display:flex; justify-content:center; align-items:center; border-radius: 50%; color: white; font-size:14px; font-weight:bold; border: 2px solid white;">${P_char}</div>`;
                iconSize = [32,32]; 
                iconAnchor = [16,16];
            } else { // intermediateStop
                const bgColor = '#2196F3'; 
                const displayText = text || '?';
                htmlContent = `<div style="background-color:${bgColor}; padding: 5px 8px; border-radius: 5px; color: white; font-size:12px; font-weight:bold; border: 1px solid white; min-width: 15px; text-align: center;">${displayText}</div>`;
                iconSize = [displayText.length > 1 ? 35 : 30, 30]; 
                iconAnchor = [iconSize[0]/2, 15];
            }
            
            return L.divIcon({
                className: className,
                html: htmlContent,
                iconSize: iconSize, 
                iconAnchor: iconAnchor
            });
        }
        
        function createUserLocationIcon() {
            return L.divIcon({
                className: 'user-location-icon',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        function initMap() {
            map = L.map('map').setView([-34.6037, -58.3816], 13); 
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            map.on('click', onMapClick);
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    map.setView([position.coords.latitude, position.coords.longitude], 13);
                });
            }
            document.getElementById('stopRadiusInput').value = currentStopRadius;
            updateRouteSettings(); // This will also initialize currentEditingFlagView and button text
        }

        function setActiveMode(modeName) {
            const modeButtons = {
                flagConfig: document.getElementById('modeFlagConfigBtn'),
                waypoint: document.getElementById('modeWaypointBtn'),
                intermediateStop: document.getElementById('modeIntermediateStopBtn'),
                lineEndpoint: document.getElementById('modeLineEndpointBtn'),
                schedule: document.getElementById('modeScheduleBtn')
            };
            const statusP = document.getElementById('activeModeStatus');
            const cancelBtn = document.getElementById('modeCancelBtn');

            activePointCreationMode = null;
            timeEditingPriority = false;
            Object.values(modeButtons).forEach(btn => { 
                if(btn) btn.classList.remove('active-mode-button');
            });
            cancelEdit(); 

            if (modeName === null) { 
                statusP.textContent = "Selecciona un modo o toca un punto existente para editar.";
                statusP.style.color = '#FFFFFF'; 
                cancelBtn.style.display = 'none';
                updateWaypointMarkersVisibility(false); 
                return;
            }

            if(modeButtons[modeName]) modeButtons[modeName].classList.add('active-mode-button');
            cancelBtn.style.display = 'inline-block';
            statusP.style.color = '#17a2b8';

            switch (modeName) {
                case 'flagConfig':
                    statusP.textContent = "Modo Edición de Bandera: Configure vueltas y nombres de bandera en su sección.";
                    document.getElementById('routeSettingsSection')?.scrollIntoView({ behavior: 'smooth' });
                    updateWaypointMarkersVisibility(false);
                    break;
                case 'waypoint':
                    activePointCreationMode = 'waypoint';
                    statusP.textContent = "Modo 'Añadir Punto de Paso' ACTIVO. Toca el mapa para añadir. Toca un punto de paso existente para borrarlo.";
                    updateWaypointMarkersVisibility(true);
                    break;
                case 'intermediateStop':
                    activePointCreationMode = 'intermediateStop';
                    statusP.textContent = "Modo 'Añadir Parada Intermedia' ACTIVO. Toca el mapa para añadir.";
                    updateWaypointMarkersVisibility(false);
                    break;
                case 'lineEndpoint':
                    activePointCreationMode = 'lineEndpoint';
                    statusP.textContent = "Modo 'Añadir Punta de Línea' ACTIVO. Toca el mapa para añadir (máx. 2).";
                    updateWaypointMarkersVisibility(false);
                    break;
                case 'schedule':
                    timeEditingPriority = true;
                    statusP.textContent = "Modo 'Editar Horarios' ACTIVO. Toca una parada o punta de línea para editar sus horarios.";
                    updateWaypointMarkersVisibility(false);
                    break;
            }
        }
        
        function updateWaypointMarkersVisibility(showWaypointsOverride = null) {
            const show = showWaypointsOverride !== null ? showWaypointsOverride : (activePointCreationMode === 'waypoint');
            routePoints.forEach(p => {
                if (p.pointCategory === 'waypoint' && p.marker) {
                    if (show) {
                        if (!map.hasLayer(p.marker)) map.addLayer(p.marker);
                    } else {
                        if (map.hasLayer(p.marker)) map.removeLayer(p.marker);
                    }
                }
            });
        }

        function toggleEditingFlagView() {
            const btn = document.getElementById('toggleEditingFlagViewBtn');
            if (currentEditingFlagView === routeSettings.flagNameIda) {
                currentEditingFlagView = routeSettings.flagNameVuelta;
            } else {
                currentEditingFlagView = routeSettings.flagNameIda;
            }
            btn.textContent = `Vista Trazado: ${currentEditingFlagView}`;
            redrawRouteLine();
        }
        
        function updateRouteSettings() {
            const oldIdaName = routeSettings.flagNameIda;
            const oldVueltaName = routeSettings.flagNameVuelta;
        
            routeSettings.totalTurns = parseInt(document.getElementById('totalTurnsInput').value) || 1;
            routeSettings.flagNameIda = document.getElementById('flagNameIdaInput').value || "IDA";
            routeSettings.flagNameVuelta = document.getElementById('flagNameVueltaInput').value || "VUELTA";
        
            if (currentEditingFlagView === oldIdaName) {
                currentEditingFlagView = routeSettings.flagNameIda;
            } else if (currentEditingFlagView === oldVueltaName) {
                currentEditingFlagView = routeSettings.flagNameVuelta;
            } else { // If names changed significantly or currentEditingFlagView was something else
                currentEditingFlagView = routeSettings.flagNameIda;
            }
        
            const btn = document.getElementById('toggleEditingFlagViewBtn');
            if (btn) { // Button might not exist if called very early
                btn.textContent = `Vista Trazado: ${currentEditingFlagView}`;
            }
            
            if (!isTracking) {
                trackingState.currentFlag = routeSettings.flagNameIda;
            }
            redrawRouteLine(); 
            updateTrackingStatusDisplay();
        }

        function formatDateTimeForInput(date) {
            if (!date || isNaN(new Date(date).getTime())) return "";
            const d = new Date(date);
            d.setMinutes(d.getMinutes() - d.getTimezoneOffset());
            return d.toISOString().slice(0, 16);
        }

        function activateEditModeForPoint(point) {
            if (isTracking) { return; }
            if (point.pointCategory === 'waypoint') {
                 if (activePointCreationMode === 'waypoint') {
                    // Deletion is handled by waypoint's own click listener when in waypoint mode
                 } else {
                    alert("Para interactuar con Puntos de Paso, active el modo '+Pto. Paso'.");
                 }
                return;
            }
            
            if (activePointCreationMode !== null) {
                setActiveMode(null); 
            } else {
                cancelEdit(); 
            }

            currentlyEditingPoint = point;
            document.getElementById('pointName').value = point.name;
            document.getElementById('pointName').readOnly = timeEditingPriority;
            
            document.getElementById('lineEndpointTimes').style.display = 'none';
            document.getElementById('intermediateStopTime').style.display = 'none';

            if (point.pointCategory === 'lineEndpoint') {
                document.getElementById('lineEndpointTimes').style.display = 'block';
                const depTimeKey = point.isFirstEndpoint ? 'departureOutbound' : 'departureReturn';
                const arrTimeKey = point.isFirstEndpoint ? 'arrivalReturn' : 'arrivalOutbound';
                document.getElementById('pointScheduledDepartureTime').value = formatDateTimeForInput(point.times[depTimeKey]);
                document.getElementById('pointScheduledArrivalTime').value = formatDateTimeForInput(point.times[arrTimeKey]);
                if(timeEditingPriority) document.getElementById('pointScheduledDepartureTime').focus();
            } else if (point.pointCategory === 'intermediateStop') {
                document.getElementById('intermediateStopTime').style.display = 'block';
                document.getElementById('pointScheduledTimeIntermediate').value = formatDateTimeForInput(point.times.scheduledIDA);
                 if(timeEditingPriority) document.getElementById('pointScheduledTimeIntermediate').focus();
            }
            
            document.getElementById('editPointControls').style.display = 'block';
            if (!timeEditingPriority) document.getElementById('pointName').focus();
        }

        function cancelEdit() {
            currentlyEditingPoint = null;
            document.getElementById('pointName').value = "";
            document.getElementById('pointName').readOnly = false;
            document.getElementById('pointScheduledDepartureTime').value = "";
            document.getElementById('pointScheduledArrivalTime').value = "";
            document.getElementById('pointScheduledTimeIntermediate').value = "";
            document.getElementById('editPointControls').style.display = 'none';
            document.getElementById('lineEndpointTimes').style.display = 'none';
            document.getElementById('intermediateStopTime').style.display = 'none';
        }

        function updateSelectedPoint() {
            if (!currentlyEditingPoint || currentlyEditingPoint.pointCategory === 'waypoint') return;

            if (!timeEditingPriority) { 
                const newName = document.getElementById('pointName').value.trim();
                if (!newName) { alert("El nombre del punto no puede estar vacío."); return; }
                currentlyEditingPoint.name = newName;
            }

            if (currentlyEditingPoint.pointCategory === 'lineEndpoint') {
                const depTimeValue = document.getElementById('pointScheduledDepartureTime').value;
                const arrTimeValue = document.getElementById('pointScheduledArrivalTime').value;
                
                if (!depTimeValue || !arrTimeValue) {
                    alert("Las Puntas de Línea deben tener horarios de salida y llegada definidos."); return;
                }
                const departureTime = new Date(depTimeValue);
                const arrivalTime = new Date(arrTimeValue);

                if (isNaN(departureTime.getTime()) || isNaN(arrivalTime.getTime())) {
                    alert("Formato de fecha/hora inválido para Punta de Línea."); return;
                }
                
                if (currentlyEditingPoint.isFirstEndpoint) {
                    currentlyEditingPoint.times.departureOutbound = departureTime;
                    currentlyEditingPoint.times.arrivalReturn = arrivalTime;
                } else {
                    currentlyEditingPoint.times.arrivalOutbound = arrivalTime; 
                    currentlyEditingPoint.times.departureReturn = departureTime; 
                }

            } else if (currentlyEditingPoint.pointCategory === 'intermediateStop') {
                const interTimeValue = document.getElementById('pointScheduledTimeIntermediate').value;
                currentlyEditingPoint.times.scheduledIDA = interTimeValue ? new Date(interTimeValue) : null;
                if (interTimeValue && isNaN(currentlyEditingPoint.times.scheduledIDA.getTime())) {
                     alert("Formato de fecha/hora inválido para Parada Intermedia.");
                     currentlyEditingPoint.times.scheduledIDA = null; 
                     return;
                }
            }
            
            if (document.getElementById('autoCalcTimes').checked) {
                calculateAndApplyAllIntermediateTimes();
            }
            updateAllMarkerIconsAndLabels(); 
            redrawRouteLine();
            updateStopsList();
            alert(`Punto "${currentlyEditingPoint.name}" actualizado.`);
            cancelEdit(); 
        }

        function deleteSelectedPoint() {
            if (!currentlyEditingPoint || currentlyEditingPoint.pointCategory === 'waypoint') return;
        
            if (confirm(`¿Seguro que quieres borrar el punto "${currentlyEditingPoint.name}"?`)) {
                map.removeLayer(currentlyEditingPoint.marker);
                if (currentlyEditingPoint.radiusCircle) map.removeLayer(currentlyEditingPoint.radiusCircle);
                
                const originalPointCategory = currentlyEditingPoint.pointCategory;
                const pointNameToDelete = currentlyEditingPoint.name; 
                routePoints = routePoints.filter(p => p.id !== currentlyEditingPoint.id);
                
                if (originalPointCategory === 'lineEndpoint') {
                    const remainingLineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
                    if (remainingLineEndpoints.length > 0) {
                         remainingLineEndpoints.sort((a,b) => a.originalIndex - b.originalIndex);
                         remainingLineEndpoints[0].isFirstEndpoint = true;
                         if(remainingLineEndpoints.length > 1) remainingLineEndpoints[1].isFirstEndpoint = false;
                    }
                }
        
                if (document.getElementById('autoCalcTimes').checked) {
                    calculateAndApplyAllIntermediateTimes();
                }
                updateAllMarkerIconsAndLabels();
                redrawRouteLine();
                updateStopsList();
                alert(`Punto "${pointNameToDelete}" borrado.`);
            }
            cancelEdit(); 
        }
        
        function updateAllMarkerIconsAndLabels() {
            const displayOrderedPoints = getSortedRoutePointsForDisplay(); 

            routePoints.forEach(p => { 
                if (p.marker) {
                    let text = '';
                    if (p.pointCategory === 'lineEndpoint') {
                        text = p.name; 
                    } else if (p.pointCategory === 'intermediateStop') {
                        // Find index among only intermediate stops for display numbering
                        const intermediateStopsOnly = displayOrderedPoints.filter(dp => dp.pointCategory === 'intermediateStop');
                        const displayIdx = intermediateStopsOnly.findIndex(dp => dp.id === p.id);
                        text = (displayIdx !== -1) ? String(displayIdx + 1) : '?';
                    }
                    p.marker.setIcon(createDivIcon(text, p.pointCategory, p.isFirstEndpoint));
                }
            });
        }

        function onMapClick(e) {
            if (isTracking) { alert("Detén el seguimiento para modificar la ruta."); return; }
            
            let targetIsMarkerIcon = e.originalEvent.target.closest && e.originalEvent.target.closest('.leaflet-marker-icon');
            
            if (currentlyEditingPoint && !targetIsMarkerIcon) {
                cancelEdit();
            }
            if (targetIsMarkerIcon) return; 

            const latlng = e.latlng;
            const pointId = generateUniqueId();
            
            if (activePointCreationMode) {
                document.getElementById('pointName').value = ""; 
                let pointNameValue = ""; 
                let newPointData = {
                    id: pointId, lat: latlng.lat, lng: latlng.lng,
                    originalIndex: routePoints.length, times: {}
                };

                switch (activePointCreationMode) {
                    case 'waypoint':
                        const waypoint = {
                            id: pointId, lat: latlng.lat, lng: latlng.lng, 
                            name: `Paso ${routePoints.filter(p => p.pointCategory === 'waypoint').length + 1}`,
                            pointCategory: 'waypoint',
                            marker: L.marker(latlng, { icon: createDivIcon(null, 'waypoint'), draggable: true }),
                            radiusCircle: null, originalIndex: routePoints.length 
                        };
                        if (map.hasLayer(waypoint.marker)) map.removeLayer(waypoint.marker);
                        map.addLayer(waypoint.marker);

                        waypoint.marker.on('dragend', function(event) {
                            if (isTracking) { event.target.setLatLng(L.latLng(waypoint.lat, waypoint.lng)); return; }
                            const pos = event.target.getLatLng(); waypoint.lat = pos.lat; waypoint.lng = pos.lng;
                            redrawRouteLine();
                            if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                        });
                        waypoint.marker.on('click', function(ev) {
                            L.DomEvent.stopPropagation(ev); if (isTracking) return;
                            if (activePointCreationMode === 'waypoint') { 
                                if (confirm(`¿Borrar este punto de paso "${waypoint.name}"?`)) {
                                    map.removeLayer(waypoint.marker);
                                    routePoints = routePoints.filter(p => p.id !== waypoint.id);
                                    redrawRouteLine();
                                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                                }
                            } else {
                                alert("Para borrar Puntos de Paso, active el modo '+Pto. Paso'.");
                            }
                        });
                        routePoints.push(waypoint);
                        routePoints.sort((a,b) => a.originalIndex - b.originalIndex); // Re-sort just in case, then re-assign indices
                        routePoints.forEach((p, idx) => p.originalIndex = idx);

                        if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes(); 
                        redrawRouteLine();
                        return; 

                    case 'intermediateStop':
                        newPointData.name = `Parada ${routePoints.filter(p => p.pointCategory === 'intermediateStop').length + 1}`;
                        newPointData.pointCategory = 'intermediateStop';
                        newPointData.times = { scheduledIDA: null, scheduledVUELTA: null };
                        break;

                    case 'lineEndpoint':
                        const currentLineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
                        if (currentLineEndpoints.length >= 2) {
                            alert("Ya existen dos Puntas de Línea. No se pueden añadir más.");
                            return;
                        }
                        const isFirstEp = (currentLineEndpoints.length === 0);
                        newPointData.name = isFirstEp ? "Punta de Línea 1" : "Punta de Línea 2";
                        newPointData.pointCategory = 'lineEndpoint';
                        newPointData.isFirstEndpoint = isFirstEp;
                        newPointData.times = isFirstEp ? 
                            { departureOutbound: null, arrivalReturn: null } : 
                            { arrivalOutbound: null, departureReturn: null };
                        break;
                    default: return; 
                }
                
                const newPoint = { ...newPointData };
                routePoints.push(newPoint);
                routePoints.sort((a,b) => a.originalIndex - b.originalIndex); 
                routePoints.forEach((p, idx) => p.originalIndex = idx);

                newPoint.marker = L.marker(latlng, { 
                    icon: createDivIcon(newPoint.name, newPoint.pointCategory, newPoint.isFirstEndpoint), draggable: true 
                }).addTo(map);
                newPoint.radiusCircle = L.circle(latlng, {
                    radius: currentStopRadius, 
                    color: (newPoint.pointCategory === 'lineEndpoint' ? (newPoint.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'), 
                    weight: 1, opacity: 0.5, 
                    fillColor: (newPoint.pointCategory === 'lineEndpoint' ? (newPoint.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'), fillOpacity: 0.2
                }).addTo(map);

                newPoint.marker.on('dragend', function(event) {
                    if (isTracking) {event.target.setLatLng(L.latLng(newPoint.lat, newPoint.lng)); return; }
                    const pos = event.target.getLatLng(); newPoint.lat = pos.lat; newPoint.lng = pos.lng;
                    if (newPoint.radiusCircle) newPoint.radiusCircle.setLatLng(pos);
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                    updateStopsList(); 
                });
                newPoint.marker.on('click', function(ev) { L.DomEvent.stopPropagation(ev); if (isTracking) return; activateEditModeForPoint(newPoint); });
                
                updateAllMarkerIconsAndLabels();
                if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                redrawRouteLine();
                updateStopsList();
            } else if (timeEditingPriority) {
                // In 'schedule' mode, map click itself does nothing unless it's on a marker.
            }
        }
        
        // LA TRAZA DIBUJADA AZUL/ROJA DEBE SEGUIR A LOS PUNTOS DE PASO Y A LAS PARADAS INTERMEDIAS... SIEMPRE.
        function getPathPointsForPolyline(flagNameToUse) {
            const allPointsSorted = [...routePoints].sort((a, b) => a.originalIndex - b.originalIndex);
            if (allPointsSorted.length < 1) return []; // No points, no path

            const lineEndpoints = allPointsSorted.filter(p => p.pointCategory === 'lineEndpoint');

            // If less than 2 endpoints, or no P1/P2 identified, trace all points in order
            if (lineEndpoints.length < 2) {
                return allPointsSorted;
            }

            const p1 = lineEndpoints.find(p => p.isFirstEndpoint);
            const p2 = lineEndpoints.find(p => !p.isFirstEndpoint);

            if (!p1 || !p2) { // Should have P1 and P2 if length >= 2
                return allPointsSorted;
            }

            const p1ActualIndexInSortedArray = allPointsSorted.findIndex(p => p.id === p1.id);
            const p2ActualIndexInSortedArray = allPointsSorted.findIndex(p => p.id === p2.id);

            if (flagNameToUse === routeSettings.flagNameIda) {
                // IDA: Path from P1 to P2, following the order in allPointsSorted
                if (p1ActualIndexInSortedArray < p2ActualIndexInSortedArray) {
                    return allPointsSorted.slice(p1ActualIndexInSortedArray, p2ActualIndexInSortedArray + 1);
                } else { // P1 is after P2 in the list (e.g. P2, ..., P1), IDA path wraps around
                    return [
                        ...allPointsSorted.slice(p1ActualIndexInSortedArray), 
                        ...allPointsSorted.slice(0, p2ActualIndexInSortedArray + 1)
                    ];
                }
            } else { // VUELTA
                // VUELTA: Path from P2 to P1, following the order in allPointsSorted
                if (p2ActualIndexInSortedArray < p1ActualIndexInSortedArray) {
                    return allPointsSorted.slice(p2ActualIndexInSortedArray, p1ActualIndexInSortedArray + 1);
                } else { // P2 is after P1 in the list (e.g. P1, ..., P2), VUELTA path wraps around
                    return [
                        ...allPointsSorted.slice(p2ActualIndexInSortedArray), 
                        ...allPointsSorted.slice(0, p1ActualIndexInSortedArray + 1)
                    ];
                }
            }
        }


        function calculateAndApplyAllIntermediateTimes() {
            const autoCalc = document.getElementById('autoCalcTimes').checked;
            if (!autoCalc) { 
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => stop.times.scheduledVUELTA = null);
                updateStopsList(); return; 
            }

            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint').sort((a,b)=>a.originalIndex - b.originalIndex);
            if (lineEndpoints.length < 2) { updateStopsList(); return; }
            
            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);
            if (!p1 || !p2) { updateStopsList(); return; }

            const allPointsSorted = [...routePoints].sort((a, b) => a.originalIndex - b.originalIndex);
            const p1ActualIndex = allPointsSorted.findIndex(p => p.id === p1.id);
            const p2ActualIndex = allPointsSorted.findIndex(p => p.id === p2.id);

            // IDA leg times calculation
            if (p1.times.departureOutbound && p2.times.arrivalOutbound) {
                let idaLegPath;
                if (p1ActualIndex < p2ActualIndex) {
                    idaLegPath = allPointsSorted.slice(p1ActualIndex, p2ActualIndex + 1);
                } else { // Wrap around
                    idaLegPath = [...allPointsSorted.slice(p1ActualIndex), ...allPointsSorted.slice(0, p2ActualIndex + 1)];
                }
                distributeTimesProportionally(idaLegPath, new Date(p1.times.departureOutbound), new Date(p2.times.arrivalOutbound), 'scheduledIDA');
            } else {
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => stop.times.scheduledIDA = null);
            }

            // VUELTA leg times calculation (only if auto-calc is on and it's a simple reversal)
            // For distinct VUELTA paths, times would need manual input or more complex logic
            // This part assumes VUELTA reuses IDA intermediates in reverse if auto-calculating.
            if (p2.times.departureReturn && p1.times.arrivalReturn) {
                let vueltaLegPath;
                 if (p2ActualIndex < p1ActualIndex) {
                    vueltaLegPath = allPointsSorted.slice(p2ActualIndex, p1ActualIndex + 1);
                } else { // Wrap around
                    vueltaLegPath = [...allPointsSorted.slice(p2ActualIndex), ...allPointsSorted.slice(0, p1ActualIndex + 1)];
                }
                // If vueltaLegPath reuses the same intermediate stops as IDA (just P1 and P2 swapped)
                // then distribute proportionally. Otherwise, this needs to be smarter or disabled for complex routes.
                // For now, this will calculate for the VUELTA path defined by P2->P1 slice.
                distributeTimesProportionally(vueltaLegPath, new Date(p2.times.departureReturn), new Date(p1.times.arrivalReturn), 'scheduledVUELTA');
            } else {
                routePoints.filter(p => p.pointCategory === 'intermediateStop').forEach(stop => stop.times.scheduledVUELTA = null);
            }
            updateStopsList();
        }

        function distributeTimesProportionally(legPathPoints, legStartTimeDate, legEndTimeDate, timeKey) {
            if (!legStartTimeDate || !legEndTimeDate || legPathPoints.length < 2) return;
            
            const legStartMillis = legStartTimeDate.getTime();
            const legEndMillis = legEndTimeDate.getTime();
            const totalDurationMillis = legEndMillis - legStartMillis;

            const intermediateStopsInLeg = legPathPoints.slice(1, -1).filter(p => p.pointCategory === 'intermediateStop');
            if (totalDurationMillis <= 0) {
                intermediateStopsInLeg.forEach(p => {
                    const pointInMainRoute = routePoints.find(rp => rp.id === p.id);
                    if(pointInMainRoute) pointInMainRoute.times[timeKey] = null;
                });
                return;
            }

            let totalDistance = 0;
            const segmentDistances = [];
            for (let i = 0; i < legPathPoints.length - 1; i++) {
                const dist = L.latLng(legPathPoints[i].lat, legPathPoints[i].lng)
                               .distanceTo(L.latLng(legPathPoints[i+1].lat, legPathPoints[i+1].lng));
                segmentDistances.push(dist);
                totalDistance += dist;
            }

            if (totalDistance < 1.0) { 
                const numTimeSegments = intermediateStopsInLeg.length + 1;
                if (numTimeSegments <= 0) return;
                const timePerSegment = totalDurationMillis / numTimeSegments;
                let currentTime = legStartMillis;
                legPathPoints.slice(1, -1).forEach(p_leg => { 
                    if (p_leg.pointCategory === 'intermediateStop') {
                       currentTime += timePerSegment; 
                       const pointInMainRoute = routePoints.find(rp => rp.id === p_leg.id);
                       if(pointInMainRoute) pointInMainRoute.times[timeKey] = new Date(currentTime);
                    }
                });
            } else {
                let accumulatedDistance = 0;
                for (let i = 0; i < legPathPoints.length - 1; i++) {
                    accumulatedDistance += segmentDistances[i];
                    const nextPointInPath = legPathPoints[i+1];
                    if (nextPointInPath.pointCategory === 'intermediateStop') {
                        const proportionOfRoute = accumulatedDistance / totalDistance;
                        const timeOffsetMillis = totalDurationMillis * proportionOfRoute;
                        const pointInMainRoute = routePoints.find(rp => rp.id === nextPointInPath.id);
                        if(pointInMainRoute) pointInMainRoute.times[timeKey] = new Date(legStartMillis + timeOffsetMillis);
                    }
                }
            }
        }
        
        function clearCurrentRoute() {
            setActiveMode(null); 
            routePoints.forEach(p => {
                if (p.marker) map.removeLayer(p.marker);
                if (p.radiusCircle) map.removeLayer(p.radiusCircle);
            });
            routePoints = [];
            if (routeLine) map.removeLayer(routeLine); routeLine = null;
            document.getElementById('pointName').value = "";
            // Reset editing flag view to default (IDA)
            currentEditingFlagView = routeSettings.flagNameIda;
            const editFlagBtn = document.getElementById('toggleEditingFlagViewBtn');
            if(editFlagBtn) editFlagBtn.textContent = `Vista Trazado: ${routeSettings.flagNameIda}`;

            updateStopsList(); updateAllMarkerIconsAndLabels(); 
            redrawRouteLine(); // Add this to clear the line from map if any
        }

        function redrawRouteLine() {
            if (routeLine) map.removeLayer(routeLine); routeLine = null;
            
            const flagForPolyline = isTracking ? trackingState.currentFlag : currentEditingFlagView;
            const polylinePathPoints = getPathPointsForPolyline(flagForPolyline); 
            
            if (polylinePathPoints.length > 1) {
                const latlngs = polylinePathPoints.map(p => [p.lat, p.lng]);
                const color = (flagForPolyline === routeSettings.flagNameIda) ? 'blue' : 'red';
                routeLine = L.polyline(latlngs, {color: color, weight: 5}).addTo(map);
            }
        }
        
        function getSortedRoutePointsForDisplay() { 
            // Display all points, sorted by originalIndex, for the list.
            // The list shows P1, then intermediates between P1 & P2, then P2, then any points after P2.
            return [...routePoints].sort((a, b) => a.originalIndex - b.originalIndex)
                                  .filter(p => p.pointCategory !== 'waypoint'); // Waypoints not in stops list
        }

        function formatTime(dateObj, includeDate = true) { 
            if (!dateObj || isNaN(new Date(dateObj).getTime())) return "N/A";
            let timeStr = new Date(dateObj).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            if (includeDate) {
                 timeStr += ` (${new Date(dateObj).toLocaleDateString('es-ES', {day:'2-digit', month:'2-digit'})})`;
            }
            return timeStr;
        }
        
        function updateStopsList() {
            const listDiv = document.getElementById('stopsList');
            const displayPoints = getSortedRoutePointsForDisplay(); 

            if (displayPoints.length === 0) { listDiv.innerHTML = "No hay puntos definidos."; return; }

            let html = "<ul style='padding-left: 10px; list-style: none;'>"; // Using none for custom numbering effect
            let intermediateVisualCounter = 1; 
            let overallCounter = 1;
            displayPoints.forEach((p) => { 
                let typeText = "", timeStr = "N/A";
                let itemClass = "stop-item";
                let prefix = `${overallCounter++}. `;


                if (p.pointCategory === 'lineEndpoint') {
                    itemClass += " line-endpoint-highlight";
                    typeText = p.isFirstEndpoint ? "P1" : "P2"; // Simpler P1/P2
                    const dep = p.isFirstEndpoint ? p.times.departureOutbound : p.times.departureReturn;
                    const arr = p.isFirstEndpoint ? p.times.arrivalReturn : p.times.arrivalOutbound;
                    timeStr = `Sal: ${formatTime(dep, false)} / Lleg: ${formatTime(arr, false)}`;
                    if (dep) timeStr += ` (${new Date(dep).toLocaleDateString('es-ES',{day:'2-digit',month:'2-digit'})})`;
                } else if (p.pointCategory === 'intermediateStop') {
                    typeText = `Inter. ${intermediateVisualCounter++}`;
                    timeStr = `IDA: ${formatTime(p.times.scheduledIDA, false)} / VTA: ${formatTime(p.times.scheduledVUELTA, false)}`;
                    if (p.times.scheduledIDA) timeStr += ` (${new Date(p.times.scheduledIDA).toLocaleDateString('es-ES',{day:'2-digit',month:'2-digit'})})`;
                }
                html += `<li class="${itemClass}" onclick="focusPointOnMap('${p.id}')">${prefix}<b>${p.name}</b> (${typeText}) - ${timeStr}</li>`;
            });
            html += "</ul>";
            listDiv.innerHTML = html;
            highlightNextStopInList(); 
        }

        function focusPointOnMap(pointId) {
            const point = routePoints.find(p => p.id === pointId);
            if (point && map) {
                map.setView([point.lat, point.lng], Math.max(map.getZoom(), 16));
            }
        }

        function saveRoute() {
            setActiveMode(null); 
            const routeNameInput = document.getElementById('routeName');
            if (!routeNameInput.value) { alert("Por favor, ingresa un nombre para la ruta."); return; }
            
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
            if (lineEndpoints.length < 2) {
                 alert("Una ruta debe tener dos Puntas de Línea definidas (P1 y P2)."); return;
            }
            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);
            if (!p1 || !p2 || 
                !p1.times.departureOutbound || !p1.times.arrivalReturn ||
                !p2.times.arrivalOutbound || !p2.times.departureReturn) {
                alert("Ambas Puntas de Línea (P1 y P2) deben tener sus 4 horarios clave definidos.");
                return;
            }

            const savablePoints = routePoints.map(p => {
                const pointData = { 
                    id: p.id, lat: p.lat, lng: p.lng, name: p.name, 
                    pointCategory: p.pointCategory,
                    originalIndex: p.originalIndex,
                    times: {} 
                };
                if (p.pointCategory === 'lineEndpoint') {
                    pointData.isFirstEndpoint = p.isFirstEndpoint;
                    if (p.isFirstEndpoint) {
                        pointData.times.departureOutbound = p.times.departureOutbound ? new Date(p.times.departureOutbound).toISOString() : null;
                        pointData.times.arrivalReturn = p.times.arrivalReturn ? new Date(p.times.arrivalReturn).toISOString() : null;
                    } else {
                        pointData.times.arrivalOutbound = p.times.arrivalOutbound ? new Date(p.times.arrivalOutbound).toISOString() : null;
                        pointData.times.departureReturn = p.times.departureReturn ? new Date(p.times.departureReturn).toISOString() : null;
                    }
                } else if (p.pointCategory === 'intermediateStop') {
                    pointData.times.scheduledIDA = p.times.scheduledIDA ? new Date(p.times.scheduledIDA).toISOString() : null;
                    pointData.times.scheduledVUELTA = p.times.scheduledVUELTA ? new Date(p.times.scheduledVUELTA).toISOString() : null;
                }
                return pointData;
            });
            
            const routeDataToSave = { points: savablePoints, settings: routeSettings };
            localStorage.setItem(CACHE_PREFIX + routeNameInput.value, JSON.stringify(routeDataToSave));
            alert(`Ruta "${routeNameInput.value}" guardada.`);
            loadSavedRoutesLists();
        }

        function loadRoute() {
            setActiveMode(null); 
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) { alert("Selecciona una ruta para cargar."); return; }
            const savedDataRaw = localStorage.getItem(CACHE_PREFIX + selectedRouteName);
            if (!savedDataRaw) { alert("Error al cargar la ruta."); return; }

            clearCurrentRoute(); 
            const loadedRouteData = JSON.parse(savedDataRaw);
            const loadedPointsData = loadedRouteData.points;
            routeSettings = loadedRouteData.settings || { totalTurns: 1, flagNameIda: "IDA", flagNameVuelta: "VUELTA"};
            
            document.getElementById('totalTurnsInput').value = routeSettings.totalTurns;
            document.getElementById('flagNameIdaInput').value = routeSettings.flagNameIda;
            document.getElementById('flagNameVueltaInput').value = routeSettings.flagNameVuelta;

            // Update currentEditingFlagView and its button based on loaded settings
            currentEditingFlagView = routeSettings.flagNameIda;
            const editFlagBtn = document.getElementById('toggleEditingFlagViewBtn');
            if (editFlagBtn) editFlagBtn.textContent = `Vista Trazado: ${routeSettings.flagNameIda}`;
            
            trackingState.currentFlag = routeSettings.flagNameIda;


            loadedPointsData.forEach((p_data) => {
                const newPointBase = { ...p_data, times: {} }; 

                if (p_data.pointCategory === 'lineEndpoint') {
                    newPointBase.isFirstEndpoint = p_data.isFirstEndpoint; 
                    if (p_data.isFirstEndpoint) { 
                        newPointBase.times.departureOutbound = p_data.times.departureOutbound ? new Date(p_data.times.departureOutbound) : null;
                        newPointBase.times.arrivalReturn = p_data.times.arrivalReturn ? new Date(p_data.times.arrivalReturn) : null;
                    } else { 
                        newPointBase.times.arrivalOutbound = p_data.times.arrivalOutbound ? new Date(p_data.times.arrivalOutbound) : null;
                        newPointBase.times.departureReturn = p_data.times.departureReturn ? new Date(p_data.times.departureReturn) : null;
                    }
                } else if (p_data.pointCategory === 'intermediateStop') {
                     newPointBase.times.scheduledIDA = p_data.times.scheduledIDA ? new Date(p_data.times.scheduledIDA) : null;
                     newPointBase.times.scheduledVUELTA = p_data.times.scheduledVUELTA ? new Date(p_data.times.scheduledVUELTA) : null;
                }

                const newPoint = { ...newPointBase }; 
                routePoints.push(newPoint);
            });
            routePoints.sort((a,b) => a.originalIndex - b.originalIndex);

            routePoints.forEach(p => {
                 p.marker = L.marker([p.lat, p.lng], { 
                    icon: createDivIcon(p.name, p.pointCategory, p.isFirstEndpoint), 
                    draggable: true 
                }).addTo(map);
                 if (p.pointCategory !== 'waypoint') {
                    p.radiusCircle = L.circle([p.lat, p.lng], {
                        radius: currentStopRadius, 
                        color: (p.pointCategory === 'lineEndpoint' ? (p.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'), 
                        weight: 1, opacity: 0.5, 
                        fillColor: (p.pointCategory === 'lineEndpoint' ? (p.isFirstEndpoint ? '#FF8C00':'#DA70D6') : '#2196F3'), fillOpacity: 0.2
                    }).addTo(map);
                    p.marker.on('click', function(ev) {L.DomEvent.stopPropagation(ev); if(isTracking)return; activateEditModeForPoint(p); });
                 } else { 
                    p.marker.on('click', function(ev) {
                        L.DomEvent.stopPropagation(ev); if (isTracking) return;
                        if (activePointCreationMode === 'waypoint') { 
                            if (confirm(`¿Borrar este punto de paso "${p.name}"?`)) {
                                map.removeLayer(p.marker);
                                routePoints = routePoints.filter(rp => rp.id !== p.id);
                                routePoints.forEach((rp, idx) => rp.originalIndex = idx); // Re-index
                                redrawRouteLine();
                                if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                            }
                        } else {
                             alert("Para borrar Puntos de Paso, active el modo '+Pto. Paso'.");
                        }
                    });
                 }
                 p.marker.on('dragend', function(event){
                    if (isTracking) { event.target.setLatLng(L.latLng(p.lat, p.lng)); return; }
                    const pos = event.target.getLatLng(); p.lat = pos.lat; p.lng = pos.lng;
                    if (p.radiusCircle) p.radiusCircle.setLatLng(pos);
                    redrawRouteLine();
                    if (document.getElementById('autoCalcTimes').checked) calculateAndApplyAllIntermediateTimes();
                    updateStopsList();
                });
            });
            
            updateAllMarkerIconsAndLabels(); 
            updateWaypointMarkersVisibility(false); 
            redrawRouteLine();
            updateStopsList();

            const boundsPoints = routePoints; // Consider all points for bounds
            if (boundsPoints.length > 0) {
                const bounds = L.latLngBounds(boundsPoints.map(p => [p.lat, p.lng]));
                if (bounds.isValid()) map.fitBounds(bounds);
            }
            document.getElementById('routeName').value = selectedRouteName;
            alert(`Ruta "${selectedRouteName}" cargada.`);
        }

        function deleteRoute() {
            setActiveMode(null);
            const selectedRouteName = document.getElementById('savedRoutes').value;
            if (!selectedRouteName) { alert("Selecciona una ruta para borrar."); return; }
            if (confirm(`¿Estás seguro de que quieres borrar la ruta "${selectedRouteName}"?`)) {
                localStorage.removeItem(CACHE_PREFIX + selectedRouteName);
                let queue = getRouteQueue();
                queue = queue.filter(name => name !== selectedRouteName);
                saveRouteQueue(queue);
                loadSavedRoutesLists(); 
                alert(`Ruta "${selectedRouteName}" borrada.`);
            }
        }

        function loadSavedRoutesLists() { 
            const savedRoutesSelect = document.getElementById('savedRoutes');
            const routeToQueueSelect = document.getElementById('routeToQueue');
            const currentSavedRouteValue = savedRoutesSelect.value;
            const currentQueueRouteValue = routeToQueueSelect.value;

            savedRoutesSelect.innerHTML = ""; routeToQueueSelect.innerHTML = "";
            let hasRoutes = false;
            const routeNames = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(CACHE_PREFIX)) routeNames.push(key.substring(CACHE_PREFIX.length));
            }
            routeNames.sort(); 
            routeNames.forEach(routeName => {
                const option = document.createElement('option');
                option.value = routeName; option.textContent = routeName;
                savedRoutesSelect.appendChild(option.cloneNode(true));
                routeToQueueSelect.appendChild(option.cloneNode(true));
                hasRoutes = true;
            });
            if (!hasRoutes) {
                 const option = document.createElement('option');
                 option.textContent = "No hay rutas guardadas"; option.disabled = true;
                 savedRoutesSelect.appendChild(option.cloneNode(true));
                 routeToQueueSelect.appendChild(option);
            } else {
                if (routeNames.includes(currentSavedRouteValue)) savedRoutesSelect.value = currentSavedRouteValue;
                if (routeNames.includes(currentQueueRouteValue)) routeToQueueSelect.value = currentQueueRouteValue;
            }
            updateRouteQueueDisplay();
        }
        
        function setupCurrentLegForTracking() {
            trackingState.activeLegPoints = [];
            const legPathPoints = getPathPointsForPolyline(trackingState.currentFlag);
            if(legPathPoints.length === 0) {
                console.error("No points found for current leg in tracking.");
                return false;
            }

            // Need to map these leg path points (which could be raw from routePoints)
            // to have 'effectiveScheduledTime' for tracking logic.
            // This requires knowing which time field to use (departureOutbound, arrivalOutbound, scheduledIDA, etc.)
            // For simplicity, trackingState.activeLegPoints will use the `times` from original routePoints.
            // The time deviation logic needs to be robust to find the correct scheduled times based on point type and flag.

            // The getPathPointsForPolyline now returns the correct sequence of points for the current flag.
            // We need to associate scheduled times with these.
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
            const p1 = lineEndpoints.find(ep => ep.isFirstEndpoint);
            const p2 = lineEndpoints.find(ep => !ep.isFirstEndpoint);

            trackingState.activeLegPoints = legPathPoints.map(legPoint => {
                const originalPoint = routePoints.find(rp => rp.id === legPoint.id);
                if (!originalPoint) return { ...legPoint, effectiveScheduledTime: null }; // Should not happen

                let effTime = null;
                if (originalPoint.pointCategory === 'lineEndpoint') {
                    if (trackingState.currentFlag === routeSettings.flagNameIda) { // IDA leg
                        if (originalPoint.id === p1?.id) effTime = originalPoint.times.departureOutbound;
                        else if (originalPoint.id === p2?.id) effTime = originalPoint.times.arrivalOutbound;
                    } else { // VUELTA leg
                        if (originalPoint.id === p2?.id) effTime = originalPoint.times.departureReturn;
                        else if (originalPoint.id === p1?.id) effTime = originalPoint.times.arrivalReturn;
                    }
                } else if (originalPoint.pointCategory === 'intermediateStop') {
                    effTime = (trackingState.currentFlag === routeSettings.flagNameIda) ? originalPoint.times.scheduledIDA : originalPoint.times.scheduledVUELTA;
                }
                // Waypoints don't have scheduled times for deviation calculation in this model.
                return { ...originalPoint, effectiveScheduledTime: effTime ? new Date(effTime) : null };
            });


            if (trackingState.activeLegPoints.length > 0 && 
                (!trackingState.activeLegPoints[0].effectiveScheduledTime || 
                 !trackingState.activeLegPoints[trackingState.activeLegPoints.length -1].effectiveScheduledTime)
                ) {
                 alert(`Horarios incompletos para los extremos de la bandera ${trackingState.currentFlag} (Vuelta ${trackingState.currentTurn}).`);
                 return false;
            }
            return true;
        }

        function startTracking() {
            setActiveMode(null); 
            const lineEndpoints = routePoints.filter(p => p.pointCategory === 'lineEndpoint');
            if (lineEndpoints.length < 2) { alert("La ruta debe tener dos Puntas de Línea (P1 y P2)."); return; }
             if (!lineEndpoints.find(ep => ep.isFirstEndpoint) || !lineEndpoints.find(ep => !ep.isFirstEndpoint)){
                alert("P1 y/o P2 no están correctamente definidos."); return;
            }
            
            isTracking = true;
            trackingState.currentTurn = 1;
            trackingState.currentFlag = routeSettings.flagNameIda; // Start with IDA
            currentSegmentStartIndex = 0; 
            
            if (!setupCurrentLegForTracking()) {
                stopTracking(false, "Error configurando pierna inicial de seguimiento."); return;
            }
            
            document.getElementById('startTrackingBtn').style.display = 'none';
            document.getElementById('stopTrackingBtn').style.display = 'inline-block';
            document.getElementById('routeCreationSection').style.display = 'none'; 
            updateTrackingStatusDisplay();
            redrawRouteLine(); 
            updateWaypointMarkersVisibility(false); 

            if (navigator.geolocation) {
                trackingIntervalId = navigator.geolocation.watchPosition(
                    handlePositionUpdate, handleGeolocationError,
                    { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 } 
                );
                if (trackingState.activeLegPoints.length > 0 && trackingState.activeLegPoints[0]) {
                    map.setView([trackingState.activeLegPoints[0].lat, trackingState.activeLegPoints[0].lng], 16); 
                }
                highlightNextStopInList(); 
            } else {
                alert("Geolocalización no disponible."); stopTracking(false); 
            }
            updateManualNavButtons();
        }

        function stopTracking(completedNaturally = false, reason = "") {
            if (trackingIntervalId) navigator.geolocation.clearWatch(trackingIntervalId);
            trackingIntervalId = null; isTracking = false; lastKnownPosition = null;
            document.getElementById('startTrackingBtn').style.display = 'inline-block';
            document.getElementById('stopTrackingBtn').style.display = 'none';
            document.getElementById('routeCreationSection').style.display = 'block'; 
            if (userMarker) { map.removeLayer(userMarker); userMarker = null; }
            
            // Reset view to IDA for editing when tracking stops
            currentEditingFlagView = routeSettings.flagNameIda;
            const editFlagBtn = document.getElementById('toggleEditingFlagViewBtn');
            if (editFlagBtn) editFlagBtn.textContent = `Vista Trazado: ${routeSettings.flagNameIda}`;
            
            trackingState.currentFlag = routeSettings.flagNameIda; // Prepare for next potential tracking
            redrawRouteLine(); updateStopsList(); 
            currentSegmentStartIndex = 0; 
            updateManualNavButtons();
            setActiveMode(null); 
            updateWaypointMarkersVisibility(false); 


            if (completedNaturally) {
                document.getElementById('trackingInfoDisplay').textContent = "RUTA COMPLETADA";
                alert("Ruta completada!"); checkRouteQueue();
            } else {
                const msg = "Seguimiento detenido." + (reason ? " Razón: " + reason : "");
                console.log(msg); if (reason) alert(msg);
                document.getElementById('trackingInfoDisplay').textContent = "SEGUIMIENTO DETENIDO";
            }
        }
        
        function updateTrackingStatusDisplay() {
            if (!isTracking) {
                document.getElementById('statusDisplay').style.display = 'none';
                return;
            }

            document.getElementById('statusDisplay').style.display = 'block';
            document.getElementById('trackingInfoDisplay').textContent = 
                `Vuelta: ${trackingState.currentTurn}/${routeSettings.totalTurns} - Bandera: ${trackingState.currentFlag}`;
        }

        function updateManualNavButtons() {
            const manualNav = document.getElementById('manualStopNav').checked;
            const prevBtn = document.getElementById('prevStopBtn');
            const nextBtn = document.getElementById('nextStopBtn');
            
            if (isTracking && manualNav && trackingState.activeLegPoints && trackingState.activeLegPoints.length > 0) {
                prevBtn.style.display = 'inline-block';
                nextBtn.style.display = 'inline-block';
                prevBtn.disabled = currentSegmentStartIndex === 0;
                nextBtn.disabled = currentSegmentStartIndex >= trackingState.activeLegPoints.length - 2; 
            } else {
                prevBtn.style.display = 'none'; nextBtn.style.display = 'none';
            }
        }

        function handlePositionUpdate(position) {
            lastKnownPosition = position;
            const { latitude, longitude, speed } = position.coords;
            if (!userMarker) userMarker = L.marker([latitude, longitude], { icon: createUserLocationIcon() }).addTo(map);
            else userMarker.setLatLng([latitude, longitude]);
            map.panTo([latitude, longitude], {animate: true, duration: 0.5}); 
            document.getElementById('speedDisplay').textContent = `Velocidad: ${(speed ? (speed * 3.6) : 0).toFixed(1)} KM/H`;

            if (!trackingState.activeLegPoints || currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) {
                return; 
            }
            
            const manualNav = document.getElementById('manualStopNav').checked;
            let advancedThisTick = false;

            if (!manualNav) {
                const currentTargetPoint = trackingState.activeLegPoints[currentSegmentStartIndex + 1];
                if (currentTargetPoint && currentTargetPoint.pointCategory !== 'waypoint') { // Only auto-advance for stops/endpoints
                    const distanceToTarget = L.latLng(latitude, longitude).distanceTo(L.latLng(currentTargetPoint.lat, currentTargetPoint.lng));
                    if (distanceToTarget < currentStopRadius) {
                        advanceToNextActivePoint(); advancedThisTick = true;
                    }
                }
            }
            if (!advancedThisTick && currentSegmentStartIndex < trackingState.activeLegPoints.length -1 && trackingState.activeLegPoints[currentSegmentStartIndex+1]) { 
                 calculateTimeDeviation(position);
            }
        }
        
        function advanceToNextActivePoint() { 
            currentSegmentStartIndex++;
            if (!trackingState.activeLegPoints || currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) { 
                handleEndOfLeg();
            } else {
                highlightNextStopInList(); updateManualNavButtons();
                if (lastKnownPosition && trackingState.activeLegPoints[currentSegmentStartIndex+1]) calculateTimeDeviation(lastKnownPosition);
            }
        }

        function handleEndOfLeg() {
            if (trackingState.currentFlag === routeSettings.flagNameIda) {
                trackingState.currentFlag = routeSettings.flagNameVuelta;
            } else {
                trackingState.currentTurn++;
                if (trackingState.currentTurn > routeSettings.totalTurns) {
                    stopTracking(true); return;
                }
                trackingState.currentFlag = routeSettings.flagNameIda;
            }

            currentSegmentStartIndex = 0;
            if (!setupCurrentLegForTracking()) {
                 stopTracking(false, `Error configurando pierna ${trackingState.currentFlag} (Vuelta ${trackingState.currentTurn}).`); return;
            }
            updateTrackingStatusDisplay(); redrawRouteLine(); highlightNextStopInList();
            updateManualNavButtons(); 
            if (lastKnownPosition && trackingState.activeLegPoints && trackingState.activeLegPoints.length > 1 && trackingState.activeLegPoints[1]) {
                 calculateTimeDeviation(lastKnownPosition);
            }
            
            if (trackingState.activeLegPoints.length > 0 && trackingState.activeLegPoints[0]) {
                map.setView([trackingState.activeLegPoints[0].lat, trackingState.activeLegPoints[0].lng], map.getZoom()); 
            }
        }
        
        function goToPreviousActivePoint() {
            if (!isTracking || currentSegmentStartIndex === 0) return;
            currentSegmentStartIndex--;
            highlightNextStopInList(); updateManualNavButtons();
            if (lastKnownPosition && trackingState.activeLegPoints && trackingState.activeLegPoints[currentSegmentStartIndex+1]) calculateTimeDeviation(lastKnownPosition);
        }
        function goToNextActivePoint() { 
            if (!isTracking || !trackingState.activeLegPoints || currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) return;
            advanceToNextActivePoint();
        }

        function highlightNextStopInList() {
            document.querySelectorAll('#stopsList .stop-item').forEach(item => item.classList.remove('next-stop-highlight'));
            let nextStopName = "N/A";

            if (isTracking && trackingState.activeLegPoints && trackingState.activeLegPoints.length > 0 && 
                currentSegmentStartIndex < trackingState.activeLegPoints.length - 1) {
                
                let displayableNextTarget = null;
                // Find next non-waypoint target for display in "Next Stop"
                for(let i = currentSegmentStartIndex + 1; i < trackingState.activeLegPoints.length; i++){
                    if(trackingState.activeLegPoints[i].pointCategory !== 'waypoint'){
                        displayableNextTarget = trackingState.activeLegPoints[i];
                        break;
                    }
                }
                // If no non-waypoint found, but there IS a next point (must be waypoint)
                if (!displayableNextTarget && trackingState.activeLegPoints.length > currentSegmentStartIndex +1 ) {
                     displayableNextTarget = trackingState.activeLegPoints[currentSegmentStartIndex + 1];
                }


                if(displayableNextTarget) {
                    nextStopName = displayableNextTarget.name;
                    // Highlight in the actual list (which only shows stops/endpoints)
                    const listPoints = getSortedRoutePointsForDisplay(); 
                    const displayIndexInList = listPoints.findIndex(dp => dp.id === displayableNextTarget.id);
                    
                    if (displayIndexInList !== -1 && document.querySelectorAll('#stopsList .stop-item')[displayIndexInList]) {
                        document.querySelectorAll('#stopsList .stop-item')[displayIndexInList].classList.add('next-stop-highlight');
                    }
                }
            } else if (!isTracking) {
                const displayPoints = getSortedRoutePointsForDisplay();
                if (displayPoints.length > 0 && displayPoints[0].pointCategory !== 'waypoint') {
                     nextStopName = displayPoints[0].name;
                }
            }
            document.getElementById('nextStopDisplay').textContent = `Próxima: ${nextStopName}`;
        }

        function calculateTimeDeviation(currentUserGeoPosition) { 
            if (!isTracking || !trackingState.activeLegPoints || currentSegmentStartIndex >= trackingState.activeLegPoints.length - 1) {
                document.getElementById('timeDeviation').textContent = "00:00";
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                return;
            }

            const pointA = trackingState.activeLegPoints[currentSegmentStartIndex];
            const pointB = trackingState.activeLegPoints[currentSegmentStartIndex + 1];

            if (!pointA || !pointB || !pointA.effectiveScheduledTime || !pointB.effectiveScheduledTime ||
                pointA.pointCategory === 'waypoint' || pointB.pointCategory === 'waypoint') { // Waypoints don't affect time deviation
                document.getElementById('timeDeviation').textContent = "N/A_T";
                document.getElementById('timeDeviation').style.color = "#FFFFFF";
                return;
            }
            const scheduledTimeA = new Date(pointA.effectiveScheduledTime);
            const scheduledTimeB = new Date(pointB.effectiveScheduledTime);
            const segmentTotalScheduledMillis = scheduledTimeB.getTime() - scheduledTimeA.getTime();

            if (segmentTotalScheduledMillis <= 0 && !(scheduledTimeA.getTime() === scheduledTimeB.getTime() && pointA.id === pointB.id) ) { 
                document.getElementById('timeDeviation').textContent = "ERR_DUR";
                document.getElementById('timeDeviation').style.color = "#FFA500";
                return;
            }

            const latLngA = L.latLng(pointA.lat, pointA.lng);
            const latLngB = L.latLng(pointB.lat, pointB.lng);
            const currentUserLatLng = L.latLng(currentUserGeoPosition.coords.latitude, currentUserGeoPosition.coords.longitude);
            const distanceTotalSegment = latLngA.distanceTo(latLngB);
            let progressPercentage;

            if (distanceTotalSegment < 1.0) { 
                progressPercentage = 0; 
                 const now = new Date();
                let expectedTimeAtCurrentPosMillis;
                if (now.getTime() > (scheduledTimeA.getTime() + segmentTotalScheduledMillis / 2)) {
                    expectedTimeAtCurrentPosMillis = scheduledTimeB.getTime();
                } else {
                    expectedTimeAtCurrentPosMillis = scheduledTimeA.getTime();
                }
                const deviationMillisSpecial = expectedTimeAtCurrentPosMillis - now.getTime();
                displayDeviation(deviationMillisSpecial);
                return;
            }
            
            const distToA = currentUserLatLng.distanceTo(latLngA); 
            const distToB = currentUserLatLng.distanceTo(latLngB); 
            if (distToA < 10.0) progressPercentage = 0.0; 
            else if (distToB < 10.0) progressPercentage = 1.0; 
            else if (Math.abs(distToA - (distanceTotalSegment + distToB)) < 20.0 && distToA > distanceTotalSegment) progressPercentage = 1.0; 
            else if (Math.abs(distToB - (distanceTotalSegment + distToA)) < 20.0 && distToB > distanceTotalSegment) progressPercentage = 0.0; 
            else { 
                const dist_A_to_P_prime_on_AB = (Math.pow(distanceTotalSegment, 2) + Math.pow(distToA, 2) - Math.pow(distToB, 2)) / (2 * distanceTotalSegment);
                progressPercentage = dist_A_to_P_prime_on_AB / distanceTotalSegment;
            }
            progressPercentage = Math.max(0, Math.min(1, progressPercentage)); 

            const expectedTimeElapsedMillis = segmentTotalScheduledMillis * progressPercentage;
            const expectedTimeAtCurrentPosition = new Date(scheduledTimeA.getTime() + expectedTimeElapsedMillis);
            const currentTime = new Date();
            const deviationMillis = expectedTimeAtCurrentPosition.getTime() - currentTime.getTime();
            displayDeviation(deviationMillis);
        }

        function displayDeviation(deviationMillis) { 
            const absMillis = Math.abs(deviationMillis);
            const totalSecondsValue = Math.floor(absMillis / 1000);
            const displaySeconds = totalSecondsValue % 60;
            const totalMinutesValue = Math.floor(totalSecondsValue / 60);
            const sign = deviationMillis >= 0 ? "+" : "-";
            const formattedDeviation = `${sign}${String(totalMinutesValue).padStart(2, '0')}:${String(displaySeconds).padStart(2, '0')}`;
            const deviationDiv = document.getElementById('timeDeviation');
            deviationDiv.textContent = formattedDeviation;
            if (deviationMillis >= -59999 && deviationMillis <= 59999) deviationDiv.style.color = "#FFFFFF"; 
            else if (deviationMillis > 59999) deviationDiv.style.color = "#00FF00"; 
            else deviationDiv.style.color = "#FF0000"; 
        }
        function handleGeolocationError(error) { 
            console.error("Error de geolocalización: ", error);
            alert(`Error de geolocalización: ${error.message}.`);
            if (isTracking) stopTracking(false, "Error de geolocalización"); 
        }

        function getRouteQueue() { const q = localStorage.getItem(ROUTE_QUEUE_CACHE_KEY); return q ? JSON.parse(q) : [];}
        function saveRouteQueue(queue) { localStorage.setItem(ROUTE_QUEUE_CACHE_KEY, JSON.stringify(queue)); updateRouteQueueDisplay();}
        function addRouteToQueue() { 
            const selectedRouteName = document.getElementById('routeToQueue').value;
            if (!selectedRouteName || document.getElementById('routeToQueue').options[0]?.disabled) { 
                alert("Selecciona una ruta válida para añadir."); return;
            }
            const queue = getRouteQueue(); if (queue.includes(selectedRouteName)) { alert("Ruta ya en cola."); return; }
            queue.push(selectedRouteName); saveRouteQueue(queue); alert(`Ruta "${selectedRouteName}" añadida.`);
        }
        function updateRouteQueueDisplay() { 
            const queueDiv = document.getElementById('routeQueueDisplay'); const queue = getRouteQueue();
            if (queue.length === 0) { queueDiv.innerHTML = "Vacía."; } 
            else { let html = "<ol>"; queue.forEach(rn => { html += `<li>${rn}</li>`; }); html += "</ol>"; queueDiv.innerHTML = html; }
        }
        function clearRouteQueue() { if (confirm("¿Limpiar toda la cola?")) saveRouteQueue([]);}
        function checkRouteQueue() { 
            let queue = getRouteQueue();
            if (queue.length > 0) {
                const nextRouteName = queue.shift(); saveRouteQueue(queue); 
                if (confirm(`Ruta finalizada. ¿Iniciar siguiente: "${nextRouteName}"?`)) {
                    const savedRoutesSelect = document.getElementById('savedRoutes');
                    if (Array.from(savedRoutesSelect.options).some(opt => opt.value === nextRouteName)) {
                        savedRoutesSelect.value = nextRouteName; loadRoute(); 
                        setTimeout(() => { 
                            const lineEndpoints = routePoints.filter(p=>p.pointCategory==='lineEndpoint');
                            if (lineEndpoints.length >=2 && lineEndpoints.find(ep=>ep.isFirstEndpoint) && lineEndpoints.find(ep=>!ep.isFirstEndpoint)) {
                                startTracking();
                            } else {
                                alert("Error al cargar ruta de cola o es inválida (P1/P2 faltantes o mal configurados).");
                            }
                        }, 500); 
                    } else alert(`Ruta "${nextRouteName}" no encontrada.`);
                } else alert("Siguiente ruta no iniciada.");
            }
        }

        function updateGlobalStopRadiusSettings() { 
            const newRadius = parseInt(document.getElementById('stopRadiusInput').value, 10);
            if (!isNaN(newRadius) && newRadius >= 10 && newRadius <= 500) {
                currentStopRadius = newRadius;
                routePoints.forEach(point => {
                    if (point.radiusCircle) point.radiusCircle.setRadius(currentStopRadius);
                });
            } else {
                alert("Radio inválido (10-500m).");
                document.getElementById('stopRadiusInput').value = currentStopRadius;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initMap(); // Calls updateRouteSettings, which sets currentEditingFlagView and button text
            loadSavedRoutesLists(); 
            updateStopsList(); 
            updateManualNavButtons(); 
            setActiveMode(null); 
            updateTrackingStatusDisplay();
        });

    </script>
</body>
</html>
